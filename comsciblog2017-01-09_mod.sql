
-- phpMyAdmin SQL Dump
-- version 3.5.2.2
-- http://www.phpmyadmin.net
--
-- Hoszt: localhost
-- Létrehozás ideje: 2017. jan. 09. 20:18
-- Szerver verzió: 10.0.28-MariaDB
-- PHP verzió: 5.2.17

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Adatbázis: `u556670428_blog`
--

-- --------------------------------------------------------

--
-- Tábla szerkezet: `category`
--

CREATE TABLE IF NOT EXISTS `category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_name` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `category_desc` text COLLATE utf8_unicode_ci NOT NULL,
  `lang` varchar(10) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`category_id`),
  UNIQUE KEY `category_id` (`category_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=4 ;

--
-- A tábla adatainak kiíratása `category`
--

INSERT INTO `category` (`category_id`, `category_name`, `category_desc`, `lang`) VALUES
(1, 'Project Euler megoldások', 'Ez a kategória a <a href="http://projecteuler.net"> Project Euler </a> feladatainak megoldásait tartalmazza, rövid magyarázatokkal. Érdekes lehet, ha valaki elakadt egy feladat során, vagy csak szívesen olvasna egyszer&#369;bb programozási/matematikai feladatok megoldási módszereir&#337;l. A végeredmény kimásolása helyett javaslom az adott probléma/megoldás megértését. Ha valami nem világos, hozzászólásban lehet segítséget kérni!', 'hu'),
(2, 'Advent of Code', 'Ebben a kategóriában a (2015. évi) <a href="http://adventofcode.com">Advent of Code</a> programozási feladatai, és az általam elkészített megoldási találhatók.', 'hu'),
(3, 'Algoritmusok, adatszerkezetek', 'Ezen az oldalon különféle alapvet&#337; algoritmusokat és adatszerkezeteket mutatok be. A bejegyzések viszonylag tömörek, de általában C/C++ nyelv&#369; forráskód tartozik hozzájuk. Hasznos lehet középiskolásoknak, egyetemistáknak, illetve önállóan tanulni vágyó kezd&#337; programozóknak is.', 'hu');

-- --------------------------------------------------------

--
-- Tábla szerkezet: `comment`
--

CREATE TABLE IF NOT EXISTS `comment` (
  `comment_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `post_id` int(11) NOT NULL,
  `writer` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `text` text COLLATE utf8_unicode_ci NOT NULL,
  `cookie_name` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  PRIMARY KEY (`comment_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=5 ;

--
-- A tábla adatainak kiíratása `comment`
--

INSERT INTO `comment` (`comment_id`, `post_id`, `writer`, `text`, `cookie_name`, `created_at`, `updated_at`) VALUES
(3, 45, 'sd', 'jhgfd', 'comsci-comment-42f3819aa4ea50fc73e1419c5b1dbd1a45cdb382', '2015-10-26 02:23:08', '2015-10-26 02:23:08'),
(4, 65, 'Én', 'nem vagyok robot.', 'comsci-comment-d900582352ba59a41b645cf6939e71f0d14023e2', '2016-05-26 06:29:35', '2016-05-26 06:29:35');

-- --------------------------------------------------------

--
-- Tábla szerkezet: `image`
--

CREATE TABLE IF NOT EXISTS `image` (
  `image_id` int(11) NOT NULL AUTO_INCREMENT,
  `image_path` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`image_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=76 ;

--
-- A tábla adatainak kiíratása `image`
--

INSERT INTO `image` (`image_id`, `image_path`) VALUES
(54, 'img/heapify.gif'),
(2, 'img/which-programming-language-infographic-hun.png'),
(3, 'img/grid.png'),
(4, 'img/Broken_keyboard2.jpg'),
(5, 'img/Collatz.png'),
(6, 'img/ascii_christmas_tree.png'),
(7, 'img/santa_elves.gif'),
(8, 'img/web_console.png'),
(19, 'img/eng_hun_flag.png'),
(10, 'img/A-nagy-karácsonyi-izzócsata-9.jpg'),
(11, 'img/uncle_santa wants_you.jpg'),
(12, 'img/do_or_do_not.jpg'),
(20, 'img/stack_image.png'),
(14, 'img/catch_em_all.png'),
(15, 'img/terminator.jpg'),
(18, 'img/Frozen_sven.jpg'),
(17, 'img/cpp_vs_java.jpg'),
(21, 'img/factorial_stack.png'),
(22, 'img/queue_anim.gif'),
(23, 'img/queue.png'),
(24, 'img/types_of_linked_lists.png'),
(25, 'img/linked-list.png'),
(26, 'img/garfield_laza_vasarnap.jpg'),
(27, 'img/honap_butyok.jpg'),
(28, 'img/web_console.png'),
(29, 'img/santa_elves.gif'),
(30, 'img/uncle_santa wants_you.jpg'),
(31, 'img/A-nagy-karácsonyi-izzócsata-9.jpg'),
(32, 'img/which-programming-language-infographic-hun.png'),
(33, 'img/grid.png'),
(34, 'img/amort_search_tree.gif'),
(55, 'img/max_heap_delete.gif'),
(36, 'img/binary_search_tree.png'),
(37, 'img/binary_search_tree_insert.gif'),
(38, 'img/binary_search_tree_search.gif'),
(39, 'img/notepad01.png'),
(40, 'img/notepad02_encoding.png'),
(41, 'img/notepad03_syntax.png'),
(42, 'img/notepad04_lang.png'),
(43, 'img/notepad05_kieg.png'),
(44, 'img/notepad06_stilus.png'),
(45, 'img/notepad07_plugin.png'),
(46, 'img/notepad08_explorer.png'),
(47, 'img/notepad09_spellcheck.png'),
(48, 'img/notepad10_ftp.png'),
(49, 'img/notepad11_run_firefox.png'),
(50, 'img/notepad12_compile.png'),
(51, 'img/notepad13_nppexec.png'),
(52, 'img/npp_cute.png'),
(53, 'img/path.png'),
(56, 'img/max_heap_build.gif'),
(57, 'img/max_heap_example.jpg'),
(58, 'img/tree_heap_xkcd.png'),
(59, 'img/aboutprogramming_hun.png'),
(60, 'img/happy_birthday_paradox.png'),
(61, 'img/birthday_paradox_chart.png'),
(62, 'img/facebook_graph.png'),
(63, 'img/konigsberg_bridges.png'),
(64, 'img/konigsberg_bridges_graph.gif'),
(72, 'img/site_adj_matrix_w02.png'),
(73, 'img/site_adj_matrix_uw02.png'),
(74, 'img/site_inc_matrix.png'),
(75, 'img/site_graph_uw_w.png');

-- --------------------------------------------------------

--
-- Tábla szerkezet: `keyword`
--

CREATE TABLE IF NOT EXISTS `keyword` (
  `keyword_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `post_id` int(11) NOT NULL,
  `keyword` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `lang` varchar(10) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`keyword_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=289 ;

--
-- A tábla adatainak kiíratása `keyword`
--

INSERT INTO `keyword` (`keyword_id`, `post_id`, `keyword`, `lang`) VALUES
(115, 41, 'Project Euler', 'hu'),
(114, 41, 'programozás', 'hu'),
(113, 41, 'C nyelv', 'hu'),
(157, 49, 'Project Euler', 'hu'),
(27, 26, 'oszthatóság', 'hu'),
(26, 26, 'Project Euler', 'hu'),
(28, 26, 'C nyelv', 'hu'),
(29, 26, 'programozás', 'hu'),
(30, 26, 'számtani sorozat', 'hu'),
(31, 34, 'programozás', 'hu'),
(32, 34, 'Project Euler', 'hu'),
(33, 34, 'C nyelv', 'hu'),
(34, 34, 'Fibonacci', 'hu'),
(35, 34, 'rekurzió', 'hu'),
(36, 34, 'nyuszikák', 'hu'),
(59, 35, 'iterátor', 'hu'),
(58, 35, 'palindrom', 'hu'),
(89, 36, 'oszthatóság', 'hu'),
(56, 35, 'Project Euler', 'hu'),
(55, 35, 'programozás', 'hu'),
(60, 35, 'számelmélet', 'hu'),
(61, 35, 'CPP', 'hu'),
(88, 36, 'CPP', 'hu'),
(87, 36, 'Project Euler', 'hu'),
(86, 36, 'C nyelv', 'hu'),
(85, 36, 'számelmélet', 'hu'),
(84, 36, 'prímek', 'hu'),
(83, 36, 'összetett számok', 'hu'),
(90, 36, 'számelmélet alaptétele', 'hu'),
(91, 36, 'prímfelbontás', 'hu'),
(100, 37, 'Project Euler', 'hu'),
(99, 37, 'teljes indukció', 'hu'),
(98, 37, 'számtani sorozat', 'hu'),
(97, 37, 'C nyelv', 'hu'),
(101, 37, 'programozás', 'hu'),
(102, 37, 'véges sorösszeg', 'hu'),
(103, 38, 'programozási nyelvek', 'hu'),
(104, 38, 'infógrafika', 'hu'),
(105, 38, 'A Gy&#369;r&#369;k ura', 'hu'),
(106, 39, 'C nyelv', 'hu'),
(107, 39, 'programozás', 'hu'),
(108, 39, 'Project Euler', 'hu'),
(109, 39, 'Pitagoraszi számhármas', 'hu'),
(116, 41, 'számelmélet', 'hu'),
(117, 41, 'Pitagoraszi számhármas', 'hu'),
(129, 42, 'számelmélet alaptétele', 'hu'),
(128, 42, 'számelmélet', 'hu'),
(127, 42, 'prímek', 'hu'),
(126, 42, 'összetett számok', 'hu'),
(125, 42, 'CPP', 'hu'),
(130, 42, 'Project Euler', 'hu'),
(131, 42, 'Eratoszthenész', 'hu'),
(132, 44, 'CPP', 'hu'),
(133, 44, 'programozás', 'hu'),
(134, 44, 'Project Euler', 'hu'),
(135, 44, 'fájlkezelés', 'hu'),
(136, 45, 'CPP', 'hu'),
(137, 45, 'halmazok', 'hu'),
(138, 45, 'objektumorientált', 'hu'),
(139, 45, 'OOP', 'hu'),
(140, 46, 'programozás', 'hu'),
(141, 46, 'Project Euler', 'hu'),
(142, 46, 'CPP', 'hu'),
(143, 46, 'összeadás', 'hu'),
(144, 46, 'nagy számok', 'hu'),
(145, 46, 'Big Integer', 'hu'),
(146, 47, 'C nyelv', 'hu'),
(147, 47, 'CPP', 'hu'),
(148, 47, 'programozás', 'hu'),
(149, 47, 'fájlkezelés', 'hu'),
(150, 47, 'dailyprogrammer', 'hu'),
(151, 48, 'dailyprogrammer', 'hu'),
(152, 48, 'számelmélet', 'hu'),
(153, 48, 'számelmélet alaptétele', 'hu'),
(154, 48, 'programozás', 'hu'),
(155, 48, 'prímek', 'hu'),
(156, 48, 'prímfelbontás', 'hu'),
(158, 49, 'programozás', 'hu'),
(159, 49, 'C nyelv', 'hu'),
(192, 55, 'Javascript', 'hu'),
(189, 54, 'Mikulás', 'hu'),
(188, 54, 'programozás', 'hu'),
(191, 55, 'adventofcode', 'hu'),
(190, 55, 'programozás', 'hu'),
(187, 54, 'adventofcode', 'hu'),
(196, 56, 'adventofcode', 'hu'),
(195, 56, 'programozás', 'hu'),
(197, 56, 'Mikulás', 'hu'),
(198, 57, 'adventofcode', 'hu'),
(199, 57, 'programozás', 'hu'),
(200, 57, 'Mikulás', 'hu'),
(201, 57, 'prímfelbontás', 'hu'),
(202, 57, 'Java', 'hu'),
(203, 57, 'fájlkezelés', 'hu'),
(204, 58, 'adventofcode', 'hu'),
(205, 58, 'fájlkezelés', 'hu'),
(206, 58, 'Java', 'hu'),
(207, 58, 'Mikulás', 'hu'),
(208, 59, 'programozási nyelvek', 'hu'),
(209, 59, 'programozás', 'hu'),
(210, 59, 'Project Euler', 'hu'),
(211, 59, 'ArnoldC', 'hu'),
(212, 60, 'programozási nyelvek', 'hu'),
(213, 60, 'programozás', 'hu'),
(214, 60, 'Project Euler', 'hu'),
(215, 60, 'ArnoldC', 'hu'),
(216, 60, 'adventofcode', 'hu'),
(217, 60, 'CPP', 'hu'),
(218, 60, 'Java', 'hu'),
(219, 61, 'adventofcode', 'hu'),
(220, 61, 'Java', 'hu'),
(221, 61, 'objektumorientált', 'hu'),
(222, 61, 'OOP', 'hu'),
(223, 61, 'programozás', 'hu'),
(224, 61, 'Javascript', 'hu'),
(225, 62, 'Information', 'en'),
(226, 62, 'Hungarian', 'en'),
(227, 62, 'language', 'en'),
(228, 63, 'C nyelv', 'hu'),
(229, 63, 'CPP', 'hu'),
(230, 63, 'objektumorientált', 'hu'),
(231, 63, 'OOP', 'hu'),
(232, 63, 'programozás', 'hu'),
(233, 63, 'rekurzió', 'hu'),
(234, 63, 'adatszerkezet', 'hu'),
(235, 64, 'adatszerkezet', 'hu'),
(236, 64, 'C nyelv', 'hu'),
(237, 64, 'CPP', 'hu'),
(238, 64, 'objektumorientált', 'hu'),
(239, 64, 'OOP', 'hu'),
(240, 64, 'queue', 'hu'),
(241, 65, 'CPP', 'hu'),
(242, 65, 'adatszerkezet', 'hu'),
(243, 65, 'programozás', 'hu'),
(244, 65, 'queue', 'hu'),
(245, 65, 'láncolt lista', 'hu'),
(246, 66, 'Java', 'hu'),
(247, 66, 'CPP', 'hu'),
(248, 66, 'C nyelv', 'hu'),
(249, 66, 'Project Euler', 'hu'),
(250, 66, 'Vasárnap', 'hu'),
(251, 67, 'CPP', 'hu'),
(252, 67, 'adatszerkezet', 'hu'),
(253, 67, 'láncolt lista', 'hu'),
(254, 67, 'bináris fa', 'hu'),
(255, 67, 'keresés', 'hu'),
(256, 67, 'bst', 'hu'),
(257, 67, 'logaritmikus keresés', 'hu'),
(258, 68, 'szövegszerkeszt&#337;', 'hu'),
(259, 68, 'Notepad', 'hu'),
(260, 68, 'IDE', 'hu'),
(261, 69, 'C nyelv', 'hu'),
(262, 69, 'CPP', 'hu'),
(263, 69, 'adatszerkezet', 'hu'),
(264, 69, 'heap', 'hu'),
(265, 69, 'bináris kupac', 'hu'),
(266, 69, 'kupacolás', 'hu'),
(267, 70, 'infógrafika', 'hu'),
(268, 70, 'programozási nyelvek', 'hu'),
(269, 70, 'történelem', 'hu'),
(270, 71, 'matematika', 'hu'),
(271, 71, 'kombinatorika', 'hu'),
(272, 71, 'születésnap', 'hu'),
(273, 71, 'születésnap paradoxon', 'hu'),
(274, 71, 'érdekesség', 'hu'),
(279, 72, 'gráf', 'hu'),
(278, 72, 'adatszerkezet', 'hu'),
(280, 72, 'algoritmus', 'hu'),
(281, 72, 'matematika', 'hu'),
(282, 73, 'algoritmus', 'hu'),
(283, 73, 'ArnoldC', 'hu'),
(284, 73, 'matematika', 'hu'),
(285, 73, 'összeadás', 'hu'),
(286, 73, 'érdekesség', 'hu'),
(287, 73, 'Brainfuck', 'hu'),
(288, 73, 'Turing gép', 'hu');

-- --------------------------------------------------------

--
-- Tábla szerkezet: `migrations`
--

CREATE TABLE IF NOT EXISTS `migrations` (
  `migration` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `batch` int(11) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- A tábla adatainak kiíratása `migrations`
--

INSERT INTO `migrations` (`migration`, `batch`) VALUES
('2015_06_21_132505_create_tables', 1),
('2015_07_14_142704_create_tables', 2);

-- --------------------------------------------------------

--
-- Tábla szerkezet: `post`
--

CREATE TABLE IF NOT EXISTS `post` (
  `post_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `lang` varchar(10) COLLATE utf8_unicode_ci NOT NULL,
  `text` longtext COLLATE utf8_unicode_ci NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  PRIMARY KEY (`post_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=74 ;

--
-- A tábla adatainak kiíratása `post`
--

INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(41, 'comsciblog', 'Project Euler 9 - Alternatív megoldás', 'hu', '<p><strong>A k&ouml;vetkez&#337; bejegyz&eacute;sben m&eacute;g mindig a pitagoraszi sz&aacute;mh&aacute;rmasokkal foglalkozom, &eacute;s a m&aacute;r egyszer teljes&iacute;tett Project Euler 9. feladat&aacute;ra mutatok egy alternat&iacute;v m&oacute;dszert. Ez&uacute;ttal az elemi algebrai &aacute;talak&iacute;tgat&aacute;sok helyett a Pitagoraszi sz&aacute;mh&aacute;rmasok egy sz&aacute;melm&eacute;leti tulajdons&aacute;g&aacute;t haszn&aacute;lom ki, &eacute;s &uacute;gy oldom meg a feladatot. Az algoritmus ett&#337;l nem lesz hat&eacute;konyabb, s&#337;t kev&eacute;sb&eacute; hat&eacute;kony, &aacute;m matematikailag nagyon &eacute;rdekesnek tal&aacute;ltam a felhaszn&aacute;lt t&eacute;telt, &eacute;s bizony&iacute;t&aacute;s&aacute;t.<br /><br />\n<img class="img-responsive"  src="http://comsciblog.esy.es/img/pit_szamharmas.jpg" alt="N&eacute;h&aacute;ny Pitagoraszi sz&aacute;mh&aacute;rmas" /><br /></strong>N&eacute;h&aacute;ny Pitagoraszi sz&aacute;mh&aacute;rmas. (K&eacute;p forr&aacute;sa: <a href="http://freemathresource.com/5-lessons/algebra/113-pythagorean-triples" target="_blank">freemathresource.com</a>)<strong><br /></strong></p>\n<p>El&#337;sz&ouml;r is induljunk ki egy <a title="Wikip&eacute;dia sz&oacute;cikk (angol nyelv&#369;)" href="https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple" target="_blank">Euklid&eacute;sz nev&eacute;hez f&#369;z&#337;d&#337; t&eacute;telb&#337;l</a>, amely azt &aacute;ll&iacute;tja, hogy minden $\\{a,b,c\\}$ Pitagoraszi sz&aacute;mh&aacute;rmas el&#337;&aacute;ll&iacute;that&oacute;: <br />\\[<br />&nbsp;a = k(m^2 - n^2) \\\\<br />&nbsp;b = k(2mn) \\\\<br />&nbsp;c = k(m^2 + n^2) \\]<br />alakban, ahol $k\\in \\mathbb{N}$ tetsz&#337;leges konstans, $m$ &eacute;s $n$ egym&aacute;ssal relat&iacute;v pr&iacute;mek, valamint parit&aacute;suk k&uuml;l&ouml;nb&ouml;zik. Ezt felhaszn&aacute;lva a program:</p>\n<pre><code>#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#define PERIM 1000\nint main()<br />{<br />&nbsp;&nbsp;&nbsp; int a=0, b=0, c=0 ,m=PERIM ,n=PERIM ,k;<br />&nbsp;&nbsp;&nbsp; char found=0;<br />&nbsp;&nbsp;&nbsp; for (k=1; !found &amp;&amp; m&gt;0; ++k)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (m=PERIM; m&gt;0 &amp;&amp;!found; m-=2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (n=m-1; n&gt;0 &amp;&amp; !found; n-=2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=m*m-n*n;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=2*m*n;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c=m*m+n*n;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a*a+b*b==c*c &amp;&amp; a+b+c==PERIM)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Megtalaltam a megoldast!");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found=1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; if (!found)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Nincs ilyen\\n");<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("A megoldas: a=%d b=%d c=%d\\n",a,b,c);<br />&nbsp;&nbsp;&nbsp; printf("Szorzatuk: %d\\n",a*b*c);<br />&nbsp;&nbsp;&nbsp; return 0;<br />}</code></pre>\n<p>J&oacute;l l&aacute;that&oacute;, hogy az el&#337;z&#337; bejegyz&eacute;s programj&aacute;nak egyetlen ciklus&aacute;hoz k&eacute;pest most <em>ism&eacute;t 3 egym&aacute;sba &aacute;gyazott ciklussal</em> van dolgunk, teh&aacute;t sz&aacute;m&iacute;t&aacute;selm&eacute;letileg egy&aacute;ltal&aacute;n nem jav&iacute;tott ez a fel&iacute;r&aacute;s az algoritmuson. Viszont a megold&aacute;st ez is megtal&aacute;lja, &eacute;s a t&eacute;tel szerint minden sz&aacute;mh&aacute;rmasra m&#369;k&ouml;dik!</p>\n<p><span style="text-decoration: underline;"><strong>K&eacute;rd&eacute;s: biztosan minden egyes h&aacute;romsz&ouml;get fel&iacute;rhat&oacute; &iacute;gy?</strong></span></p>\n<p>Legyen $a := m^2 - n^2$, $b := 2mn$&nbsp; &eacute;s $c := m^2 + n^2$. Ekkor behelyettes&iacute;tve a j&oacute;l ismert Pitagorasz-t&eacute;telbe megkapjuk:<br />\\[<br />&nbsp;a^2 + b^2 = (m^2 - n^2)^2 + (2mn)^2 = m^4 - 2m^2 n^2 + 4m^2 n^2 + n^4 = \\\\<br />&nbsp;= m^4 + 2m^2 n^2 + n^4 = (m^2 + n^2) = c^2 <br />\\]<br />vagyis <em>ha adott $\\{a,b,c\\}$ sz&aacute;mh&aacute;rmas fel&iacute;rhat&oacute; ilyen alakban</em>, akkor azok<em> biztosan egy der&eacute;ksz&ouml;g&#369; h&aacute;romsz&ouml;g oldalai</em>, vagyis Pitagorasz-sz&aacute;mok.</p>\n<p>Az is megmutathat&oacute;, hogy a <span style="text-decoration: underline;">minden h&aacute;romsz&ouml;g fel&iacute;rhat&oacute; a k&ouml;vetkez&#337; alakban</span>, vagyis $m$, $n$ &eacute;s $k$ seg&iacute;ts&eacute;g&eacute;vel minden ilyen sz&aacute;mh&aacute;rmas/h&aacute;romsz&ouml;g gener&aacute;lhat&oacute;!</p>\n<p>Vegy&uuml;nk $a^2 + b^2 = c^2$ pitagoraszi sz&aacute;mh&aacute;rmast, &eacute;s tegy&uuml;k fel, hogy $a$, $b$ &eacute;s $c$ relat&iacute;v pr&iacute;mek. Ezt k&ouml;nnyen megtehetj&uuml;k, mivel ha a legnagyobb k&ouml;z&ouml;s oszt&oacute;juk $k \\in \\mathbb{N}$, akkor leosztva $k$-val m&eacute;g mindig der&eacute;ksz&ouml;g&#369; h&aacute;romsz&ouml;g&uuml;nk van, csak $k$-szoros&aacute;ra zsugor&iacute;tottuk. <br />Ha h&aacute;rman relat&iacute;v pr&iacute;mek (legnagyobb k&ouml;z&ouml;s oszt&oacute;juk 1), akkor p&aacute;ronk&eacute;nt is relat&iacute;v pr&iacute;mek. <br />Ebb&#337;l az k&ouml;vetkezik, hogy $b$ &eacute;s $c$ parit&aacute;sa k&uuml;l&ouml;nb&ouml;zik: <br /><ul> <li> Mindkett&#337; p&aacute;ros nem lehet, hiszen akkor nem lenn&eacute;nek relat&iacute;v pr&iacute;mek, a legnagyobb k&ouml;z&ouml;s oszt&oacute;juk 2 t&ouml;bbsz&ouml;r&ouml;se lenne.</li> <li>Mindkett&#337; p&aacute;ratlan sem lehet, mert <ul><li> ha $a$ p&aacute;ratlan, akkor az &ouml;sszes sz&aacute;m egyar&aacute;nt p&aacute;ratlan, teh&aacute;t a parit&aacute;si szab&aacute;lyok szerint p&aacute;ratlanok n&eacute;gyzete p&aacute;ratlan, viszont k&eacute;t p&aacute;ratlan &ouml;sszege ($a^2 + b^2$) p&aacute;ros, ami nem lehet $c^2$, mivel az p&aacute;ratlan!</li><li> Viszont $a$ p&aacute;ros sem lehet, mert akkor meg $a$ &eacute;s $c$ nem lenne relat&iacute;v pr&iacute;m.</li> </ul> </ul> </p>\n<p>A Pitagorasz-t&eacute;telt &aacute;trendezve, &eacute;s a hatv&aacute;nyoz&aacute;s egy azonoss&aacute;gait kihaszn&aacute;lva: <br />\\[<br />b^2 = c^2 - a^2 = (c-a)(c+a) \\\\<br />\\frac{b^2}{c-a} = c+a \\\\<br />\\frac{b}{c-a} = \\frac{c+a}{b}<br />\\]<br />Legyen $ \\frac{m}{n} := \\frac{c+a}{b} $. Vegy&uuml;k &eacute;szre, hogy ennek a sz&aacute;mnak a reciproka, $ \\frac{n}{m}=(\\frac{c+a}{b})^{-1} = \\frac{b}{c+a}$ a n&eacute;h&aacute;ny sorral feljebb meg&aacute;llap&iacute;tott egyenl&#337;s&eacute;g szerint egyenl&#337; $\\frac{b}{c-a}$-vel. Vagyis:<br />\\[<br />&nbsp; \\begin{eqnarray}<br />&nbsp;&nbsp;&nbsp;&nbsp; \\frac{m}{n} = \\frac{c+a}{b} \\\\  \\frac{n}{m} = \\frac{b}{c-a}<br />&nbsp; \\end{eqnarray}<br />\\]<br />A k&eacute;t egyenlet &ouml;sszeadva:<br />\\[<br />&nbsp; \\frac{2c}{b} = \\frac{m}{n} + \\frac{n}{m} = \\frac{m^2+n^2}{mn} \\\\<br />&nbsp; \\frac{c}{b} =&nbsp; \\frac{m^2+n^2}{2mn}<br />\\]<br />Az els&#337; egyenletb&#337;l kivonva a m&aacute;sodik:<br />\\[<br />&nbsp; \\frac{2a}{b} = \\frac{m}{n} - \\frac{n}{m} =&nbsp; \\frac{m^2-n^2}{mn} \\\\<br />&nbsp; \\frac{a}{b} = \\frac{m^2+n^2}{2mn}<br />\\]<br />Mivel $a$,$b$ &eacute;s $c$ p&aacute;ronk&eacute;nt relat&iacute;v pr&iacute;mek, ez&eacute;rt $\\frac{c}{b}$ &eacute;s $ \\frac{a}{b}$ t&ouml;rtek nem egyszer&#369;s&iacute;thet&#337; t&ouml;rtek. Vagyis a jobb oldali sz&aacute;ml&aacute;l&oacute;nak meg kell egyezni a bal oldali sz&aacute;ml&aacute;l&oacute;val, &eacute;s a jobb oldali nevez&#337;nek is meg kell egyezni a bal oldali nevez&#337;vel, &eacute;s &iacute;gy a jobb oldali t&ouml;rt sem egyszer&#369;s&iacute;thet&#337; t&ouml;rt, teh&aacute;t $m$ &eacute;s $n$ relat&iacute;v pr&iacute;meknek kell lenni&uuml;k. Ezen k&iacute;v&uuml;l $m$ &eacute;s $n$ parit&aacute;sa is k&uuml;l&ouml;nb&ouml;zik, ugyanis mindkett&#337; nem lehet p&aacute;ros, mert a nevez&#337;k ($2mn$) p&aacute;rosak, viszont a bal oldali t&ouml;rtek k&uuml;l&ouml;nb&ouml;z&#337; parit&aacute;s&uacute; sz&aacute;mok h&aacute;nyadosai. Teh&aacute;t ha $m^2 + n^2$ p&aacute;ratlan, akkor $m^2$-nek p&aacute;rosnak, $n^2$-nek p&aacute;ratlannak kell lennie, vagy ford&iacute;tva. Ebb&#337;l pedig k&ouml;vetkezik, hogy $m$ &eacute;s $n$ parit&aacute;s&aacute;nak is k&uuml;l&ouml;nb&ouml;znie kell.</p>\n<p style="text-align: center" ><img class="img-responsive" style="margin-right: auto; margin-left: auto; display: block;" src="http://ceemrr.com/Geometry1/ExactValue/PTtable.png" alt="Pitagoraszi sz&aacute;mh&aacute;rmasok el&#337;&aacute;ll&iacute;t&aacute;sa az Euklideszi formula seg&iacute;ts&eacute;g&eacute;vel" />&nbsp;\nSz&aacute;mh&aacute;rmasok el&#337;&aacute;ll&iacute;t&aacute;sa a t&eacute;tel seg&iacute;ts&eacute;g&eacute;vel. (K&eacute;p forr&aacute;sa: <a href="http://ceemrr.com/Geometry1/ExactValue/ExactValue4.html" target="_blank">ceemrr.com</a> ) </p>\n<p><span style="text-decoration: underline;"><strong>Megjegyz&eacute;s:</strong></span></p>\n<p>A program sor&aacute;n nem haszn&aacute;ltam ki, hogy relat&iacute;v pr&iacute;mek, illetve hogy k&uuml;l&ouml;nb&ouml;z&#337; parit&aacute;s&uacute;ak, hanem az &ouml;sszes $m$ &eacute;s $n$ sz&aacute;mot kipr&oacute;b&aacute;ltam.<br />B&aacute;r ez a felbont&aacute;s a jelenlegi algoritmust nem sokban jav&iacute;totta a brute-force keres&eacute;shez k&eacute;pest, de a seg&iacute;ts&eacute;g&eacute;vel gener&aacute;lhat&oacute; az &ouml;sszes pitagoraszi sz&aacute;mh&aacute;rmas, vagyis der&eacute;ksz&ouml;g&#369; h&aacute;romsz&ouml;g. &Eacute;s szerintem ez az&eacute;rt el&eacute;g &eacute;rdekes t&eacute;ny, amit nem &aacute;rt tudni, ha m&aacute;r egyszer r&aacute;j&ouml;ttek a r&eacute;gi g&ouml;r&ouml;g&ouml;k!</p>', '2015-08-26 03:39:43', '2015-08-26 03:51:52'),
(66, 'comsciblog', 'Project Euler 19 - Számoljunk vasárnapokat!', 'hu', '<p><strong>A mai bejegyz&eacute;s sor&aacute;n ism&eacute;t egy Project Euler feladatr&oacute;l fogok &iacute;rni, konkr&eacute;tan a <a href="https://projecteuler.net/problem=19" title="Project Euler 19"> 19. feladatr&oacute;l</a>. A feladatunk, hogy &ouml;sszesz&aacute;moljuk, hogy h&aacute;ny vas&aacute;rnap volt a m&uacute;lt &eacute;vsz&aacute;zadban, azaz 1901 janu&aacute;r 1. &eacute;s 2001 december 31. k&ouml;z&ouml;tt. A feladat viszonylag egyszer&#369;en megoldhat&oacute;, ak&aacute;r an&eacute;lk&uuml;l is, hogy programot &iacute;rn&aacute;nk. &Eacute;n viszont most egy C++ &eacute;s egy Java nyelv&#369; megold&aacute;st mutatok be.<br /><br /><img class="img-responsive" src="http:&#47;&#47;comsciblog.esy.es/img/garfield_laza_vasarnap.jpg" style="width: 60%; height: 60%; margin: 0 auto 0;" alt="Kellemes, lazul&oacute;s vas&aacute;rnapot k&iacute;v&aacute;n Garfield" width="665" height="649" /><br /></strong><sub>Garfield kellemes, lazul&oacute;s vas&aacute;rnapot k&iacute;v&aacute;n. Mi pedig megsz&aacute;moljuk, hogy mennyi ilyenben is lehetett r&eacute;sze annak, aki t&uacute;l&eacute;lte a teljes XX. sz&aacute;zadot. <br/> A k&eacute;p forr&aacute;sa: <a title="K&eacute;peslap.com" href="http:&#47;&#47;www.kepeslap.com/Kellemes%20vas%E1rnapot!_IMAGEshow.asp?imageid=412515&amp;userid=27559" target="_blank">kepeslap.com</a></sub></p>\n<p>A megold&aacute;s sor&aacute;n figyelembe kell venn&uuml;nk a sz&ouml;k&#337;&eacute;veket. A sz&ouml;k&#337;&eacute;vek minden n&eacute;ggyel oszthat&oacute; &eacute;vben plusz egy napot jelentenek, felt&eacute;ve, ha az &eacute;vsz&aacute;m nem oszthat&oacute; sz&aacute;zzal, vagy n&eacute;gysz&aacute;zzal is oszthat&oacute;. Teh&aacute;t c&eacute;lszer&#369; lehet elk&eacute;sz&iacute;teni egy olyan f&uuml;ggv&eacute;nyt, ami eld&ouml;nti egy bemen&#337; &eacute;vsz&aacute;mr&oacute;l, hogy az sz&ouml;k&#337;&eacute;v-e. Itt mind&ouml;ssze a fent le&iacute;rt felt&eacute;teleket kell megval&oacute;s&iacute;tani:</p>\n<pre><code>bool isLeapYear(int year)\n{\n if (year%4==0)\n {\n   if (year%100==0)\n   {\n     if (year%400==0)\n       return true;\n     else\n       return false;\n   }\n   else\n     return true;\n }\n else\n   return false;\n}\n</code></pre>\n<p>Vagy r&ouml;videbben:</p>\n<pre><code>bool isLeapYear(unsigned year)\n{\n return !(year%4)&amp;&amp;(year%100)||!(year%400);\n}\n</code></pre>\n<p>Ha esetleg a hat&eacute;konys&aacute;g is sz&aacute;m&iacute;t:</p>\n<pre><code>bool isLeapYear(unsigned year)\n{\n return ((year &amp; 3) == 0 &amp;&amp; ((year % 25) != 0 || (year &amp; 15) == 0));\n}\n</code></pre>\n<p>Ez a megold&aacute;st az Interneten olvastam, nem saj&aacute;t szerzem&eacute;ny. A magyar&aacute;zatra nem t&eacute;rn&eacute;k ki, akit &eacute;rdekel, olvassa el ezt a <a title="Most efficient leap year test - Stackoverflow" href="http:&#47;&#47;stackoverflow.com/a/11595914" target="_blank">Stackoverflow v&aacute;laszt</a>, meg&eacute;ri.</p>\n<p>Mivel m&aacute;r tudjuk, mikor vannak sz&ouml;k&#337;&eacute;vek, meg kell tudnunk, hogy melyik h&oacute;nap h&aacute;ny napos. Ehhez el&#337;kereshet&uuml;nk egy napt&aacute;rat, <a title="H&oacute;napok hosszai a Wikip&eacute;di&aacute;n" href="https:&#47;&#47;hu.wikipedia.org/wiki/H%C3%B3nap#A_Julianus-napt.C3.A1r_.C3.A9s_a_Gergely-napt.C3.A1r_h.C3.B3napjai" target="_blank">Wikip&eacute;di&aacute;t</a>, illetve a&nbsp;<a title="Melyik h&oacute;nap 31 napos? - K&eacute;zen kisz&aacute;molva" href="http:&#47;&#47;wiki.startlap.hu/melyik-honap-31-napos/" target="_blank">b&uuml;tykeinket is haszn&aacute;lhatjuk</a>. Ezek elt&aacute;rolhat&oacute;k egy t&ouml;mbben, hogy k&eacute;s&#337;bb k&ouml;nnyebb dolgunk legyen.</p>\n<pre><code>const int MONTH_COUNT = 12;\nint month_lengths[MONTH_COUNT] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n</code></pre>\n<img src="http://comsciblog.esy.es/img/honap_butyok.jpg" class="img img-responsive" style="margin: 0 auto 0; padding: 10px;"> \n<p>Mivel mindig a h&oacute;napok els&#337; napjait keress&uuml;k, &eacute;s eleve janu&aacute;r 1-t&#337;l indulunk, nincs m&aacute;s dolgunk, mint a kisz&aacute;molt &eacute;rt&eacute;kekkel n&ouml;velgetni egy v&aacute;ltoz&oacute;t, minden &eacute;vben. Ez a sz&aacute;ml&aacute;l&oacute; (1-r&#337;l ind&iacute;tva) visszaadn&aacute;, hogy az adott h&oacute;nap els&#337; napja az adott &eacute;v hanyadik napja. Nek&uuml;nk azonban az kell, hogy ez a nap vas&aacute;rnap-e. A feladat le&iacute;r&aacute;s&aacute;ban az &aacute;ll, hogy 1901 janu&aacute;r 1-je keddre esett. 31 nappal azut&aacute;n, <em>1902. febru&aacute;r</em> elsej&eacute;n ezek alapj&aacute;n <em>p&eacute;ntek</em> volt.</p>\n<h3>Hogyan j&ouml;tt ez ki?</h3>\n<p>Janu&aacute;r 31 napos, teh&aacute;t febru&aacute;r 1. pontosan 31 nappal k&eacute;s&#337;bb van, mint janu&aacute;r 1. Mivel egy h&eacute;t pontosan h&eacute;t napb&oacute;l &aacute;ll, a <em>32 h&eacute;ttel vett oszt&aacute;si marad&eacute;k&aacute;b&oacute;l</em> megtudhatjuk, hogy keddhez k&eacute;pest h&aacute;ny nappal van k&eacute;s&#337;bb. Ha a h&eacute;t minden napj&aacute;nak egy-egy sz&aacute;mot feleltet&uuml;nk meg, [p&eacute;ld&aacute;ul H&eacute;tf&#337; = 0, Kedd = 1, &hellip;, Vas&aacute;rnap = 6] akkor k&ouml;nnyen leprogramozhat&oacute; a feladat:</p>\n<pre><code>enum Day {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY};\n\nconst int MONTH_COUNT = 12, DAYS_PER_WEEK = 7;\nint month_lengths[MONTH_COUNT] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nint main(int argc, char ** argv)\n{\n int firstDayOfMonth = TUESDAY;\n int countOfSundays = 0;\n for (int year=1901; year&lt;2001; ++year)\n {\n   for (int month=0; month&lt;MONTH_COUNT; ++month)\n   {\n     if (firstDayOfMonth == SUNDAY)\n       ++countOfSundays;\n\n     &#47;&#47;Leptetes: szokoev februarjaban 29 nap van\n     if (isLeapYear(year) &amp;&amp; month==1)\n     {\n       firstDayOfMonth+=29;\n       firstDayOfMonth%=DAYS_PER_WEEK;\n     }\n     &#47;&#47;Egyebkent a megadott honap napszamaval leptetes\n     else\n     {\n     firstDayOfMonth+=month_lengths[month];\n     firstDayOfMonth%=DAYS_PER_WEEK;\n     }\n   }\n }\n cout&lt;&lt;"\\n Vasarnapok szama: "&lt;&lt;countOfSundays&lt;&lt;endl;\n}\n</code></pre>\n<h3>Megjegyz&eacute;s</h3>\n<p>Az <strong>enum Day</strong> felsorol&aacute;st csak a k&oacute;d olvashat&oacute;s&aacute;g&aacute;&eacute;rt hoztam l&eacute;tre. Ugyanis (sz&aacute;momra) sokkal bar&aacute;ts&aacute;gosabb, ha TUESDAY &eacute;s SUNDAY olvashat&oacute; a k&oacute;dban 1 &eacute;s 6 helyett. Egy&eacute;bk&eacute;nt ugyan&uacute;gy m&#369;k&ouml;dnek, mint a sz&aacute;mok. Igen, SUNDAY/THURSDAY == WEDNESDAY :-) <br />Hasonl&oacute; okokb&oacute;l sz&aacute;molom az &eacute;veket 1901-t&#337;l 2000-ig, de ugyan&uacute;gy m&#369;k&ouml;dik a program 0-t&oacute;l 100-ig sz&aacute;molva is, mivel sehol sem haszn&aacute;ljuk ki az &eacute;veket.</p>\n<p>Alternat&iacute;v megold&aacute;s</p>\n<p>Aki sz&aacute;molgat&aacute;s helyett sz&iacute;vesebben olvas&nbsp;dokument&aacute;ci&oacute;t, vagy esetleg a kisujj&aacute;ban van a Java <a title="GregorianCalendar Java dokument&aacute;ci&oacute;" href="https:&#47;&#47;docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html" target="_blank">GregorianCalendar</a> oszt&aacute;ly&aacute;nak haszn&aacute;lata (nem &uacute;gy, mint nekem), az haszn&aacute;lhat Java nyelvet is.&nbsp;</p>\n<pre><code>import java.util.*;\n\npublic class CountingSundays \n{\n	public static void main(String[] args) \n	{\n		Calendar currentDate = GregorianCalendar.getInstance();\n		currentDate.set(1901, Calendar.JANUARY, 1); &#47;&#47;kezdodatum\n		Calendar destDate = GregorianCalendar.getInstance();\n		destDate.set(2000, Calendar.DECEMBER, 31);  &#47;&#47;celdatum\n		    \n		int counter = 0;\n		&#47;&#47;amig a jelenlegi datum kisebb, mint a cel\n		while (currentDate.before(destDate))\n		{\n		    if (currentDate.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY \n                    && currentDate.get(Calendar.DAY_OF_MONTH) == 1)\n		    {\n		        ++counter;\n		    	System.out.println(counter+". Sunday: "+currentDate.getTime());\n		    }\n	      currentDate.add(Calendar.DAY_OF_YEAR, 1); &#47;&#47;novelem a napokat\n	    }\n	}   \n}\n</code></pre>\n<h3>Megjegyz&eacute;s a feladathoz:</h3>\n<p>A feladat $100$ &eacute;vre k&eacute;rte, hogy sz&aacute;moljuk &ouml;ssze, hogy h&aacute;ny h&oacute;nap elseje volt vas&aacute;rnap. Mivel $100$ &eacute;v alatt &ouml;sszesen $12 \\cdot 100 = 1200$ h&oacute;nap volt, &eacute;s mindegyiknek volt els&#337; napja, ez&eacute;rt $1200$ h&oacute;nap elseje is volt. Mivel a h&eacute;t miden napjainak egyenletes az eloszl&aacute;sa, ez&eacute;rt nagyj&aacute;b&oacute;l ugyanannyi h&oacute;nap elseje esett vas&aacute;rnapra, mint h&eacute;tf&#337;re, vagy keddre, vagy ... szombatra.<br />\\[<br />&nbsp;\\frac{1200}{7} \\approx 171,43<br />\\]<br />K&ouml;r&uuml;lbel&uuml;l ennyi h&eacute;tf&#337;, kedd, ..., vas&aacute;rnap esett elsej&eacute;re a XX. sz&aacute;zadban. Ez kipr&oacute;b&aacute;lhat&oacute; a fenti programokkal is.</p>', '2016-05-29 11:17:20', '2016-05-29 11:56:38'),
(26, 'comsciblog', 'Project Euler 1 - C nyelven', 'hu', '<p><strong>El&eacute;rkezt&uuml;nk az els&#337; "igazi" bejegyz&eacute;shez. Itt egy igaz&aacute;n egyszer&#369; feladat megold&aacute;s&aacute;t fogom k&ouml;z&ouml;lni, C nyelven. A feladat: "Find the sum of all the multiples of 3 or 5 below 1000." vagyis megkeresni a 3 &eacute;s az 5 sz&aacute;m 1000 alatti t&ouml;bbsz&ouml;r&ouml;seinek &ouml;sszeg&eacute;t. Sz&aacute;m&iacute;t&oacute;g&eacute;ppel pillanatok alatt meghat&aacute;rozhat&oacute;, de pap&iacute;ron, tiszt&aacute;n matematikai eszk&ouml;z&ouml;kkel sem annyira bonyolult.</strong></p>\n<p>Sz&aacute;m&iacute;t&oacute;g&eacute;pes k&eacute;zenfekv&#337; megold&aacute;s: menj&uuml;nk v&eacute;gig mind az 1000 sz&aacute;mon, &eacute;s tesztelj&uuml;k, hogy az adott sz&aacute;m oszhat&oacute;-e (marad&eacute;k n&eacute;lk&uuml;l) 3-mal vagy 5-tel. Az k&ouml;z&ouml;lt k&oacute;d pontosan ezt teszi:</p>\n<pre><code>\n#include &lt;stdio.h&gt;\n#define N 1000\n\nint main(int argc, char ** argv)\n{\nint i=1;\nint sum=0;\nfor (i=1; i&lt;N; ++i)\n{\nif (i%3==0 || i%5==0)\nsum+=i;\n}\nprintf("\\n%d alatti 3-mal es 5-tel oszthatok osszege: %d\\n",N,sum);\nreturn 0;\n}\n</code></pre>\n<p style="text-align: justify;">Hogyan is m&#369;k&ouml;dik pontosan az al&aacute;bbi program? Az <strong>#include &lt;stdio.h&gt;&nbsp;</strong> seg&iacute;ts&eacute;g&eacute;vel a C be/kimenetet biztos&iacute;t&oacute; k&ouml;nyvt&aacute;t haszn&aacute;lhatjuk. Jelenleg a printf f&uuml;ggv&eacute;ny haszn&aacute;lata miatt sz&uuml;ks&eacute;ges. A <strong>#define</strong> haszn&aacute;lat&aacute;val makr&oacute;kat defini&aacute;lhatunk. Jeleneg az <strong>N</strong> &eacute;rt&eacute;ke konstans, 1000. Vagyis a forr&aacute;sk&oacute;ban valah&aacute;nyszor N-re hivatkozunk, mindannyiszor az el&#337;ford&iacute;t&oacute; N hely&eacute;re 1000-et helyettes&iacute;t be. Ha N &eacute;rt&eacute;k&eacute;t a 2. sorban megv&aacute;ltoztatjuk, akkor mindenhol megv&aacute;ltozik, &eacute;s &iacute;gy 1000 helyett haszn&aacute;lhatjuk 10000-ig, vagy ak&aacute;r csak 20-ig is. <br />A <strong>main</strong> f&uuml;ggv&eacute;ny a minden C program r&eacute;sze, vele kezd&#337;dik a v&eacute;grehajt&aacute;s. K&eacute;t param&eacute;tere van: az els&#337; a parancssori argumentumok darabsz&aacute;ma, a m&aacute;sodik az argumentumok, karakterl&aacute;ncok t&ouml;mbjek&eacute;nt. Eg&eacute;sz &eacute;rt&eacute;kkel t&eacute;r vissza, ha nincs hiba, jellemz&#337;en null&aacute;val. <br />Az <strong>i</strong> &eacute;s a <strong>sum</strong> k&eacute;t eg&eacute;sz v&aacute;ltoz&oacute;, a sum &eacute;rt&eacute;ke kezdetben 0, ez t&aacute;rolja az &ouml;sszeget. A <strong>for</strong> ciklus fejr&eacute;sze 3 r&eacute;szb&#337;l &aacute;ll: a ciklus kezdete el&#337;tt be&aacute;ll&iacute;tja i &eacute;rt&eacute;k&eacute;t 1-re; a ciklus addig megy, am&iacute;g i &eacute;rt&eacute;ke kisebb N-n&eacute;l; &eacute;s minden iter&aacute;ci&oacute;s l&eacute;p&eacute;s ut&aacute;n n&ouml;veli 1-gyel i-&eacute;rt&eacute;k&eacute;t. A ciklus magj&aacute;ban egy <strong>if</strong> felt&eacute;tel seg&iacute;t&eacute;s&eacute;gvel eld&ouml;ntj&uuml;k, hogy az adott i sz&aacute;m oszhat&oacute;-e (marad&eacute;k n&eacute;lk&uuml;l) 3-mal VAGY 5-tel. A <strong>%</strong> oper&aacute;tor az oszt&aacute;si marad&eacute;kot adja vissza, azt vizsg&aacute;ljuk, hogy nulla-e. A logikai vagy <strong>||</strong> oper&aacute;tor akkor igaz, ha valamelyik operandus&aacute;nak logikai &eacute;rt&eacute;ke igaz. Amennyiben teljes&uuml;l a felt&eacute;tel: <strong>(i%3==0 || i%5==0)</strong>, akkor n&ouml;velhetj&uuml;k sum &eacute;rt&eacute;k&eacute;t a megadott i-vel. <br />A ciklus v&eacute;g&eacute;n nem marad m&aacute;s dolgunk, mint megjelen&iacute;teni az eredm&eacute;nyt a <strong>printf</strong> f&uuml;ggv&eacute;ny seg&iacute;ts&eacute;g&eacute;vel (amit a stdio.h tartalmaz.) A <strong>printf</strong> tetsz&#337;legesen param&eacute;terezhet&#337;: els&#337; param&eacute;tere a sz&ouml;vegkonstas form&aacute;tuma: <strong>\\n</strong> sort&ouml;r&eacute;st jelent, a <strong>%d</strong> pedig a k&ouml;vetkez&#337; param&eacute;ter &eacute;rt&eacute;k&eacute;t eg&eacute;sz sz&aacute;mk&eacute;nt helyettes&iacute;ti be a sz&ouml;vegbe.</p>\n<p><span style="text-decoration: underline;"><strong>A kimenet teh&aacute;t:</strong></span></p>\n<pre><code><code><code> 1000 alatti 3-mal es 5-tel oszthatok osszege: 233168 </code></code></code></pre>\n<p>&nbsp;</p>\n<p style="text-align: justify;">A megold&aacute;s helyess&eacute;ge k&ouml;nnyed&eacute;n ellen&#337;rizhet&#337;: Egyr&eacute;szr&#337;l <a href="https://projecteuler.net/problem=1" target="_blank">a feladv&aacute;ny hivatalos oldal&aacute;n</a>, m&aacute;sr&eacute;szr&#337;l n&eacute;mi matematika seg&iacute;ts&eacute;g&eacute;vel ak&aacute;r sz&aacute;m&iacute;t&oacute;g&eacute;p n&eacute;lk&uuml;l is kisz&aacute;molhattuk volna.<br />A 3-mal / 5-tel oszthat&oacute; sz&aacute;mok ugyanis <strong>sz&aacute;mtani sorozatot</strong> alkotnak. A sz&aacute;mtani sorozatokr&oacute;l ismert, hogy a tagok k&uuml;l&ouml;nbs&eacute;ge &aacute;lland&oacute;, &eacute;s egy adott tagot kisz&aacute;molhatunk a 2 szomsz&eacute;dj&aacute;nak &aacute;tlagak&eacute;nt, &eacute;s r&eacute;szlet&ouml;sszeg-sorozatot is tudunk sz&aacute;molni a k&ouml;vetkez&#337; k&eacute;pletekkel:<br />\\[<br />&nbsp; a_n = a_1 + (n-1)d \\\\<br />&nbsp; a_n = \\frac{a_{n-1} + a_{n+1}}{2} \\\\<br />&nbsp; S_n = \\frac{a_1 + a_n}{2}n = \\frac{ 2a_1 + (n-1)d &nbsp;} {2}n<br />\\]<br />Az h&aacute;rommal oszthat&oacute; sz&aacute;mok sorozat&aacute;nak&nbsp;els&#337; tagja $a_1 = 3$, k&uuml;l&ouml;nbs&eacute;ge $d=3$. 1000 alatt <strong>333 db</strong> 3-mal oszthat&oacute; sz&aacute;m van, ugyanis $a_333 = 333 \\cdot 3 = 999$ A sorozat els&#337; 333 tagj&aacute;nak &ouml;sszege pedig $ S_333 =\\frac{3+999}{2} \\cdot 333 = 166833 $.<br />Hasonl&oacute;an az &ouml;ttel oszhat&oacute;kn&aacute;l: $a_1 = 5$, $d=5$, &eacute;s itt <strong>199db</strong> 1000 alatti elem van, mert $a_199 = 995$ ($a_200$ pontosan 1000 lenne, ami m&aacute;r nem kell.) &Iacute;gy az &ouml;sszeg: $S_199 = \\frac{5+995}{2} \\cdot 1999 = 99500$.<br /> <span style="text-decoration: underline color: red;"><strong>DE! Mi van azokkal a sz&aacute;mokkal, amelyek 3-mal &eacute;s 5-tel is oszthat&oacute;k? <br /></strong></span><br /> V&aacute;lasz: &#336;ket 2-szer sz&aacute;moltuk bele. &#336;k a 15-tel oszthat&oacute; sz&aacute;mok. N&aacute;luk $a_1 = 15$ $d=15$, &eacute;s <strong>66db</strong> van bel&#337;l&uuml;k, &eacute;s $a_66 =990$. Vagyis: $S_66 = \\frac{15+990}{2} \\cdot 66 = 33165 $, amit le kell vonnunk az el&#337;z&#337; k&eacute;t r&eacute;szlet&ouml;sszeg &ouml;sszeg&eacute;b&#337;l.<br /><span style="text-decoration: underline;"><strong>Teh&aacute;t a keresett &ouml;sszeg: </strong></span></p>\n<pre><code><code>166833+99500-33165 = 233168</code></code></pre>\n<p>Ugye, hogy nem is volt olyan neh&eacute;z? A feladat egy&eacute;bk&eacute;nt a <a href="http://projecteuler.net" target="_blank" title="Project Euler oldala"> Project Euler</a> els&#337; feladv&aacute;nya volt. Tov&aacute;bbi feladatok az oldalukon tal&aacute;lhat&oacute;k.</p>', '2015-08-06 11:45:46', '2015-08-06 03:29:35'),
(34, 'comsciblog', 'Project Euler 2 - Páros Fibonacci számok összege', 'hu', '<p><strong>A k&ouml;vetkez&#337; bejegyz&eacute;semben ism&eacute;t a Project Euler egy feladat&aacute;nak megold&aacute;s&aacute;t k&ouml;zl&ouml;m, szint&eacute;n C nyelven. A feladat a 4000000 alatti p&aacute;ros Fibonacci sz&aacute;mok &ouml;sszeg&eacute;nek megkeres&eacute;se. Egy r&ouml;vid matematika t&ouml;rt&eacute;neti bevezet&#337;t k&ouml;vet&#337;en k&eacute;tf&eacute;le megold&aacute;st ismertetek, igyekezve r&aacute;vil&aacute;g&iacute;tani az &aacute;ltalam &iacute;rt programok k&ouml;z&ouml;tti k&uuml;l&ouml;nbs&eacute;gekre, a rekurzi&oacute; tulajdons&aacute;gaira, gyenges&eacute;geire &eacute;s el&#337;nyeire, a teljess&eacute;g ig&eacute;nye n&eacute;lk&uuml;l.</strong></p>\n<p>A Fibonacci-sorozatot egy k&ouml;z&eacute;pkori it&aacute;liai matematikusr&oacute;l, a pisai Leonardo Fibonaccir&oacute;l nevezt&eacute;k el. A t&ouml;rt&eacute;net szerint a r&oacute;la elnevezett sorozatot el&#337;sz&ouml;r nyulak szaporod&aacute;s&aacute;nak kapcs&aacute;n figyelte meg. Tekints&uuml;nk ugyanis 1 p&aacute;r &uacute;jsz&uuml;l&ouml;tt nyulat, amelyek 2 &eacute;v ut&aacute;n v&aacute;lnak ivar&eacute;rett&eacute;, &eacute;s minden &eacute;vben pontosan 1 p&aacute;r ny&uacute;lut&oacute;dot hoznak a vil&aacute;gra, amelyek szint&eacute;n rendelkeznek ugyanezen tulajdons&aacute;gok mindegyik&eacute;vel. Ezen k&iacute;v&uuml;l tegy&uuml;k fel, hogy a nyulak halhatatlanok. &Iacute;gy az els&#337; &eacute;v v&eacute;g&eacute;re 1 p&aacute;r nyulunk lesz (az eredeti p&aacute;r), a 2. &eacute;v v&eacute;g&eacute;re viszont 2 p&aacute;r. A 3. &eacute;v v&eacute;g&eacute;re az eredeti p&aacute;rnak ism&eacute;t lesz &uacute;jabb &uacute;t&oacute;d p&aacute;rja, &iacute;gy 3 p&aacute;r nyulunk lesz. A 4. &eacute;vben azonban a 2. &eacute;v nyulai is &eacute;rettek lesznek (&eacute;s persze az &#337;seik is), &iacute;gy a 4. &eacute;vben 5, majd az 5.-ben m&aacute;r a 3. &eacute;vben sz&uuml;letetteknek is lesz &uacute;t&oacute;djuk, &iacute;gy m&aacute;r 8, &eacute;s &iacute;gy tov&aacute;bb...Vagyis a sorozat els&#337; n&eacute;h&aacute;ny eleme: 0,1,1,2,3,5,8... azaz minden sz&aacute;m az &#337;t megel&#337;z&#337; k&eacute;t sz&aacute;m &ouml;sszegek&eacute;nt kaphat&oacute;. Form&aacute;lisabban, a Fibonacci-sorozat egy rekurz&iacute;v sorozat, amelynek hozz&aacute;rendel&eacute;si szab&aacute;lya:</p>\n<p>&nbsp;</p>\n<p style="text-align: center;"><img src="https://upload.wikimedia.org/math/c/3/7/c37529f8e6fdf180b54aa8e86166029f.png" alt="Fibonacci-sorozat rekurz&iacute;v defin&iacute;ci&oacute;ja" width="274" height="84" /></p>\n<p>&nbsp;</p>\n<p><strong>1. megold&aacute;s: rekurz&iacute;&oacute;val</strong></p>\n<p>A feladat megold&aacute;s&aacute;nak els&#337; megk&ouml;zel&iacute;t&eacute;se: &iacute;rjunk egy olyan f&uuml;ggv&eacute;nyt, amely kisz&aacute;m&iacute;tja a a k. Fibonacci-sz&aacute;mot. Vagyis ha $k=0$, akkor $fib(k)=0$, ha $k=1$ akkor $fib(k)=1$, egy&eacute;bk&eacute;nt pedig $fib(k) = fib(k-1) + fib(k-2)$, rekurz&iacute;v defin&iacute;ci&oacute; alapj&aacute;n. Teh&aacute;t a forr&aacute;s szinte trivi&aacute;lis:</p>\n<pre> <code>\n#include &lt;stdio.h&gt;\n#define N 4000000\n\nint fib(int n)\n{\n    if (n&lt;2)\n        return 1;\n    else\n        return fib(n-2)+fib(n-1);\n}\n\nint main(int argc, char ** argv)\n{\n   int n=1, sum=0;\n   for (n=1; fib(n)&lt;N; ++n)\n   {\n      if (fib(n)%2 == 1)\n        sum+=fib(n);\n   }\n    printf("A paros %d alatti Fibonacci-szamok osszege: %d",N,sum);\n    return 0;\n}\n</code> </pre>\n<p>Az eredm&eacute;ny pedig: A paros 4000000 alatti Fibonacci-szamok osszege: 4613732</p>\n<p>Vizsg&aacute;ljuk meg kicsit a program hat&eacute;konys&aacute;g&aacute;t: Ha p&eacute;ld&aacute;ul az 5. elemre van sz&uuml;ks&eacute;gem, ahhoz ismernem kell a 4.-et &eacute;s a 3.-at. De a 4-hez ismernem kell a 3.-at &eacute;s 2.-at, a 3.-hoz a 2.-at &eacute;s az els&#337;t, amely 1, a 2.-hoz pedig az 1.-t &eacute;s a 0.-at, ami ugye 1+0 = 1. Most, hogy megvan a 2., ki tudom sz&aacute;molni a 3.-at: 1+1=2. Most, hogy tudjuk a 3.-at, ki tudn&aacute;nk sz&aacute;molni a 4.-et, ha ismern&eacute;nk a 2.-at. Viszont a sz&aacute;m&iacute;t&oacute;g&eacute;p &uacute;jra fogja sz&aacute;molni, majd a ha m&aacute;r megvan a 4., az 5.-hez &uacute;jra sz&aacute;molja a 3.-at, ugyan&uacute;gy, ahogy az im&eacute;nt le&iacute;rtam. Az al&aacute;bbi &aacute;br&aacute;n a rekurzi&oacute; f&aacute;ja l&aacute;that&oacute;, amely ezt nagyon j&oacute;l szeml&eacute;lteti.</p>\n<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://mitpress.mit.edu/sicp/chapter1/fib-tree.gif" alt="Fibonacci rekurzi&oacute; f&aacute;ja" width="437" height="359" /></p>\n<p style="text-align: center;"><strong>fib(5) Rekurzi&oacute;j&aacute;nak f&aacute;ja (K&eacute;p forr&aacute;sa: <a title="MIT egyetem honlapja" href="https://mitpress.mit.edu/sicp/chapter1/node13.html" target="_blank"> MIT honlapja</a>)</strong></p>\n<p style="text-align: left;"><strong> 2. megold&aacute;s: ciklikusan &nbsp;</strong></p>\n<p>Vagyis m&aacute;r kev&eacute;s tagra is <em>viszonylag m&#369;veletig&eacute;nyes</em>, a feladat m&eacute;ret&eacute;nek n&ouml;vel&eacute;s&eacute;vel pedig rohamosan n&#337; a sz&aacute;mol&aacute;sig&eacute;ny: exponenci&aacute;lis fut&aacute;sid&#337;vel rendelkezik. (Mert ugye Fib(10000) = Fib(9999)+Fib(9998), de Fib(9999)=Fib(9998)+Fib(9997) ... hadd ne folytassam.) Viszont j&oacute; h&iacute;r, hogy az egyes elemek rekurzi&oacute; n&eacute;lk&uuml;l, csup&aacute;n egyetlen ciklussal, line&aacute;ris fut&aacute;sid&#337; alatt meghat&aacute;rozhat&oacute;k! A 0. &eacute;s 1. tagot tudjuk, a jelenlegit pedig a kett&#337; &ouml;sszegek&eacute;nt kapjuk. Nincs m&aacute;s dolgunk, mint t&aacute;rolni az "el&#337;z&#337;" &eacute;s az "el&#337;z&#337; el&#337;tti" tagot, &eacute;s &ouml;sszeadni. A k&ouml;vetkez&#337; iter&aacute;ci&oacute;ban pedig a jelenlegi "el&#337;z&#337;" lesz az "el&#337;z&#337; el&#337;tti" a jelenleg kisz&aacute;molt pedig az "el&#337;z&#337;". (A r&eacute;gi "el&#337;z&#337; el&#337;ttire" m&aacute;r nincs t&ouml;bb&eacute; sz&uuml;ks&eacute;g&uuml;nk.) &Iacute;gy a k&oacute;d: &nbsp;</p>\n<pre><code>#include &lt;stdio.h&gt;\n#define N 4000000\n\nint main(int argc, char ** argv)\n{\n    int prev=1, prev_prev=1, curr=2, sum=0;\n    while(curr&lt;N)\n    {\n        if (!(curr&amp;1))\n            sum+=curr;\n        prev_prev=prev;\n        prev=curr;\n        curr = prev+prev_prev;\n    }\n    printf("A paros %d alatti Fibonacci-szamok osszege: %d\\n",N,sum);\n    return 0;\n}\n</code></pre>\n<p><strong>Az eredm&eacute;ny pedig: </strong> </p>\n<p>A paros 4000000 alatti Fibonacci-szamok osszege: 4613732</p>\n<p>Megjegyz&eacute;s: Az<strong> if (!(curr&amp;1))</strong> felt&eacute;tel &eacute;rtelmez&eacute;s&eacute;hez tudni kell azt, hogy a C/C++ a <em>0 sz&aacute;m&eacute;rt&eacute;ket HAMIS</em> logikai &eacute;rt&eacute;knek tekinti, <em>minden egy&eacute;b sz&aacute;m&eacute;rt&eacute;ket IGAZ</em> &eacute;rt&eacute;knek. Az &amp; bitenk&eacute;nti &Eacute;S oper&aacute;tor, ami azt jelenti, hogy a 2 operandus&aacute;nak bitjein v&eacute;gzi a m&#369;veletet, &eacute;s nem az logikai &eacute;rt&eacute;k&uuml;k&ouml;n. P&eacute;ld&aacute;ul $00110011 &amp; 01010101 = 00010001$. Ha valamihez 1-et "&eacute;sel&uuml;nk hozz&aacute;" bitenk&eacute;nt, akkor az eredm&eacute;ny vagy 000....001 vagy 000...000 lesz, att&oacute;l f&uuml;gg&#337;en, hogy az eredeti sz&aacute;munk utols&oacute; bitje 0 vagy 1. Ha az utols&oacute; bit 0 (vagyis hamis), akkor a sz&aacute;m p&aacute;ros, ha 1 (vagyis igaz), akkor p&aacute;ratlan.</p>', '2015-08-11 08:16:36', '2015-08-11 03:53:36'),
(35, 'comsciblog', 'Project Euler 04 - Indul a görög aludni!', 'hu', '<p><strong>Ma egy &uacute;jabb Project Euleres feladatot fogok bemutatni, nevezetesen a 4.-et. A feladat, hogy keress&uuml;k meg a legnagyobb palindromsz&aacute;mot, amely 2 h&aacute;romjegy&#369; sz&aacute;m szorzatak&eacute;nt el&#337;&aacute;ll&iacute;that&oacute;. A megval&oacute;s&iacute;t&aacute;s nyelve ez&uacute;ttal C++ lesz, mivel ki fogom haszn&aacute;lni a C++ n&eacute;h&aacute;ny nyelvi saj&aacute;toss&aacute;g&aacute;t a feladat megval&oacute;s&iacute;t&aacute;s&aacute;nak megk&ouml;nny&iacute;t&eacute;se &eacute;rdek&eacute;ben.</strong></p>\r\n<p><strong>Mi is az a palindrom?</strong> <br /> A palindrom olyan sz&oacute; vagy sz&oacute;kapcsolat, amely visszafel&eacute; olvasva is ugyanazt jelenti. A palindromsz&aacute;mok ezzel anal&oacute;g m&oacute;don olyan (10-es sz&aacute;mrendszerbeli) sz&aacute;mok, amelyek <em>sz&aacute;mjegyeit visszafel&eacute; olvasva ugyanaz az &eacute;rt&eacute;k&uuml;k</em>. Vagyis egy $k$ sz&aacute;mjegy&#369; (t&iacute;zes sz&aacute;mrendszerbeli) $\\sum_{i=0}^k a_i \\cdot 10^i$ sz&aacute;m akkor &eacute;s csak akkor palindrom, ha $a_i = a_{k-i}$ minden $a_i (i=0...k)$ sz&aacute;mjegyre. (Tov&aacute;bbi inform&aacute;ci&oacute;: <a title="Palindromsz&aacute;mok sz&oacute;cikk" href="https://hu.wikipedia.org/wiki/Palindromsz%C3%A1mok" target="_blank">Wikip&eacute;dia</a>)</p>\r\n<p>A programom sor&aacute;n el&#337;&aacute;ll&iacute;tom az &ouml;sszes h&aacute;romjegy&#369; sz&aacute;m szorzat&aacute;t. Mivel 900 darab h&aacute;romjegy&#369; sz&aacute;m van, ez&eacute;rt ezt $900\\times900 = 810000$ szorz&aacute;s &aacute;r&aacute;n tehetem meg, teh&aacute;t n&eacute;gyzetes fut&aacute;sid&#337;ben. Az &iacute;gy kapott 6/7 jegy&#369; sz&aacute;mokr&oacute;l pedig eld&ouml;ntj&uuml;k, hogy palindrom-e. <br /> <strong>Teh&aacute;t a k&oacute;d "v&aacute;za":</strong></p>\r\n<pre><code>#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;sstream&gt;\r\nusing namespace std;\r\n\r\nbool is_palindrome(string text);\r\nstring num2string(int num);\r\n\r\nint main(int argc, char ** argv)\r\n{\r\n    int max = 0;\r\n    for (int i=100; i&lt;1000; ++i)\r\n    {\r\n        for (int j=100; j&lt;1000; ++j)\r\n        {\r\n           int prod = i*j;\r\n           string prod_str = num2string(prod);\r\n           if (is_palindrome(prod_str) &amp;&amp; prod&gt;max )\r\n               max = prod;\r\n        }\r\n    }\r\n    cout&lt;&lt;"Max: "&lt;&lt;max&lt;&lt;endl;\r\n    return 0;\r\n}</code></pre>\r\n<p>Az <strong>#include</strong> sorok hasonl&oacute;ak a hagyom&aacute;nyos C programok include soraihoz. A program sor&aacute;n c&eacute;lszer&#369; haszn&aacute;lni az std n&eacute;vteret, ugyanis a <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank">C++ standard objektumai</a>, templatei, algoritmusai (pl.: cout, cin, string, vector, sort...) az std-n kereszt&uuml;l &eacute;rhet&#337;k el. A main f&uuml;ggv&eacute;ny el&#337;tt, 2 f&uuml;ggv&eacute;ny protot&iacute;pusa tal&aacute;lhat&oacute;, amire k&eacute;s&#337;bb visszat&eacute;rek. A <strong>mainben</strong> pedig el&#337;&aacute;ll&iacute;tjuk az &ouml;sszes 3-jegy&#369; sz&aacute;m (<em>i &eacute;s j</em>) szorzat&aacute;t, &eacute;s (n&eacute;mi konvert&aacute;l&aacute;s ut&aacute;n) tesztelj&uuml;k, hogy palindrom-e a sz&aacute;m, valamint, hogy a palindromszorzat nagyobb-e a jelenlegi maximumn&aacute;l (<em>maximumkiv&aacute;laszt&aacute;s</em>).&nbsp;</p>\r\n<p><br /> <strong>De hogyan is n&eacute;zz&uuml;k meg, hogy a sz&aacute;m palindrom-e?</strong> <br /><br /> Mint m&aacute;r le&iacute;rtam, a ($k$ jegy&#369;)palindromsz&aacute;mok els&#337; sz&aacute;mjegye megegyezik az utols&oacute; ($k.$) jeggyel, az $2.$ a $k-1.$ jeggyel, &eacute;s &iacute;gy tov&aacute;bb. Ahhoz, hogy az egyes sz&aacute;mjegyeire egyenk&eacute;nt tudjunk hivatkozni, j&oacute; megold&aacute;s lehet karakterl&aacute;ncc&aacute; (stringg&eacute;) alak&iacute;tani a k&iacute;v&aacute;nt sz&aacute;mot. A num2string f&uuml;ggv&eacute;ny pontosan ezt teszi:</p>\r\n<pre><code>string num2string(int num)\r\n{\r\n	string result = "";\r\n	while(num &gt; 0)\r\n	{\r\n		result.push_back(num%10+&apos;0&apos;);\r\n		num/=10;\r\n	}\r\n	//string megforditasa:\r\n	int N = result.size();\r\n	for (int i=0; i&lt;N/2; ++i)\r\n	{\r\n		char tmp = result[i];\r\n		result[i] = result[N-1-i];\r\n		result[N-1-i] = tmp;\r\n	}\r\n	return result;\r\n}\r\n</code></pre>\r\n<p>A f&uuml;ggv&eacute;ny 2 r&eacute;szb&#337;l &aacute;ll. Az egyikben a kapott param&eacute;tert <strong>num</strong> addig osztja 10-zel, am&iacute;g nagyobb null&aacute;n&aacute;l, &eacute;s a jelenlegi sz&aacute;m utols&oacute; sz&aacute;mjegy&eacute;t (<strong>num%10</strong>) hozz&aacute;f&#369;zi a jelenlegi (kezdetben &uuml;res) <strong>result</strong> eredm&eacute;nystringhez. A +&apos;0&apos; r&eacute;szre az&eacute;rt van sz&uuml;ks&eacute;g, hogy <em>ne a sz&aacute;mot</em>, hanem az adott <em>sz&aacute;mkaraktert</em> f&#369;zze a string v&eacute;g&eacute;re. Ez&eacute;rt ell kell tolnunk a <em>0 karakter ASCII-k&oacute;dj&aacute;val (48)</em>. Vagyis 0+&apos;0&apos;=&apos;0&apos;(48), 1+&apos;0&apos;=&apos;1&apos; (49) ... 9+&apos;0&apos;=&apos;9&apos;(57). Viszont az &iacute;gy kapott karakterl&aacute;nc <em> ford&iacute;tottja az eredeti sz&aacute;mnak </em>. Ez&eacute;rt meg kell ford&iacute;tani a stringet. A megford&iacute;t&aacute;st pedig &uacute;gy v&eacute;gzi, hogy a 0. karaktert az utols&oacute;val (N-1.) cser&eacute;li ki, az 1.-t az N-2.-kell, &eacute;s &iacute;gy tov&aacute;bb, N/2-ig. <br /><strong> Mi&eacute;rt N/2-ig? </strong>Ugyanis ha N-ig menne, akkor az els&#337; N/2 l&eacute;p&eacute;sben megcser&eacute;ln&eacute;, majd az ut&aacute;na j&ouml;v&#337; N/2 l&eacute;p&eacute;sben <em>visszacser&eacute;ln&eacute;</em> a karaktereket, &iacute;gy tulajdonk&eacute;ppen nem csin&aacute;lna semmit.</p>\r\n<p>De van a konvert&aacute;l&aacute;sra C++-ban egy egyszer&#369;bb m&oacute;d is, ahol felhaszn&aacute;ljuk a C++ streameket. Ez&eacute;rt kellett az <strong>#include </strong> a program elej&eacute;re. <br /><br /><strong>A konvert&aacute;l&aacute;s egyszer&#369;bb m&oacute;dja:</strong></p>\r\n<pre><code>\r\nstring num2string(int num)\r\n{\r\n   stringstream ss;\r\n   ss&lt;&lt;num;\r\n   return ss.str();\r\n}</code></pre>\r\n<p>A m&aacute;sik hi&aacute;nyz&oacute; f&uuml;ggv&eacute;ny azt hivatott eld&ouml;nteni, hogy palindrom-e az megadott <em>sz&ouml;veg</em>(!). Igen, a f&uuml;ggv&eacute;ny haszn&aacute;lhat&oacute; tetsz&#337;leges sz&ouml;vegekre, nem csak sz&aacute;mokra! Ez&eacute;rt is kellett a konvert&aacute;l&aacute;s az el&#337;bb.</p>\r\n<pre><code>\r\nbool is_palindrome(string text)\r\n{\r\n  int N = text.size();\r\n  for (int i=0; i&lt;N/2; ++i)\r\n  {\r\n    if (text[i]!=text[N-1-i])\r\n    return 0;\r\n  }\r\n  return 1; \r\n}\r\n</code></pre>\r\n<p style="text-align: justify;">A f&uuml;ggv&eacute;ny <em>igazzal (1)</em> t&eacute;r vissza, ha a param&eacute;terk&eacute;nt &aacute;tadott sz&ouml;veg palindrom, &eacute;s <em>hamissal (0)</em>, ha nem az. Induljunk el a "k&eacute;t sz&eacute;l&eacute;t&#337;l", &eacute;s vizsg&aacute;ljuk meg, hogy a k&eacute;t legt&aacute;volabbi karakter megegyezik-e. Vagyis ha a 0. karakter az N-1. karakterrel megegyezik, <span style="text-decoration: underline;">vizsg&aacute;lhatjuk tov&aacute;bb,</span> az 1. &eacute;s az N-2. karaktert, <span style="text-decoration: underline;">ellenkez&#337; esetben biztosan nem palindrom</span>. <br /> Ha "k&ouml;z&eacute;pen tal&aacute;lkoztak", vagyis eljutottunk N/2-ig an&eacute;lk&uuml;l, hogy tal&aacute;ltunk nem megegyez&#337; karakterp&aacute;rt, akkor a sz&ouml;veg (sz&aacute;m) bizony palindrom! (Vagyis a 2. k&oacute;dr&eacute;szletn&eacute;l a konvert&aacute;l&aacute;sn&aacute;l <em>ebben az esetben</em> nem lett volna l&eacute;tfontoss&aacute;g&uacute; megford&iacute;tani a sz&aacute;mot.)</p>\r\n<p>Viszont C++ seg&iacute;ts&eacute;g&eacute;vel ezt is lehet egyszer&#369;bben! Mi lenne ugyanis, ha nem az egyes karaktereket n&eacute;zn&eacute;nk p&aacute;ronk&eacute;nt, hanem hogy <em>a sz&ouml;veg megegyezik-e a megford&iacute;tottj&aacute;val</em>? A megford&iacute;t&aacute;st m&aacute;r meg&iacute;rtam a 2. k&oacute;dr&eacute;szletben, de van r&aacute; egyszer&#369;bb m&oacute;d is, &uacute;j, az eredeti string ford&iacute;tottj&aacute;nak l&eacute;trehoz&aacute;s&aacute;val:</p>\r\n<pre><code>bool is_palindrome(string text)\r\n{\r\n return text==string(text.rbegin(), text.rend());\r\n}\r\n</code></pre>\r\n<p style="text-align: justify;">Itt nem t&ouml;rt&eacute;nik m&aacute;s, mint a <strong>string()</strong> <a title="Wikip&eacute;dia cikk az OOP alapjair&oacute;l" href="https://hu.wikipedia.org/wiki/Objektumorient%C3%A1lt_programoz%C3%A1s#Az_oszt.C3.A1lyok_fel.C3.A9p.C3.ADt.C3.A9se" target="_blank">konstruktor&aacute;nak</a> seg&iacute;ts&eacute;g&eacute;vel l&eacute;trehozunk egy &uacute;j stringet. Ennek a konstruktornak a k&eacute;t param&eacute;tere a string elej&eacute;re, illetve v&eacute;g&eacute;re mutat&oacute; <a title="C++ iter&aacute;torok (Northwestern jegyzet)" href="http://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-iterators.html" target="_blank">iter&aacute;tor</a>. Az &uacute;j string&uuml;nk eleje pedig az eredeti <strong>text</strong> ford&iacute;tottj&aacute;nak eleje <strong>text.rbegin()</strong>, v&eacute;ge pedig a ford&iacute;tott string v&eacute;ge <strong>text.rend()</strong>. &Iacute;gy nincs m&aacute;s dolgunk, mint visszat&eacute;rni azzal a logikai &eacute;rt&eacute;kkel, hogy egyenl&#337;-e a k&eacute;t string.</p>\r\n<h4 style="text-decoration: underline;">A kapott eredm&eacute;ny b&aacute;rmelyik lehets&eacute;ges f&uuml;ggv&eacute;ny haszn&aacute;lat&aacute;val:</h4>\r\n<pre><code> Max: 906609 </code></pre>', '2015-08-11 03:37:10', '2015-08-14 10:43:30');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(36, 'comsciblog', 'Project Euler 3 - Prímfelbontás, legnagyobb prím osztó', 'hu', '<p><strong>Ebben a bejegyz&eacute;sben pr&iacute;msz&aacute;mokr&oacute;l, pr&iacute;mfaktoriz&aacute;ci&oacute;r&oacute;l lesz sz&oacute;, a Project Euler 3. feladat&aacute;nak kapcs&aacute;n. A feladat egy viszonylag nagy sz&aacute;m (de az&eacute;rt 64 biten &aacute;br&aacute;zolhat&oacute;) sz&aacute;m legnagyobb pr&iacute;mt oszt&oacute;j&aacute;nak a megkeres&eacute;se. Sokf&eacute;le m&oacute;dszert kipr&oacute;b&aacute;ltam, de &aacute;ltal&aacute;ban lass&uacute;nak bizonyultak m&aacute;r ekkora bemenetre is. V&eacute;g&uuml;l azonban siker&uuml;lt megtal&aacute;lnom egy j&oacute; m&oacute;dszert.</strong></p>\r\n<p><span style="text-decoration: underline;">Hogyan lehetne eld&ouml;nteni, hogy melyik egy N sz&aacute;m legnagyobb pr&iacute;m oszt&oacute;ja?</span></p>\r\n<ol start="0">\r\n<li>Haszn&aacute;ljunk olyan matematikai programot (Pl.: Maple, MATLAB, Octave, Mathematica, vagy ak&aacute;r&nbsp;<a href="http://wolframalpha.com" target="_blank">WolframAlpha</a>...) amely k&eacute;pes a pr&iacute;mfaktoriz&aacute;ci&oacute;ra :)</li>\r\n<li>Osszuk el minden n&aacute;la kisebb pr&iacute;mmel, &eacute;s vegy&uuml;k a legnagyobbat, amivel null&aacute;t ad marad&eacute;kul.</li>\r\n<li>Vizsg&aacute;ljuk meg sorban (2-t&#337;l N-ig) minden sz&aacute;mot, hogy osztja-e N-t, &eacute;s ha igen, tesztelj&uuml;k le, hogy pr&iacute;m-e.</li>\r\n<li>&nbsp;Pr&oacute;b&aacute;ljuk meg N-t 2-vel osztani. Ha oszthat&oacute; 2-vel, pr&oacute;b&aacute;ljuk megism&eacute;telni. Ha nem, l&eacute;pj&uuml;nk a k&ouml;vetkez&#337; pr&iacute;mre (3), &eacute;s 2 helyett vele pr&oacute;b&aacute;ljuk ugyanezt. Addig ism&eacute;telj&uuml;k a m&oacute;dszert, am&iacute;g 1 nem marad. Ez hasonl&oacute; lehet az &aacute;ltal&aacute;nos iskolai m&oacute;dszerhez.</li>\r\n</ol>\r\n<p>Az els&#337; m&oacute;dszerrel az a baj, hogy mivel N nagy, ez&eacute;rt sok id&#337;t vesz ig&eacute;nybe az &ouml;sszes N alatti sz&aacute;m kilist&aacute;z&aacute;sa. Erre val&oacute; m&oacute;dszer az <a href="https://hu.wikipedia.org/wiki/Eratoszthen%C3%A9sz_szit%C3%A1ja" target="_blank">Eratoszthen&eacute;sz szit&aacute;ja</a>, amely seg&iacute;ts&eacute;g&eacute;vel kisz&#369;rhetj&uuml;k egy bizonyos term&eacute;szetes sz&aacute;mn&aacute;l kisebb pr&iacute;meket. Viszont az &eacute;n programom a megadott $N=600851475143 $-ra olyan sok&aacute;ig futott, hogy nem tudtam kiv&aacute;rni. R&aacute;ad&aacute;sul viszonylag sok <em>extra mem&oacute;ri&aacute;t</em> is haszn&aacute;l a t&ouml;bbi m&oacute;dszerhez k&eacute;pest. &Iacute;gy ezt a programot most nem ismertetn&eacute;m, tal&aacute;n majd egy m&aacute;sik bejegyz&eacute;sben.</p>\r\n<p>A m&aacute;sodik pr&oacute;b&aacute;lkoz&aacute;som szint&eacute;n lass&uacute;nak bizonyult. A program forr&aacute;sk&oacute;dj&aacute;nak <strong>main</strong> f&uuml;ggv&eacute;nye:</p>\r\n<pre><code>int main(int argc, char ** argv)\r\n{\r\n	 unsigned long long result = 0;\r\n	 bool found = false;\r\n	 const unsigned long long NUM = 600851475143;\r\n	 unsigned long long start = NUM&amp;1? NUM-2: NUM-1;\r\n	 for (unsigned long long i=start; !found &amp;&amp; i&gt;0; i-=2)\r\n	 {\r\n	 	 if (NUM%i==0 &amp;&amp; isPrime(i))\r\n	 	 {\r\n	 	 	result = i;\r\n	 	 	found = true;\r\n	 	 }\r\n	 } \r\n	 cout&lt;&lt;result&lt;&lt;endl;\r\n    return 0;\r\n} \r\n</code></pre>\r\n<p>Az <strong>unsigned long long</strong> t&iacute;pus sima a 6<em>4 bites el&#337;jel n&eacute;lk&uuml;li sz&aacute;mok</em> t&aacute;rol&aacute;s&aacute;ra haszn&aacute;lom, sima <strong>int</strong> t&iacute;pusba nem f&eacute;rne bele a nagy(obbacska) N. A program f&#337; ciklusa nem egyes&eacute;vel l&eacute;pked, hanem kettes&eacute;vel, mivel a <em>kett&#337;n k&iacute;v&uuml;l nincs m&aacute;s p&aacute;ros pr&iacute;m</em> (N pedig hat&aacute;rozottan nem kett&#337;hatv&aacute;ny), &iacute;gy elegend&#337; sz&aacute;mn&aacute;l kisebb p&aacute;ratlanokat v&eacute;gign&eacute;zni. Ez&eacute;rt nem mindegy, hogy a sz&aacute;m p&aacute;ros vagy p&aacute;ratlan. Ha p&aacute;ros, a n&aacute;la 1-gyel kisebb p&aacute;ratlan sz&aacute;mt&oacute;l ind&iacute;tom a ciklust, ha p&aacute;ratlan, akkor pedig a n&aacute;la 2-vel kisebb, szint&eacute;n p&aacute;ratlan sz&aacute;mt&oacute;l.</p>\r\n<p><strong>A pr&iacute;mteszt f&uuml;ggv&eacute;ny:</strong></p>\r\n<pre><code>bool isPrime(unsigned long long num)\r\n{\r\n	if (num==2) \r\n		return true;\r\n	if (num%2==0 || num&lt;2)\r\n		return false;\r\n		\r\n	for (int i=3; i&lt;=sqrt(num); i+=2)\r\n	{\r\n		if (num%i==0)\r\n			return false;\r\n	}\r\n	return true;\r\n}\r\n</code></pre>\r\n<p>A f&uuml;ggv&eacute;ny 2 eset&eacute;n igazzal t&eacute;r vissza, minden egy&eacute;b p&aacute;ros sz&aacute;m eset&eacute;n hamissal, csak&uacute;gy mint 2-n&eacute;l kisebb (nemnegat&iacute;v) sz&aacute;m eset&eacute;n. Most, hogy megszabadultunk a p&aacute;ros sz&aacute;mokt&oacute;l, ind&iacute;thatjuk a tesztel&eacute;st 3-t&oacute;l, $\\sqrt(N)$-ig. <em>Ha tal&aacute;ltunk ak&aacute;r egyetlen oszt&oacute;t az adott sz&aacute;mok k&ouml;z&uuml;l, akkor nem pr&iacute;m. Ha v&eacute;gig&eacute;rt, nem tal&aacute;ltunk oszt&oacute;t, teh&aacute;t pr&iacute;m.<br /></em><br /><span style="text-decoration: underline;"><strong>DE: Mi&eacute;rt el&eacute;g $\\sqrt(N)$-ig tesztelni?<br /></strong></span><br />Ugyanis egy sz&aacute;melm&eacute;leti t&eacute;tel szerint biztosan kell lennie egy N &ouml;sszetett sz&aacute;mnak olyan pr&iacute;moszt&oacute;j&aacute;nak, amely $\\leq \\sqrt(N)$. <br />A bizony&iacute;t&aacute;shoz vegy&uuml;k $N=p \\cdot q$ &ouml;sszetett sz&aacute;mot ($p$ &eacute;s $q$ pr&iacute;m), &eacute;s <em>tegy&uuml;k fel, hogy nem igaz a t&eacute;tel</em>, vagyis $p &gt; \\sqrt(N)$ &eacute;s $q &gt; \\sqrt(N)$. Ekkor &ouml;sszeszorozva &#337;ket $p \\cdot q &gt; \\sqrt(N) \\cdot \\sqrt(N) $ vagyis $p \\cdot q &gt; N$, ami ellenmond azzal, hogy egyenl&#337;ek. Vagyis ilyen nem t&ouml;rt&eacute;nhet meg, teh&aacute;t musz&aacute;j, hogy $p \\leq \\sqrt(N)$ vagy $q \\leq \\sqrt(N) $. <br />N&eacute;gyzetsz&aacute;m eset&eacute;n, vagyis ha $p=q$, akkor egyenl&#337;s&eacute;g &aacute;ll fenn. <br />Vagyis el&eacute;g egy sz&aacute;mot<em> n&eacute;gyzetgy&ouml;k&eacute;n&eacute;l nem nagyobb sz&aacute;mokkal elosztani</em>, hogy kider&uuml;lj&ouml;n, hogy nem pr&iacute;m. Ez nagy sz&aacute;mokn&aacute;l jelent&#337;s gyorsul&aacute;st okozhat.</p>\r\n<p>M&eacute;gsem futott le el&eacute;g gyorsan a 2. program, mivel a f&#337; f&uuml;ggv&eacute;ny m&eacute;g mindig t&uacute;l sok l&eacute;p&eacute;st v&eacute;gez. Ez&eacute;rt volt sz&uuml;ks&eacute;g a 3. fajta megk&ouml;zel&iacute;t&eacute;sre:</p>\r\n<p>A <strong>sz&aacute;melm&eacute;let alapt&eacute;tele</strong> szerint minden sz&aacute;m egy&eacute;retlm&#369;en fel&iacute;rhat&oacute; pr&iacute;msz&aacute;mok szorzatak&eacute;nt: Vagyis megpr&oacute;b&aacute;ljuk leosztani 2-vel, &eacute;s ha oszthat&oacute; 2-vel, megpr&oacute;b&aacute;ljuk megism&eacute;telni. Ha nem, l&eacute;p&uuml;nk a k&ouml;vetkez&#337; pr&iacute;mre (3), &eacute;s 2 helyett vele pr&oacute;b&aacute;ljuk ugyanezt. Addig ism&eacute;telj&uuml;k a m&oacute;dszert, am&iacute;g 1 nem marad. El&#337;bb ut&oacute;bb 1 lesz az eredm&eacute;ny, legrosszabb esetben akkor, ha mag&aacute;val osztjuk le, ami azt jelenten&eacute;, hogy a N pr&iacute;m.<br />A program:</p>\r\n<pre><code>int main(int argc, char ** argv)\r\n{\r\n	unsigned long long divider = 2, biggestFactor = 2;\r\n	unsigned long long number = 600851475143;\r\n	while (number &gt; 1)\r\n	{\r\n		if (number%divider == 0)\r\n		{\r\n			number/=divider;\r\n			biggestFactor = divider;\r\n		}\r\n		else \r\n		{\r\n			divider = nextPrime(divider);\r\n		}\r\n	}\r\n	cout&lt;&lt;"A legnagyobb primfaktor: "&lt;&lt;biggestFactor&lt;&lt;endl;\r\n	return 0;\r\n}\r\n</code> </code></pre>\r\n<p>A <strong>nextPrime</strong> f&uuml;ggv&eacute;ny pedig az <strong>isPrime</strong> ismeret&eacute;ben szinte trivi&aacute;lis: addig l&eacute;ptet egy sz&aacute;mot, am&iacute;g nem pr&iacute;m.</p>\r\n<pre><code> \r\nunsigned long long nextPrime(unsigned long long num)\r\n{\r\n	unsigned long long i;\r\n	for (i=num+1; !isPrime(i); ++i);\r\n	return i;\r\n}\r\n</code></pre>\r\n<p>Az eredm&eacute;ny pillanatok alatt megsz&uuml;letik:</p>\r\n<pre><code> A legnagyobb primfaktor: 6857 </code></pre>\r\n<p>Viszont, ami sz&aacute;momra els&#337;re meglep&#337;nek t&#369;nt, hogy ez a m&oacute;dszer <span style="text-decoration: underline;">a <strong>nextPrime</strong> &eacute;s <strong>isPrime</strong> f&uuml;ggv&eacute;nyek n&eacute;lk&uuml;l is m&#369;k&ouml;dik!</span> Vagyis ha a 14. sorban <strong> <strong>divider = nextPrime(divider); </strong>sort egyszer&#369;en &nbsp;<strong>++divider;</strong>&nbsp;sorra cser&eacute;ln&eacute;m, ugyan&uacute;gy m&#369;k&ouml;dne.</strong></p>\r\n<p><strong>Mi&eacute;rt?</strong>&nbsp;Mivel ha a sz&aacute;mot m&aacute;r leosztottuk el&#337;z&#337;leg n&eacute;h&aacute;ny pr&iacute;mmel, &eacute;s mivel minden &ouml;sszetett sz&aacute;m n&aacute;la kisebb pr&iacute;msz&aacute;mokb&oacute;l &aacute;ll (<a href="https://hu.wikipedia.org/wiki/A_sz%C3%A1melm%C3%A9let_alapt%C3%A9tele" target="_blank">sz&aacute;melm&eacute;let alapt&eacute;tele</a>), ez&eacute;rt semmik&eacute;ppen sem t&ouml;rt&eacute;nhet meg az, hogy &ouml;sszetett sz&aacute;mmal pr&oacute;b&aacute;ln&aacute; elosztani N-t, hanem <em>egyszer&#369;en &aacute;tugorn&aacute;</em>. <strong>P&eacute;ld&aacute;ul</strong> $N=700$ eset&eacute;n el&#337;sz&ouml;r osztom 2-vel, $N=350$ marad, majd ism&eacute;t 2-vel, &iacute;gy m&aacute;r csak $N=175$. $N$ nem oszthat&oacute; tov&aacute;bb 2-vel, &eacute;s 3-mal sem. Viszont m&aacute;r a 4 &ouml;sszetett sz&aacute;mmal sincs gond, hiszen $2 \\times 2$-k&eacute;nt m&aacute;r osztottunk vele, &iacute;gy a m&oacute;dos&iacute;tott algoritmus is meg tov&aacute;bb az 5-re! <span style="text-decoration: underline;">A k&ouml;vetkez&#337; pr&iacute;mre, an&eacute;lk&uuml;l hogy a program ismern&eacute; a pr&iacute;meket!</span></p>', '2015-08-12 04:27:32', '2015-08-13 11:34:55'),
(37, 'comsciblog', 'Project Euler 6 - Véges sorok összege', 'hu', '<p><strong>A k&ouml;vetkez&#337; bejegyz&eacute;sben ism&eacute;t egy Project Euler felad&aacute;nyb&oacute;l indulok ki, nevezetesen a 6.-b&oacute;l. A feladat konkr&eacute;tan a 100 alatti term&eacute;szetes sz&aacute;mok &ouml;sszeg&eacute;nek n&eacute;gyzet&eacute;nek, &eacute;s n&eacute;gyzeteik &ouml;sszeg&eacute;nek k&uuml;l&ouml;nbs&eacute;ge. K&eacute;t m&oacute;dszert mutatok be a megold&aacute;s&aacute;ra, egy mechanikus sz&aacute;m&iacute;t&oacute;g&eacute;pes m&oacute;dszert, illetve egy ak&aacute;r pap&iacute;ron is elv&eacute;gezhet&#337; m&oacute;dszert. Bemutatok k&eacute;t kapcsol&oacute;d&oacute; matematikai &ouml;sszef&uuml;gg&eacute;st, teljes indukci&oacute;s bizony&iacute;t&aacute;ssal.</strong></p>\n<p>A feladat: adott egy &ouml;sszeg: $1^2 + 2^2 + ... + 100^2 = \\sum_{i=1}^{100} i $ illetve egy &ouml;sszeg n&eacute;gyzete: $(1+2+...+100)^2 = (\\sum_{i=1}^{100} i^2 )^2$. A feladat: sz&aacute;moljuk ki a m&aacute;sodik &eacute;s az els&#337; k&uuml;l&ouml;nbs&eacute;g&eacute;t! Sz&aacute;m&iacute;t&oacute;g&eacute;ppel ez igen egyszer&#369; feladat: &ouml;sszegezz&uuml;k a sz&aacute;mokat, majd a sz&aacute;mok n&eacute;gyzeteit. A sz&aacute;mok &ouml;sszeg&eacute;t emelj&uuml;k n&eacute;gyzetre, &eacute;s vonjuk ki bel&#337;le a n&eacute;gyzet&ouml;sszeget. A C program k&oacute;dja:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#define N 100\n\nint main()\n{\n	long long unsigned sum, sum_of_squares;\n	int i=1;\n	for (i=1; i&lt;N; ++i)\n	{\n		sum+=i;\n		sum_of_squares+=(i*i);\n	}\n	 long long int diff = sum*sum - sum_of_squares;\n    printf("\\nAz elso %d szam osszegenek negyzete - Az elso %d negyzetszam osszege = %lld\\n",N,N,diff);\n}\n</code></pre>\n<p><br />Tekints&uuml;nk kicsit a program hat&eacute;konys&aacute;g&aacute;ra: az 1-N k&ouml;z&ouml;tti sz&aacute;mok &ouml;sszead&aacute;s&aacute;hoz N-1 &ouml;sszead&aacute;s sz&uuml;ks&eacute;ges mindk&eacute;t esetben, a n&eacute;gyzetre emel&eacute;sekhez pedig N darab szorz&aacute;s. Vagyis $2(N-1)+N $, azaz $\\mathcal{O}(N)$, vagyis a bemen&#337; adatokkal egyenesen ar&aacute;nyos a m&#369;veletig&eacute;nye, <strong>line&aacute;ris fut&aacute;sidej&#369;</strong>. (100 adatra 298 m&#369;velet, 1000 adatra 2998, &eacute;s &iacute;gy tov&aacute;bb...)<br /><br />Ismert azonban k&eacute;t matematikai &ouml;sszef&uuml;gg&eacute;s, amellyel seg&iacute;ts&eacute;g&eacute;vel ugyanannyi m&#369;velettel <span style="text-decoration: underline;">b&aacute;rmekkora sz&aacute;mra</span> kisz&aacute;m&iacute;thatjuk a fenti &ouml;sszegeket, <span style="text-decoration: underline;">ugyanannyi m&#369;velettel</span>, ak&aacute;r g&eacute;p n&eacute;lk&uuml;l, pap&iacute;ron is. Az &ouml;sszef&uuml;gg&eacute;sek:&nbsp;<br />\\[<br />1+2+..+n = \\sum_{i=1}^n i = \\frac{n(n-1)}{2}&nbsp; \\\\<br />valamint \\\\<br />1^2+2^2+...+n^2 = \\sum_{i=1}^n i^2 = \\frac{n(n+1)(2n+1)}{6}$ <br />\\]<br />Vagyis a jobb oldalba $n$ hely&eacute;re 100-at &iacute;rva 3 szorz&aacute;ssal &eacute;s 2 oszt&aacute;ssal <em>tetsz&#337;legesen nagy sz&aacute;mra kisz&aacute;m&iacute;thatjuk</em> a keresett &ouml;sszegeket, ak&aacute;r sz&aacute;m&iacute;t&oacute;g&eacute;p n&eacute;lk&uuml;l is! Ha azonban lust&aacute;k vagyunk sz&aacute;molni, &iacute;rhatunk hozz&aacute; valami ehhez hasonl&oacute; programot:</p>\n<pre><code>int main()\n{\n    long long unsigned sum, sum_of_squares;\n    sum_of_squares = (N*(N+1)*(2*N+1))/6;\n    sum = (N*(N+1))/2;\n    printf("Elso %d szam osszege: %lld\\n",N,sum);\n    printf("Elso %d negyzetszam osszege: %lld\\n",N,sum_of_squares);\n    long long int diff = sum*sum - sum_of_squares;\n\n    printf("\\nAz elso %d szam osszegenek negyzete - Az elso %d negyzetszam osszege = %lld\\n",N,N,diff);\n    return 0;\n}\n</code></pre>\n<p>Az eredm&eacute;ny mindk&eacute;t esetben ugyanaz:</p>\n<pre><code> <br />Az elso 100 szam osszegenek negyzete - Az elso 100 negyzetszam osszege = 25164150 </code> </code></pre>\n<p>Viszont <em>honnan tudjuk</em>, hogy a k&eacute;t felhaszn&aacute;lt formula <em>minden term&eacute;szetes sz&aacute;mra m&#369;k&ouml;dik</em>? A bizony&iacute;t&aacute;s&aacute;hoz felhaszn&aacute;lhand&oacute; a <a href="https://hu.wikipedia.org/wiki/Teljes_indukci%C3%B3" target="_blank">teljes indukci&oacute; elve</a>, amely szerint ha egy &aacute;ll&iacute;t&aacute;s igaz $n=1$-re, &eacute;s valamely $n$ eg&eacute;sz sz&aacute;mra, akkor minden $n \\in \\mathbb{N}$ term&eacute;szetes sz&aacute;mra teljes&uuml;l az &aacute;ll&iacute;t&aacute;s!</p>\n<p>Az $\\sum_{i=1}^n i^2 = \\frac{n(n+1)(2n+1)}{6}$ &ouml;sszef&uuml;gg&eacute;s $n=1$ sz&aacute;mra teljes&uuml;l, ugyanis $\\frac{1 \\cdot 2 \\cdot 3}{6} = 1 = 1^2 $. <em>Tegy&uuml;k fel h&aacute;t, hogy valamelyik tetsz&#337;leges $n$ eset&eacute;n igaz</em>, &eacute;s igazoljuk $n+1$-re. Vagyis helyettes&iacute;ts&uuml;nk az &ouml;sszef&uuml;gg&eacute;sben $n$ hely&eacute;re $n-1$-et, &eacute;s a k&ouml;vetkez&#337;t kapjuk:<br />\\[<br />1^2 + 2^2 + ...+n^2 + (n+1)^2 = \\frac{(n+1)(n+2)(2n+3)}{6}<br />\\]<br />A jobb oldalt kifejtve:<br />\\[<br />\\frac{(n+1)(n+2)(2n+3)}{6} = \\frac{ (n^2+3n+2)(2n+3) }{6} = \\\\<br />=\\frac{2n^3+3n^2+6n^2+9n+4n+6}{6} = \\frac{2n^3 + 9n^2 + 13n +6}{6}<br />\\]<br />A bal oldalon az els&#337; $n$ sz&aacute;m n&eacute;gyzet&ouml;sszege tal&aacute;lhat&oacute; + $(n+1)^2$. Az els&#337; $n$ sz&aacute;m &ouml;sszeg&eacute;r&#337;l feltett&uuml;k, hogy egyenl&#337; $\\frac{n(n+1)(2n+1)}{6}$-tal, helyettes&iacute;ts&uuml;k h&aacute;t be (&eacute;s haszn&aacute;ljunk n&eacute;mi elemi algebr&aacute;t az &ouml;sszead&aacute;shoz):<br />\\[<br />1^2 + 2^2 + ...+n^2 + (n+1)^2 = \\frac{n(n+1)(2n+1)}{6} + (n+1)^2 = \\\\<br />= \\frac{n^2+n)(2n+1)}{6} + (n^2+2n+1) = \\frac{2n^3+3n^2+n}{6} + \\frac{6n^2+12n+6}{6}= \\\\ <br />= \\frac{2n^3 + 9n^2 + 13n +6}{6}<br />\\]<br />A k&eacute;t oldal megegyezik, teh&aacute;t $n+1$-re is teljes&uuml;l, teh&aacute;t az indukci&oacute; elve szerint mindig igaz az &aacute;ll&iacute;t&aacute;s.</p>\n<p>A m&aacute;sik &ouml;sszef&uuml;gg&eacute;s bizony&iacute;t&aacute;sa is hasonl&oacute;: $n=1$-re $\\frac{1(1+1)}{2} = 1$ teljes&uuml;l. <em>Tegy&uuml;k fel, hogy tetsz&#337;leges $n$-re&nbsp;</em> $\\sum_{i=1}^n i = \\frac{n(n-1)}{2} $ <em>igaz</em>, &eacute;s n&eacute;zz&uuml;k meg, hogy $n+1$-et behelyettes&iacute;tve<br />\\[<br />1+2+...+n+(n+1) = \\frac{(n+1)(n+2)}{2}<br />\\]<br />m&eacute;g mindig teljes&uuml;l-e? A bal oldalon az els&#337; $n$ sz&aacute;m &ouml;sszege l&aacute;that&oacute;, $n+1$-gyet hozz&aacute;adva. Az indukci&oacute;s feltev&eacute;s alapj&aacute;n ez<br />\\[<br />&nbsp; 1+2+...+n+(n+1) = \\frac{n(n+1)}{2} + (n+1) = \\\\<br />&nbsp;= \\frac{n^2+n}{2} + \\frac{2n+2}{2} = \\frac{n^2+3n+2}{2}<br />\\]<br />ami megegyezik a jobb oldallal, ugyanis $ \\frac{(n+1)(n+2)}{2} = \\frac{n^2+3n+2}{2} $. Teh&aacute;t ez az &ouml;sszef&uuml;gg&eacute;s is igaz minden term&eacute;szetes sz&aacute;mra.</p>', '2015-08-13 05:22:23', '2015-08-13 10:56:49'),
(38, 'comsciblog', 'Melyik programozási nyelvvel kezdjem? - infógrafika', 'hu', '<p><strong>A k&ouml;vetkez&#337; bejegyz&eacute;sben nem fogok semmilyen feladatot megcsin&aacute;lni, nem lesz forr&aacute;sk&oacute;d &eacute;rtelmez&eacute;s, sem matematikai bizony&iacute;t&aacute;s. Ehelyett egy (sz&aacute;momra) &eacute;rdekes inf&oacute;grafik&aacute;t szeretn&eacute;k k&ouml;zkinccs&eacute; tenni, amit most leford&iacute;tottam magyar nyelv&#369;re. Az eredetit nagyon tal&aacute;l&oacute;nak &eacute;s viccesnek tal&aacute;ltam, &eacute;s egyben informat&iacute;vnak &eacute;s "igaznak" is. Helyenk&eacute;nt nem &eacute;rtek vele egyet (p&eacute;ld&aacute;ul a PHP-t szerintem ok n&eacute;lk&uuml;l h&uacute;zta ennyire le), de igyekeztem h&#369; maradni az eredetihez, &eacute;s a lehet&#337; legjobban visszaadni a mondand&oacute;j&aacute;t magyarul. &Iacute;gy siker&uuml;lt:</strong><br /><br /><img class="img-responsive" src="http://comsciblog.esy.es/img/which-programming-language-infographic-hun.png" alt="Melyik programoz&aacute;si nyelvvel kezdjem? - inf&oacute;grafika" width="800" height="884" /></p>\n<p>&nbsp;</p>\n<p> &nbsp;A k&eacute;pen szerepl&#337; &aacute;tlagos fizet&eacute;sek term&eacute;szetesen <em>nem a magyarorsz&aacute;gi &aacute;tlagb&eacute;rt</em> t&uuml;kr&ouml;zik.&nbsp;<br />A k&eacute;pet <strong>nem &eacute;n k&eacute;sz&iacute;tettem, nem az &eacute;n szellemi tulajdonom</strong>, &eacute;n mind&ouml;ssze <span style="text-decoration: underline;">csak leford&iacute;tottam</span> magyar nyelvre. Az eredeti k&eacute;p a <a title="Eredeti k&eacute;p" href="http://carlcheo.com/startcoding" target="_blank">k&eacute;sz&iacute;t&#337;je honlapj&aacute;n</a> megtekinthet&#337;, illetve <a title="Google-keres&eacute;si eredm&eacute;ny" href="https://www.google.hu/search?tbs=sbi:AMhZZissSqkvWgjl_1Af9T8b8JSLYbaWdrKpTYgu47_1tB7Clpcsk37JZ0bd9JKH26IWXC-2svbqpRE90Hgcw4zN5kRph3SgHIXX8iDcU_1cAdFa0XEIyornr_1pEm7oUZv8jNHUqYPRwJL122miI_1FAsO9k5Ffe8EikaDvVunzUb1SmPOAVkZp58s2ZGzx7qVBCs5ZD9f3trVl_1SmYUruUrh_1YkwWcXDvZ--J_11Zln0r9J2cnQtea8JJF-SDzksFxq7fh-aiD4qYBoXjZPNMgZ74Rt3TpSaeT4YX9qFe1Dnl9IP-O19rIl4mmBii0RqqV2Z-LSatCdSJIabvjUYrIAdUNCjFlSrU4jMviuueZdg6GtiH5HXtJZaA55V7O3b3aV7dwovZkD-xvyd9XM_1U6p3u9nqQNzGzqphI7b9RawMWAVGj-Ko6kH9EVDU4FMVC-sNT4grwGrbo8FBMoURioVVLTjA589r7qmNUi_1dnv_1y2x-Cy3Ghqd3vrXbLSytxOtJBSu_1Z025g7r00VPVtQ6K5NGmXYJNaHIZPMFPRG9xF9j9YZRysryX39ZY4-lwJL2JDWkEvjlsa2fVZRIZun-PuEd7bGu1Zr8RUjIcPwmAf2XQvuau65y8pW24Ka3hCj_1kWVKTD7Fc1jIlro4bMl6zImNHTBMfQBA_14_1eUzasUQyhsafZ-oAhdWAhjSJiq8Uwl6hl2CPlXkUvjDd1vcoYwmKghyiqx-QRIczWMcWjgctJtaouRHMFN_1l5etpWXbxyDxLDvEuRG9hD-Ufeq6JjIg86FN-shDVBoxL4GUA5k1xJHKhS2Eus75WSHyAqYtRK8YrvNYBL0oKJd_1Oh2VV1Lai_1Y0y2Csk4GviNemEMMH9aV0ijvhYIdU1vMAJPAUF2fnCIqO9Ty1J9bPorZ7RN_1MSj-x6pv0i0eli_1hWcA_1J7B4WmdzzEttR84yj5F_135lQJ6adRQEMqnfve7qHZc0XDo6C_1ksPnpzfCeUv8uWQ3w6f70ITRY4PG4rzmfYv-DUzNosS1BTOEQosPilJkpT2RZ14nkNi-sABRm4J6wceqSi5vkaj2j0FzrGqQpSRKYANFh1FMYAZ2zF9chuwtQGgXUcHvVfQg1ok2tnVsZRhLd7UBL5KQ5qc6cpc0gdKY3co8dM5N6xJIfmpdyXe9v2ROIUiM4RhiFY3rN0XaAkBoeANME82om0g1YlR3Uy6zkkSAdWT3WWjX8kCqMLQMvfSc40Qlu0FjJzPsBeB3KrgmaW8QvplRRRSQ2DMYEGISPS5Y-DfH_1uBaSa-DTk11wWpk005_17gskOYcOujicRclUy2ynMhlm1Q6oRx80rsEI1G8rYd6bZIWscWI_12PJaqr15SLJfp9WEecFmCwcwENWWjSgmq8JjasUR9OnKFv4LrRpA8NNtK_14QWELXc-6IIA2sbOLfFvZ_1YKUZQ8IqCtwJq-mGe5D-xOU5B41ar5oI4S_1SvG_1Xm0yBE_1MXO-7YIfk0ovKQv6WpFpfM6QUd4DPU_1ofeRsENX9Dby4LYmXzdqSoD8XbX4-LfqZ-U" target="_blank">sok egy&eacute;b helyen is</a> vil&aacute;gh&aacute;l&oacute;-szerte.<br />Szerintem igaz&aacute;n tal&aacute;l&oacute; inf&oacute;grafika, k&uuml;l&ouml;n&ouml;sen A Gy&#369;r&#369;k ura-hasonlat fogott meg. B&aacute;r kiss&eacute; sajn&aacute;lom szeg&eacute;ny PHP-t, hogy egy ronda mezei orkhoz hasonl&iacute;tja (b&aacute;r jobban meggondolva lehet benne igazs&aacute;g, t&eacute;nyleg lehet vele nagyon cs&uacute;nya k&oacute;dokat &iacute;rni, ha nem figyel&uuml;nk oda. )<br />A C#-hoz pedig annyit hozz&aacute;tenn&eacute;k, hogy t&uuml;nd&eacute;k nem csak V&ouml;lgyzugolyban &eacute;lnek, a k&eacute;pen l&aacute;that&oacute; Legolas pont a Bakacsinerd&#337; lak&oacute;ja (b&aacute;r val&oacute; igaz, hogy a saj&aacute;t erdeikben &eacute;rzik j&oacute;l magukat, azaz a .NET keretrendszerben)<br /><br />Kinek mi a v&eacute;lem&eacute;nye a k&eacute;pr&#337;l?</p>', '2015-08-18 11:27:34', '2015-08-18 11:52:24'),
(39, 'comsciblog', 'Project Euler 9 - Pitagoraszi számhármasok', 'hu', '<p style="text-align: left;"><strong>A k&ouml;vetkez&#337;kben a Project Euler 9. feladat&aacute;nak egy lehets&eacute;ges megold&aacute;si m&oacute;dj&aacute;t &iacute;rom le. A feladat az egyetlen olyan Pitagoraszi sz&aacute;mh&aacute;rmas megtal&aacute;l&aacute;sa, amely sz&aacute;mok &ouml;sszege 1000. N&eacute;mi elemi algebra felhaszn&aacute;l&aacute;sval egy mindent kimer&iacute;t&#337; "brute-force" megold&aacute;sb&oacute;l eljutok egy gyorsabb, hat&eacute;konyabb programig. A haszn&aacute;lt programoz&aacute;si nyelv ez&uacute;ttal is C lesz.</strong> <img style="margin-right: auto; margin-left: auto; display: block;" src="http://cms.sulinet.hu/get/d/13d4a4b4-dc44-49ac-a961-cb7ddc11a794/1/10/b/Normal/917ca003.jpg" alt="Der&eacute;ksz&ouml;g&#369; h&aacute;romsz&ouml;g, Pitagorasz-t&eacute;tel" width="365" height="300" />&nbsp;A k&eacute;p a Pitagorasz-t&eacute;telt illuszt&aacute;lja. Forr&aacute;s<span style="text-align: center;">: <a title="Sulinet oldala" href="http://tudasbazis.sulinet.hu/hu/matematika/matematika/matematika-9-osztaly/bevezetes-a-geometriaba/pitagorasz-tetel" target="_blank">tudasbazis.sulinet.hu</a> </span></p>\n<p>&nbsp;</p>\n<p><span style="text-decoration: underline;"><strong>Mi is az a Pitagoraszi sz&aacute;mh&aacute;rmas?</strong></span></p>\n<p>Olyan $a&lt;b&lt;c$ term&eacute;szetes sz&aacute;mok, amelyekre $a^2+b^2 = c^2$, vagyis amelyek megfeleltethet&#337;k egy der&eacute;ksz&ouml;g&#369; h&aacute;romsz&ouml;g oldalainak. A feladat szerint csup&aacute;n egyetlen olyan Pitagoraszi sz&aacute;mh&aacute;rmas l&eacute;tezik, amelynek &ouml;sszege 1000. M&aacute;sk&eacute;ppen sz&oacute;lva: pontosan egy der&eacute;ksz&ouml;g&#369; h&aacute;romsz&ouml;g l&eacute;tezik, amelynek ker&uuml;lete (perimeter = $p$) 1000 egys&eacute;g. A feladat az oldalak (a,b,c sz&aacute;mok) meghat&aacute;roz&aacute;sa.</p>\n<p><strong><span style="text-decoration: underline;">Megold&aacute;s:</span></strong><br /><br />A feladat megold&aacute;s&aacute;ra az egyik lehets&eacute;ges &uacute;t, ha <em>minden lehets&eacute;ges $a&lt;b&lt;c$ sz&aacute;mh&aacute;rmast v&eacute;gigpr&oacute;b&aacute;lunk</em>, hogy kiel&eacute;g&iacute;tik-e a 2 felt&eacute;tel&uuml;nket: vagyis hogy $a^2+b^2 = c^2$ &eacute;s $a+b+c=1000$. Ez azonban nagys&aacute;grendileg $10^9$ iter&aacute;ci&oacute;t ig&eacute;nyelne, vagyis $ \\mathcal{O}(n^3)$ m&#369;veletig&eacute;ny&#369; algoritmus. A minden lehet&#337;s&eacute;get kipr&oacute;b&aacute;l&oacute;, &uacute;gynevezett "brute-force" algoritmus C forr&aacute;sk&oacute;dja:</p>\n<pre><code>#include &lt;stdio.h&gt;<br />#define PERIM 1000\nint main()<br />{<br />&nbsp;&nbsp;&nbsp; int a, b, c;<br />&nbsp;&nbsp;&nbsp; for (a=1; a&lt;PERIM; ++a)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (b=a; b&lt;PERIM; ++b)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (c=b; c&lt;PERIM; ++c)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a*a+b*b==c*c &amp;&amp; a+b+c==PERIM)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("a=%d, b=%d, c=%d\\n", a, b, c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("A szorzatuk: %d\\n", a*b*c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return 0;<br />} \n</code> </code></pre>\n<p><br />B&aacute;r ugyan ez a program is el&eacute;g gyorsan v&eacute;gez, mivel viszonylag kis sz&aacute;mokr&oacute;l van sz&oacute;, az elj&aacute;r&aacute;s <strong>gyors&iacute;that&oacute;</strong>. &Eacute;szrevehetj&uuml;k, hogy $c$ kifejezhet&#337; $a$, $b$ &eacute;s a ker&uuml;let $p$ ismeret&eacute;ben: mivel&nbsp; $a+b+c=p$, ez&eacute;rt $c=p-a-b$, ahol $p$ h&aacute;romsz&ouml;g ker&uuml;lete. (Ez pillanatnyilag $p=1000$, de m&#369;k&ouml;dik &aacute;ltal&aacute;noss&aacute;gban is.) Teh&aacute;t a k&ouml;b&ouml;s algoritmus helyett n&eacute;gyzetes ($\\mathcal{O}(n^2) $ )&nbsp;is elegend&#337;, vagyis a jelenlegi programot nagyj&aacute;b&oacute;l ezerszeres&eacute;re gyors&iacute;tottuk!</p>\n<p>De van m&eacute;g egy &ouml;sszef&uuml;gg&eacute;s&uuml;nk, amelyet figyelembe vehet&uuml;nk. Ez a Pitagorasz-t&eacute;tel, vagyis $a^2+b^2 = c^2$, ahol $c=p-a-b$ &ouml;sszef&uuml;gg&eacute;st behelyettes&iacute;tve azt kapjuk, hogy : $a^2 + b^2 = (p-a-b)^2$. N&eacute;mi elemi algebrai &aacute;talak&iacute;tgat&aacute;s ut&aacute;n, $b$-re rendezve:<br />\\[<br />&nbsp;a^2 + b^2 = (p-a-b)^2 \\\\<br />&nbsp;a^2 + b^2 = p^2 + a^2 + b^2 - 2pa - 2pb + 2ab&nbsp; \\\\<br />&nbsp;0 = p^2 - 2pa - 2pb + 2ab \\\\<br />&nbsp;2pb-2ab = p^2 - 2pa&nbsp; \\\\<br />&nbsp;b(2p-2a) = p(p-2a) \\\\<br />&nbsp;b = \\frac{ p(p-2a) }{(2p-2a)} \\\\<br />\\]</p>\n<p>Vagyis <em>ism&eacute;t kifejezt&uuml;nk egy v&aacute;ltoz&oacute;t</em>, vagyis $a$ seg&iacute;ts&eacute;g&eacute;vel kifejezt&uuml;k $b$-t &eacute;s $c$-t is!&nbsp; Vagyis <span style="text-decoration: underline;">egyetlen v&aacute;ltoz&oacute; &eacute;rt&eacute;keinek v&eacute;gigpr&oacute;b&aacute;lgat&aacute;s&aacute;val</span> (mivel a ker&uuml;let &aacute;lland&oacute;, 1000) megkapjuk a v&aacute;laszt a k&eacute;rd&eacute;s&uuml;nkre! Teh&aacute;t <strong>line&aacute;ris fut&aacute;sid&#337;ben</strong> ($\\mathcal{O}(n)$), legfeljebb 1000 iter&aacute;ci&oacute; alatt lefut a programunk. A program teh&aacute;t a k&ouml;vetkez&#337;k&eacute;ppen n&eacute;z ki:</p>\n<pre><code>#include &lt;stdio.h&gt;<br />#define PERIM 1000\nint main()<br />{<br />&nbsp;&nbsp;&nbsp; int a, b, c;<br />&nbsp;&nbsp;&nbsp; char found = 0;<br />&nbsp;&nbsp;&nbsp; for (a=3; !found &amp;&amp; a&lt;PERIM; ++a)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = (PERIM*(PERIM-2*a)) / (2*(PERIM-a));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = PERIM - a - b;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a*a+b*b==c*c)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("a=%d, b=%d, c=%d\\n", a, b, c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("A szorzatuk: %d\\n", a*b*c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found = 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return 0;<br />}</code></pre>\n<p>L&aacute;that&oacute;, hogy mind&ouml;ssze 1 ciklusunk van, $a$ oldalra. Ezt elegend&#337; 3-t&oacute;l ind&iacute;tani, mivel a <em>legkisebb Pitagoraszi sz&aacute;mh&aacute;rmas</em> az $a=3, b=4, c=5$. A ciklus addig megy, am&iacute;g meg nem tal&aacute;lja a keresett &eacute;rt&eacute;ket, vagyis am&iacute;g <strong>found</strong> v&aacute;ltoz&oacute; &eacute;rt&eacute;ke nem lesz<strong> IGAZ(1)</strong>. A biztons&aacute;g kedv&eacute;&eacute;rt akkor is le&aacute;ll, ha $a$ &eacute;rt&eacute;ke t&uacute;lment a ker&uuml;leten, vagyis ha nem tal&aacute;lt ilyen sz&aacute;mh&aacute;rmast. Viszont tal&aacute;lt, a kimenet pedig:</p>\n<pre><code> a=200, b=375, c=425<br />A szorzatuk: 31875000 </code></pre>\n<p><strong><span style="text-decoration: underline;">Megjegyz&eacute;s:</span><br /></strong><br />A Pitagoraszi sz&aacute;mh&aacute;rmas vizsg&aacute;lata &uacute;gy is megt&ouml;rt&eacute;nhet, <span style="text-decoration: underline;">hogy azt ellen&#337;rizz&uuml;k, hogy $b$ eg&eacute;sz sz&aacute;m-e</span>, ugyanis a Pitagoraszi sz&aacute;mok csak <em>a term&eacute;szetes sz&aacute;mok halmaz&aacute;n</em> vannak &eacute;rtelmezve. Vagyis az <strong>if</strong> felt&eacute;telbe ha <strong>a*a+b*b==c*c</strong> helyett <strong>(PERIM*(PERIM-2*a)) % (2*(PERIM-a)) == 0</strong> ker&uuml;lne, ugyanolyan j&oacute; megold&aacute;s lenne az is.</p>', '2015-08-21 03:28:52', '2015-08-21 04:03:13'),
(47, 'comsciblog', 'Leghosszabb leírható szó, elromlott billenty&#369;zettel - dailyprogrammer', 'hu', '<p><strong>K&eacute;pzeld el, hogy egyszer csak a szomsz&eacute;d Pistike be&aacute;ll&iacute;t hozz&aacute;d azzal az &uuml;r&uuml;ggyel,&nbsp;hogy: "Seg&iacute;ts rajtam, elromlott a billenty&#369;zetem!". A kezdeti sokk ut&aacute;n &eacute;rtelmes k&eacute;rd&eacute;s lehet, hogy: "M&eacute;gis mi a baja?" Pistike v&aacute;lasza: "Elromlott. Nem minden billenty&#369;&nbsp; m&#369;k&ouml;dik, csak n&eacute;h&aacute;ny." Hardveres tud&aacute;s hi&aacute;ny&aacute;ban azonban hazak&uuml;ldheted Pistik&eacute;t, hogy vegyen egy &uacute;j billenty&#369;zetet. Viszont felaj&aacute;nlod, hogy ha megadja a m&#369;k&ouml;d&#337; billenty&#369;k list&aacute;j&aacute;t,&nbsp; te megmondod a leghosszabb &eacute;rtelmes (angol) sz&oacute;t, amit le tud g&eacute;pelni a rossz billenty&#369;zet&eacute;vel.&nbsp;A most bemutat&aacute;sra ker&uuml;l&#337; programoz&aacute;si feladat ezt a k&eacute;rd&eacute;s v&aacute;laszolja meg. A feladat a Reddit.com&nbsp;dailyprogrammer oldal&aacute;r&oacute;l sz&aacute;rmazik. A megval&oacute;s&iacute;t&aacute;s nyelve ez&uacute;ttal is C++ lesz.<br /><br /></strong> <img style="margin: 0 auto 0;" class="img-responsive" src="http://comsciblog.esy.es/img/Broken_keyboard2.jpg" />  <br />A k&eacute;p mind&ouml;ssze&nbsp;illusztr&aacute;ci&oacute;. Forr&aacute;sa: <a title="Wikimedia - Broken keyword" href="https://upload.wikimedia.org/wikipedia/commons/0/02/Broken_keyboard.jpg" target="_blank">wikimedia.org</a> </p>\n<p style="text-align: justify;"><span style="text-decoration: underline;">A program bemenete:</span> a billenty&#369; m&#369;k&ouml;d&#337; karaktereib&#337;l &aacute;ll&oacute; sz&ouml;vegkonstans (string). Mivel azonban Pistik&eacute;nek vannak bar&aacute;tai, csal&aacute;dtagjai, akik szint&eacute;n hasonl&oacute; probl&eacute;m&aacute;val k&uuml;zdenek,&nbsp;ez&eacute;rt a program tetsz&#337;leges bemenetre (vagyis "rossz billenty&#369;zet" karakterl&aacute;ncra) m&#369;k&ouml;d&#337;k&eacute;pesnek kell lennie. <br /><span style="text-decoration: underline;">A kimenet</span> pedig a billenty&#369;zettel le&iacute;rhat&oacute; leghosszabb szavak list&aacute;ja.&nbsp;Ahhoz, hogy eld&ouml;nts&uuml;k, melyek az &eacute;rtelmes szavak, a feladat az <a title="Enabled English words" href="http://norvig.com/ngrams/enable1.txt" target="_blank">enable1.txt</a> sz&ouml;vegf&aacute;jlt aj&aacute;nlja.</p>\n<h3>Hogyan is kezdhetn&eacute;nk neki?</h3>\n<p>Els&#337; k&ouml;rben &eacute;rdemes lehet <em>egyszer&#369;s&iacute;teni</em> a feladatot: tetsz&#337;leges bemenet helyett csak <em>egy bemenetre</em> (Pistik&eacute;nek seg&iacute;t&uuml;nk, de az ismer&#337;seit "elk&uuml;ldj&uuml;k"), &eacute;s az &ouml;sszes leghosszabb sz&oacute; helyett mind&ouml;ssze <em>egyetlen leghosszabb sz&oacute;</em> megkeres&eacute;s&eacute;re.<img class="img-responsive" style="float: left; margin: 5px;" src="http://treasure.diylol.com/uploads/post/image/453561/resized_my-mother-meme-generator-the-keyboard-isn-t-working-the-internet-is-broken-111-one1-f276e2.jpg" alt="Keyboard Internet broken!" width="200" height="172" /><br /><span style="text-decoration: underline;">Ekkor a feladat:</span> Keress&uuml;nk olyan sort az&nbsp;<a title="Enabled English words" href="http://norvig.com/ngrams/enable1.txt" target="_blank">enable1.txt</a>&nbsp;f&aacute;jlban, amely az <em>input sz&ouml;veg&nbsp;</em><em>karakterein k&iacute;v&uuml;l nem tartalmaz m&aacute;s karaktert</em>, vagyis az input sz&ouml;veg karaktereinek &nbsp;egy vari&aacute;ci&oacute;ja. Ezek k&ouml;z&uuml;l&nbsp;<em>v&aacute;lasszuk ki a leghosszabbat.</em>&nbsp;</p>\n<p><br />Mindenk&eacute;pp sz&uuml;ks&eacute;g lesz teh&aacute;t <em>a f&aacute;jl soronk&eacute;nti beolvas&aacute;s&aacute;ra</em>. Erre haszn&aacute;lhatjuk&nbsp;a <strong>getline</strong> f&uuml;ggv&eacute;nyt, vagy egyszer&#369;en csak bemeneti filestream&uuml;nk <strong>&gt;&gt; oper&aacute;tor&aacute;t</strong>.&nbsp;A beolvasott sz&oacute; (<em>word</em>) karaktereit egyenk&eacute;nt megvizsg&aacute;ljuk, hogy megegyezik-e&nbsp;az input sz&ouml;veg valamely karakter&eacute;vel. Ha egyik karakter&eacute;vel sem egyezik meg,&nbsp;akkor ez egy <em>&eacute;rv&eacute;nytelen</em> sz&oacute;. Ha a sz&oacute; <em>&eacute;rv&eacute;nyes</em> (<strong>valid</strong>), akkor egy megvizsg&aacute;ljuk,&nbsp;hogy hosszabb-e a jelenlegi leghosszabb sz&oacute;n&aacute;l (<a title="Alapvet&#337; programoz&aacute;si t&eacute;telek &ouml;sszefoglalva" href="http://www.zsuuu.hu/alapism/programozas.html" target="_blank">maximum kiv&aacute;laszt&aacute;s</a>).&nbsp;Az eddigi k&oacute;d:</p>\n<pre><code> \nint main(int argc, char ** argv)\n{\n  string input = "abcd";\n\n  ifstream fin("enable1.txt"); //open valid word list\n  if (!fin.is_open())\n     return -1;\n\n   string word = "", longest_word = "";\n   while (!fin.eof())\n   {\n     fin&gt;&gt;word;\n     bool valid = true; /* Assume that the readed string is valid */\n     for (int i=0; i&lt;word.size(); ++i)\n     {\n	/*Find if the ith character matches any of the input string character */\n	bool match = false;\n	for (int j=0; j&lt;input.size() &amp;&amp; !match; ++j)\n	{\n	  if (word[i] == input[j])\n	    match = true;\n	}\n	/* If any character not matched, the string not valid */\n	if (!match)\n	   valid = false;\n    }\n    /* If the current string is valid and longer than the longest */\n    if (valid &amp;&amp; word.size() &gt; longest_word.size())\n    {\n      longest_word = word;\n    }\n  }\n  fin.close();\n\n  /* Print the output of the given characters */\n  cout&lt;&lt;input&lt;&lt;" = ";\n  cout&lt;&lt;longest_word&lt;&lt;endl;\n}\n</code></pre>\n<p>Ha azt szeretn&eacute;nk, hogy <strong>EGY</strong> leghosszabb sz&oacute; helyett az <strong>&Ouml;SSZES</strong> leghosszabbat &iacute;rja ki a program, akkor el kell t&aacute;rolnunk <em>az &ouml;sszes eddigi leghosszabb</em> list&aacute;j&aacute;t.&nbsp;Amennyiben tal&aacute;ltunk hosszabbat az eddigi leghosszabbakn&aacute;l, az &ouml;sszes eddigi leghosszabbat "el kell felejteni" (<em>lista &uuml;r&iacute;t&eacute;se</em>), &eacute;s az &uacute;j leghosszabbat betenni&nbsp;a list&aacute;ba. A feladat megoldhat&oacute; egy egyszer&#369; t&ouml;mbbel,de a C++ <strong>vector</strong> adatszerkezete&nbsp;k&eacute;nyelmesebb erre a feladatra. <br />A m&oacute;dos&iacute;tott k&oacute;d:</p>\n<pre><code>\nint main(int argc, char ** argv)\n{\n    string input = "abcd";\n    ifstream fin("enable1.txt"); /* open valid word list */\n    if (!fin.is_open())\n        return -1;\n\n    string word = "";\n    vector&lt;string&gt; longest_words;\n    longest_words.push_back("");\n    \n    while (!fin.eof())\n    {\n       fin&gt;&gt;word;\n       bool valid = true; /* Assume that the readed string is valid */\n       for (int i=0; i&lt;word.size(); ++i)\n       {\n	   /* Find if the ith character matches any of the input string character */\n          bool match = false;\n          for (int j=0; j&lt;input.size() && !match; ++j)\n          {\n            if (word[i] == input[j])\n	        match = true;\n          }\n          /* If any character not matched, the string not valid */\n           if (!match)\n	      valid = false;\n       }\n        /* If the current string is valid */\n      if (valid)\n      {\n          if (word.size() &gt;    longest_words[0].size())\n          {\n	    longest_words.clear();\n            longest_words.push_back(word);\n           }\n           else if (word.size() == longest_words[0].size())		            \n            longest_words.push_back(word);\n      }\n    }\n  fin.close();\n\n  /* Print the output of the given characters */\n   cout&lt;&lt;input&lt;&lt;" = ";\n   for (int i=0; i&lt;longest_words.size(); ++i)		         \n    cout&lt;&lt;longest_words[i]&lt;&lt;", ";\n cout&lt;&lt;endl;\n return 0;\n}\n</code></pre>\n<p style="text-align: left;">Eddig j&oacute;, azonban azt szeretn&eacute;nk, ha <strong>t&ouml;bb bemenetre</strong> is m&#369;k&ouml;dne a programunk.<br />R&aacute;ad&aacute;sul <em>nem szerencs&eacute;s a bemenetet a program forr&aacute;sk&oacute;dj&aacute;ban</em> (hard-k&oacute;dolva) t&aacute;rolni,&nbsp;mivel ilyenkor a bemenet megv&aacute;ltoztat&aacute;s&aacute;hoz a program &uacute;jraford&iacute;t&aacute;sa sz&uuml;ks&eacute;ges.<br />2 lehet&#337;s&eacute;g is adott:</p>\n<ol>\n<li>A program fut&aacute;sa sor&aacute;n bek&eacute;ri a felhaszn&aacute;l&oacute;t&oacute;l a bemenetek sz&aacute;m&aacute;t, &eacute;s a bemeneteket.</li>\n<li>A program fut&aacute;sa el&#337;tt parancssori argumentumk&eacute;nt megadjuk a bemeneteket.</li>\n</ol>\n<p>&Eacute;n most a 2. lehet&#337;s&eacute;get mutatom meg, aki akarja, megcsin&aacute;lhatja az els&#337;t,&nbsp;ugyanolyan j&oacute; megold&aacute;s. <br />A C (&eacute;s a C++) programok main f&uuml;ggv&eacute;nye 2 param&eacute;tert tartalmaz: a parancssori argumentumok sz&aacute;m&aacute;t (<strong>argc</strong>)&nbsp;&eacute;s az argumentumokat (<strong>argv</strong>). Ez tal&aacute;n &eacute;rint&#337;legesen m&aacute;r el&#337;ker&uuml;lt a <a title="Project Euler 1 - C nyelven" href="http://comsciblog.esy.es/article/26/Project+Euler+1+-+C+nyelven">Project Euler 1-es bejegyz&eacute;semben</a>&nbsp;, r&eacute;szletesebb inform&aacute;ci&oacute; tal&aacute;lhat&oacute; p&eacute;ld&aacute;ul ebben a <a title="R&eacute;szletesen a parancssori argumentumokr&oacute;l" href="https://wiki.sch.bme.hu/images/c/cc/Prog2_%C3%81ltal%C3%A1ban_a_parancssori_argumentumokr%C3%B3l.PDF" target="_blank">BME-s dokumentumban</a>.&nbsp;Az <strong>argc</strong> &eacute;rt&eacute;ke <em>n db argumentum eset&eacute;n n+1</em>, mivel a 0. argumentum a leford&iacute;tott futtathat&oacute; &aacute;llom&aacute;ny ("program") neve.&nbsp;A program futtat&aacute;sa el&#337;tt&nbsp;<em>c&eacute;lszer&#369; ellen&#337;rizni</em>, hogy adunk-e meg argumentumot. Ha nem adtunk meg, &eacute;rdemes t&aacute;j&eacute;koztatni&nbsp;a kedves felhaszn&aacute;l&oacute;t a program haszn&aacute;lat&aacute;r&oacute;l egy hiba&uuml;zenetben. Majd az argumentumokon v&eacute;gig iter&aacute;lva egy <strong>for</strong> ciklus seg&iacute;ts&eacute;g&eacute;vel&nbsp;<em>ugyanazt v&eacute;grehajtjuk</em> minden egyes bemeneten, amit az el&#337;z&#337; program csin&aacute;lt.<br /> A v&eacute;gleges k&oacute;d teh&aacute;t:</p>\n<pre><code>int main(int argc, char ** argv)\n{\n    if (argc &lt; 2)\n    {\n	cout&lt;&lt;"Usage: n string, the usable characters"&lt;&lt;endl;\n	return -1;\n    }\n    for (int k=1; k&lt;argc; ++k) /* all arugments */\n    {\n	string input = argv[k];\n\n	ifstream fin("enable1.txt"); /* open valid word list */\n	if (!fin.is_open())\n	    return -1;\n		 \n	string word = "";\n	vector longest_words;		      \n        longest_words.push_back("");\n	while (!fin.eof())\n	{\n	    fin&gt;&gt;word;\n	    bool valid = true; /* Assume that the readed string is valid */\n	    for (int i=0; i&lt;word.size(); ++i)\n	    {\n		 /* Find if the ith character matches any of the input string character */\n		 bool match = false;\n		 for (int j=0; j&lt;input.size() &amp;&amp; !match; ++j)\n		 {\n		   if (word[i] == input[j])\n		      match = true;\n		 }\n		 /* If any character not matched, the string not valid */\n		   if (!match)\n		      valid = false;\n		 }\n		 /* If the current string is valid */\n		 if (valid)\n		 {\n		   if (word.size() &gt; longest_words[0].size())\n		   {\n		   longest_words.clear();\n		   longest_words.push_back(word);\n		   }\n		 else if (word.size() == longest_words[0].size())\n	  longest_words.push_back(word);\n		 }\n  }\n  fin.close();\n		\n  /* Print the output of the given characters */\n  cout&lt;&lt;input&lt;&lt;" = ";\n  for (int i=0;i&lt;longest_words.size(); ++i)        \n   cout&lt;&lt;longest_words[i]&lt;&lt;", ";\n  cout&lt;&lt;endl;\n } \n return 0;\n}\n</code> </code></pre>\n<p>Az argumentumok megadhat&oacute;k k&ouml;zvetlen&uuml;l parancssorban: Windows alatt a Parancssor (cmd.exe) seg&iacute;ts&eacute;g&eacute;vel, a leford&iacute;tott *.exe f&aacute;jl m&ouml;g&eacute; &iacute;rhat&oacute;k az argumentumok,sz&oacute;k&ouml;zzel elv&aacute;lasztva [pl.: <strong>program.exe abcd efgh </strong><em>- term&eacute;szetesen a megfelel&#337; mapp&aacute;b&oacute;l kiadva</em>]. Linux alatt hasonl&oacute;an adhat&oacute;k meg az argumentumok, a futtathat&oacute; &aacute;llom&aacute;ny neve m&ouml;g&eacute; &iacute;rva, sz&oacute;k&ouml;zzel elv&aacute;lasztva. [pl.: <strong>./program_neve abcd efgh</strong> ] <br />&Aacute;ltal&aacute;ban a k&uuml;l&ouml;nb&ouml;z&#337; fejleszt&#337;eszk&ouml;z&ouml;k (IDE-k) is adnak lehet&#337;s&eacute;get az argumentumok megad&aacute;s&aacute;ra. P&eacute;ld&aacute;ul a <a title="CodeBlocks IDE hivatalos honlapja" href="http://www.codeblocks.org/" target="_blank">CodeBlocks IDE</a> haszn&aacute;lata eset&eacute;n a <strong>Project</strong> men&uuml; <strong>Set programs&apos; arguments</strong> men&uuml;pontja seg&iacute;ts&eacute;g&eacute;vel adhat&oacute;k meg a programunk argumentumai.</p>\n<small> Az illusztrációért köszönet a <a href="http://beta.diylol.com/memes/1-business-cat/posts/453561-the-keyboard-isn-t-working-the-internet-is-broken-111-one1" target="_blank"> diylol.com </a> weboldalnak </small>', '2015-10-29 09:36:01', '2015-10-29 10:46:49');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(42, 'comsciblog', 'Project Euler 10 - Szóljanak hangosan a prímek!', 'hu', '<p><strong>A k&ouml;vetkez&#337; feladat ism&eacute;t pr&iacute;msz&aacute;mokr&oacute;l sz&oacute;l, konkr&eacute;tan a 2000000 alatti pr&iacute;mek &ouml;sszeg&eacute;nek meghat&aacute;roz&aacute;sa a c&eacute;l. Ahelyett, hogy minden 2000000 alatti term&eacute;szetes sz&aacute;mra teszteln&eacute;nk, hogy pr&iacute;m-e (pr&iacute;mteszt&eacute;rt l&aacute;sd a <a href="http://comsciblog.esy.es/article/36/Project+Euler+3+-+Pr%C3%ADmfelbont%C3%A1s%2C+legnagyobb+pr%C3%ADm+oszt%C3%B3" target="_blank"> Project Euler 3 megold&aacute;s&aacute;t</a>), a feladatot r&eacute;gi &eacute;s hat&eacute;kony algoritmus seg&iacute;ts&eacute;g&eacute;vel oldom meg, Eratoszthen&eacute;sz szit&aacute;j&aacute;val. <br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="Eratoszthen&eacute;sz szit&aacute;ja - anim&aacute;lt gif" width="445" height="369" /></strong><span style="text-align: center;"><br />Eratoszthen&eacute;sz szit&aacute;ja algoritmus, anim&aacute;lt gif. K&eacute;p forr&aacute;sa:&nbsp;<a href="https://en.wikipedia.org/wiki/Eratosthenes" target="_blank">Wikip&eacute;dia</a></span></p>\n<p><strong><a href="https://en.wikipedia.org/wiki/Eratosthenes" target="_blank"><br /></a></strong>Az algoritmus nem t&uacute;l bonyolult elven alapul: Vegy&uuml;k az &ouml;sszes term&eacute;szetes sz&aacute;mot $N$ alatt (most $N=2000000$) &eacute;s &iacute;rjuk &#337;ket egy A list&aacute;ra. Ezen k&iacute;v&uuml;l legyen egy m&aacute;sik B list&aacute;nk, amelyen a "kisz&#369;rt" pr&iacute;meket tartalmazza. Az els&#337; pr&iacute;msz&aacute;mot ismerj&uuml;k, ez a 2, teh&aacute;t B lista kezdetben csak a 2-t tartalmazza. Vegy&uuml;k ki 2 t&ouml;bbsz&ouml;r&ouml;seit az A list&aacute;b&oacute;l (4,6,8...). Miut&aacute;n ezt megtett&uuml;k, l&eacute;pj&uuml;nk tov&aacute;bb a k&ouml;vetkez&#337; A-listabeli sz&aacute;mra (3), ugyan&uacute;gy tegy&uuml;k a B list&aacute;ra a pr&iacute;mek k&ouml;z&eacute;, &eacute;s ugyan&uacute;gy vegy&uuml;k ki a t&ouml;bbsz&ouml;r&ouml;seit (9,15,21...). Majd tov&aacute;bb a k&ouml;vetkez&#337;re, ami az 5, mivel a 4-et m&aacute;r kivett&uuml;k, mivel az a 2 t&ouml;bbsz&ouml;r&ouml;se! Mire N-ig &eacute;r&uuml;nk, A-b&oacute;l elfogynak a sz&aacute;mok, m&iacute;g B tartalmazza az $N$ alatti pr&iacute;meket!</p>\n<p><span style="text-decoration: underline;"><strong>Kiss&eacute; form&aacute;lisabban: </strong></span></p>\n<ol>\n<li>&nbsp;Az algoritmusunk $n=2$-vel indult, ami az els&#337; pr&iacute;m.</li>\n<li>&nbsp;A list&aacute;b&oacute;l kivett&uuml;k $2n, 3n, 4n...$ sz&aacute;mokat, vagyis a t&ouml;bbsz&ouml;r&ouml;s&ouml;ket.</li>\n<li>Ezut&aacute;n "l&eacute;ptett&uuml;k" $n$ &eacute;rt&eacute;k&eacute;t a k&ouml;vetkez&#337; m&eacute;g list&aacute;ban l&eacute;v&#337; elemre, ami $n=3$. &#336; a k&ouml;vetkez&#337; pr&iacute;m.</li>\n<li>&nbsp;A 2. &eacute;s 3. l&eacute;p&eacute;st ism&eacute;telt&uuml;k eg&eacute;szen addig, am&iacute;g $n$ &eacute;rt&eacute;ke nem egyenl&#337; $N$ hat&aacute;rral (ami most 2000000).</li>\n</ol>\n<p>A programban A lista gyan&aacute;nt egy bitekb&#337;l &aacute;ll&oacute; t&ouml;mb&ouml;t c&eacute;lszer&#369; haszn&aacute;lni ( C++ eset&eacute;ben &eacute;n <strong>vector</strong> adatt&iacute;pust haszn&aacute;ltam), ami jelzi, hogy az adott sz&aacute;m pr&iacute;m-e. Kezdetben mindegyik a lista eleme, vagyis igaz. Ezt a programban a <em>vektor konstruktor&aacute;ban</em> adtam meg: az els&#337; param&eacute;ter a m&eacute;rete (<strong>LIMIT+1</strong>, mivel 0-r&oacute;l kezdi az indexel&eacute;st), a m&aacute;sodik pedig a kezd&#337;&eacute;rt&eacute;k (<strong>true</strong>). A vektor indexe jel&ouml;li a sz&aacute;mot, az adott elem &eacute;rt&eacute;ke pedig azt, hogy az adott index pr&iacute;m-e. A list&aacute;b&oacute;l val&oacute; "kih&uacute;z&aacute;s" teh&aacute;t&nbsp;a t&ouml;bbsz&ouml;r&ouml;s&ouml;k hamisra &aacute;ll&iacute;t&aacute;s&aacute;val t&ouml;rt&eacute;nik. A program lefut&aacute;sa v&eacute;g&eacute;n az <strong>isPrime</strong> t&ouml;mbben az <em>igaz &eacute;rt&eacute;k&#369; indexek&nbsp;a pr&iacute;mek, a hamisak az &ouml;sszetett sz&aacute;mok!</em></p>\n<p><span style="text-decoration: underline;"><strong>K&ouml;vetkezzen teh&aacute;t a v&aacute;rva v&aacute;rt C++ forr&aacute;sk&oacute;d:</strong></span></p>\n<pre><code>   const int LIMIT = 2000000;\n\n   vector isPrime(LIMIT+1, true);\n   isPrime[0] = isPrime[1] = false;\n    for (int n=2; n&lt;isPrime.size(); ++n)\n    {\n        if (isPrime[n]) \n        {\n            for (int m=2*n; m&lt;isPrime.size(); m+=n)\n       		{\n                isPrime[m] = false;\n            }\n        }\n    }\n</code></pre>\n<p>B&aacute;r a program $N=2000000$ eset&eacute;n &iacute;gy is vill&aacute;mgyorsan lefut, <span style="text-decoration: underline;">az algoritmus m&eacute;g jav&iacute;that&oacute;</span>. &Eacute;szrevehet&#337;, hogy a lista bizonyos elemeit <em>t&ouml;bbsz&ouml;r &aacute;ll&iacute;t hamisra</em> a program. P&eacute;ld&aacute;ul a 15-&ouml;t "kih&uacute;zza" $n=3$ &eacute;s $n=5$ esetben is, a 660-at $n=2, n=3, n=5$ &eacute;s $n=11$ esetben is. Teh&aacute;t a programban m &eacute;rt&eacute;k&eacute;t $2n$ helyett elegend&#337; $n^2$-r&#337;l ind&iacute;tani, ez&aacute;ltal cs&ouml;kkentve a l&eacute;p&eacute;ssz&aacute;mot. Mivel azonban m els&#337; &eacute;rt&eacute;ke $n^2$, ez&eacute;rt az $n$ sz&aacute;mokat elegend&#337; $\\sqrt(N)$-ig vizsg&aacute;lni, ugyanis enn&eacute;l nagyobb $n$ eset&eacute;n a bels&#337; ciklus sohasem futna le, mivel m&aacute;r a kezdeti &eacute;rt&eacute;kad&aacute;sn&aacute;l (<strong>m=n*n</strong>) sem teljes&uuml;l a ciklus meg&aacute;ll&aacute;si felt&eacute;tele (<strong>m&lt;isPrime.size()</strong>).</p>\n<p><span style="text-decoration: underline;"><strong>A jav&iacute;tott k&oacute;d:</strong></span></p>\n<pre><code>   const int LIMIT = 2000000;\n   vector isPrime(LIMIT+1, true);\n   isPrime[0] = isPrime[1] = false;\n    for (int n=2; n&lt;sqrt(isPrime.size()); ++n)\n    {\n        if (isPrime[n]) \n        {\n            for (int m=n*n; m&lt;isPrime.size(); m+=n)\n       		{\n                isPrime[m] = false;\n            }\n        }\n    }\n</code></pre>\n<p>Ezek ut&aacute;n pedig m&aacute;r nincs m&aacute;s dolgunk, mint &ouml;sszeadni az igaz elemeket a t&ouml;mb&uuml;nkben. Erre pedig m&aacute;r mindenki rengeteg p&eacute;ld&aacute;t l&aacute;tott:</p>\n<pre><code>    unsigned long long sum = 0;\n    for (int i=2; i&lt;isPrime.size(); ++i)\n    {\n        if (isPrime[i])\n            sum+=i;\n    }\n    cout&lt;&lt;"Az osszeg: "&lt;&lt;sum&lt;&lt;endl;\n</code></pre>\n<p><span style="text-decoration: underline;"><strong>Megjegyz&eacute;s: </strong></span></p>\n<p>A feladat sor&aacute;n az &ouml;sszeget mindenk&eacute;pp 64-bites sz&aacute;mk&eacute;nt t&aacute;roljuk, ugyanis kisebb adatt&iacute;pus (pl.: egyszer&#369; 32-bites int) eset&eacute;n t&uacute;lcsordul&aacute;s l&eacute;p fel, &eacute;s helytelen lesz az eredm&eacute;ny&uuml;nk. Ugyanis az &ouml;sszeg nagyobb, mint $\\frac{2^{32}-1}{2}$, de m&eacute;g $2^{32} -1$-n&eacute;l is, teh&aacute;t az el&#337;jel n&eacute;lk&uuml;li 32 bites (unsigned int) sem megfelel&#337; ehhez a feladathoz.</p>\n<p><br />V&eacute;gezet&uuml;l pedig sz&oacute;ljon egy dal annak, aki v&eacute;gigolvasta (de legal&aacute;bbis v&eacute;gigg&ouml;rgette) ezt a bejegyz&eacute;st:&nbsp;</p>\n<p><iframe style="display: block; margin-left: auto; margin-right: auto;" src="https://www.youtube.com/embed/Pz53BrzxzKk" width="420" height="315" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>\n<p style="text-align: center;"><small> Forr&aacute;s: <a href="https://www.youtube.com/watch?v=Pz53BrzxzKk" target="_blank">Youtube.com</a></small></p>', '2015-09-01 10:50:34', '2015-09-01 11:14:04'),
(44, 'comsciblog', 'Project Euler 11 - Számkeres&#337;', 'hu', '<p><strong>A v&aacute;ltozatoss&aacute;g kedv&eacute;&eacute;rt ez&uacute;ttal ism&eacute;t egy Project Euleres feladatmegold&aacute;st teszek k&ouml;zz&eacute;. Viszont ez a feladat tal&aacute;n kev&eacute;sb&eacute; matematikai jelleg&#369;, mint az oldalon tal&aacute;lhat&oacute; probl&eacute;m&aacute;k j&oacute; r&eacute;sze, &iacute;gy ebben a bejegyz&eacute;semben tal&aacute;n t&ouml;bb lesz a C++-al kapcsolatos technikai apr&oacute;s&aacute;g, mint a t&eacute;nyleges matematika. A feladat egy&eacute;bk&eacute;nt egy sz&aacute;mr&aacute;csban megkeresni azt a 4 szomsz&eacute;dos (v&iacute;zszintesen, f&uuml;gg&#337;legesen vagy &aacute;tl&oacute;san) sz&aacute;mot, amelyeknek a legnagyobb a szorzata. A feladatban megadott r&aacute;cs:</strong> <img class="img-responsive" class="img-responsive" src="http://comsciblog.esy.es/img/grid.png" alt="20X20-as sz&aacute;mr&aacute;cs (Project Euler 11)" width="499" height="326" /></p>\n<p>Az algoritmus egyszer&#369;: <em>v&eacute;gig kell n&eacute;zni minden n&eacute;gyes szomsz&eacute;d szorzat&aacute;t f&uuml;gg&#337;legesen, v&iacute;zszintesen, valamint a t&aacute;bl&aacute;zat f&#337;&aacute;tl&oacute;iban &eacute;s mell&eacute;k&aacute;tl&oacute;iban</em>, &eacute;s mindegyik esetben egy egyszer&#369; maximumkiv&aacute;laszt&aacute;st v&eacute;gezni. Utols&oacute; l&eacute;p&eacute;sben pedig az &iacute;gy kapott 4 maximum legnagyobbik&aacute;t kiv&aacute;lasztva megvan a keresett sz&aacute;m. <br />Ezek alapj&aacute;n a C++ forr&aacute;sk&oacute;d egy r&eacute;szlete:</p>\n<pre><code>typedef vector &lt; vector&lt;int&gt; &gt; mtx;\nmtx read_matrix(const char * filename);\nint max_HV(mtx myGrid, int adjNumbers);\nint max_mainDiag(mtx myGrid, int adjNumbers);\nint max_minorDiag(mtx myGrid, int adjNumbers);\n\nint main()\n{\n    mtx myGrid = read_matrix("grid.txt"); //racs\n    if (myGrid.empty() )\n    	return -1;\n    	\n    const int adjNumbers = 4; //szomszedos szamok szama\n\n    print_matrix(myGrid);\n    int max1 = max_HV(myGrid, adjNumbers);\n    int max2 = max_mainDiag(myGrid, adjNumbers);\n    int max3 = max_minorDiag(myGrid, adjNumbers);\n\n    if (max1&gt;max2 &amp;&amp; max1&gt;max3)\n        cout&lt;&lt;max1&lt;&lt;endl;\n    else if (max2&gt;max1 &amp;&amp; max2&gt;max3)\n        cout&lt;&lt;max2&lt;&lt;endl;\n    else\n        cout&lt;&lt;max3&lt;&lt;endl;\n\n    return 0;\n}\n</code></pre>\n<p>A main f&uuml;ggv&eacute;ny el&#337;tt n&eacute;h&aacute;ny f&uuml;ggv&eacute;ny deklar&aacute;ci&oacute;ja tal&aacute;lhat&oacute;, illetve egy typedef kulcssz&oacute;val kezd&#337;d&#337; sor. A <strong>typedef</strong> seg&iacute;ts&eacute;g&eacute;vel l&eacute;trehoztam egy <strong>mtx</strong> t&iacute;pust, amely gyakorlatilag egy <strong>std::vector</strong> adatszerkezet, amelynek minden eleme <strong>std::vector&lt;int&gt;</strong> t&iacute;pus&uacute; ("vektor a vektorban", ami hasonl&iacute;t egy 2 dimenzi&oacute;s t&ouml;mbh&ouml;z, vagyis m&aacute;trixhoz). Ennek seg&iacute;ts&eacute;g&eacute;vel a tov&aacute;bbiakban <em>vector&lt; vector&lt;int&gt; &gt;</em> helyett el&eacute;g mindenhov&aacute; <em>mtx</em>-et &iacute;rnom, ugyanarr&oacute;l az adatt&iacute;pusr&oacute;l lesz sz&oacute;.<br /> <br /><strong><span style="text-decoration: underline;">Megjegyz&eacute;s:</span></strong></p>\n<p>Hasonl&oacute; hat&aacute;st &eacute;rhetn&eacute;nk el a <strong>#define mtx vector &lt; vector&lt;int&gt; &gt;</strong> makr&oacute; haszn&aacute;lat&aacute;val is, ez esetben azonban a <em>C(++) el&#337;ford&iacute;t&oacute;ja</em> cser&eacute;ln&eacute; ki a forr&aacute;sk&oacute;dban a az "<em>mtx</em>" karaktersorozatot "<em>vector &lt; vector&lt;int&gt; &gt;</em>" -re.</p>\n<h3><span style="text-decoration: underline;">Mit is csin&aacute;l a program? </span></h3>\n<p>Beolvassa a r&aacute;csot egy sz&ouml;veges f&aacute;jlb&oacute;l, v&eacute;gign&eacute;zi v&iacute;zszintesen &eacute;s f&uuml;gg&#337;legesen a 4 legnagyobb szomsz&eacute;dos sz&aacute;m szorzat&aacute;t (ezt a k&eacute;t l&eacute;p&eacute;st &ouml;sszevontam a max_HV f&uuml;ggv&eacute;nyben), majd ugyan&iacute;gy tesz a k&eacute;t &aacute;tl&oacute;ra is. Ezzel teh&aacute;t 3 maximum&eacute;rt&eacute;k&uuml;nk lesz, amib&#337;l a legnagyobbat ki&iacute;rja a k&eacute;perny&#337;re.</p>\n<h4><strong><span style="text-decoration: underline;">Sz&ouml;veges file olvas&aacute;sa</span></strong></h4>\n<p>A t&aacute;bl&aacute;zat t&aacute;rol&aacute;s&aacute;ra el&#337;sz&ouml;r is hozzunk l&eacute;tre egy &uuml;res sz&ouml;veges f&aacute;jlt. <span style="text-decoration: underline;">A f&aacute;jl tartalmazza mag&aacute;t a r&aacute;csot, valamint (az egyszer&#369;s&eacute;g kedv&eacute;&eacute;rt) a r&aacute;cs m&eacute;reteit, sz&eacute;less&eacute;g&eacute;t &eacute;s magass&aacute;g&aacute;t.</span> A m&eacute;reteket (20 20) c&eacute;lszer&#369; a sz&ouml;veg els&#337; sor&aacute;ba &iacute;rni, k&ouml;zvetlen&uuml;l a r&aacute;cs el&eacute;. A f&aacute;jl olvas&aacute;s&aacute;hoz C++-ban egy &uacute;j streamet kell nyitnunk, amely hasonl&oacute;an m&#369;k&ouml;dik, mint a j&oacute;l ismert <strong>cin</strong> objektum, viszont <em>standard input (billenty&#369;zet) helyett megadott sz&ouml;vegf&aacute;jlb&oacute;l</em> ("grid.txt") olvas. Mivel eg&eacute;sz sz&aacute;mokat (int) olvasunk be, nincs sz&uuml;ks&eacute;g a sz&oacute;k&ouml;z&ouml;k, sort&ouml;r&eacute;sek, illetve a sz&aacute;m eleji nulla karakterek kezel&eacute;s&eacute;re, a C++ gondoskodik r&oacute;la: whitespace (sz&oacute;k&ouml;z/sort&ouml;r&eacute;s/tabul&aacute;tor) karakterig olvas, &eacute;s az olvasott karaktersorozatot megpr&oacute;b&aacute;lja a beolvasand&oacute; t&iacute;puss&aacute; (int) konvert&aacute;lni. Miut&aacute;n beolvasta a sz&aacute;mokat, &eacute;s elt&aacute;rolta egy mtx t&iacute;pus&uacute; adatszerkezetben, visszat&eacute;r a t&aacute;bl&aacute;zattal.<br />A f&aacute;jl olvas&oacute; f&uuml;ggv&eacute;ny:</p>\n<pre><code>\nmtx read_matrix(const char * filename)\n{\n    ifstream fin(filename);\n    if (!fin.is_open())\n    	return mtx();\n    	\n    mtx mtx_back; //visszateresi matrix\n    int N, M;\n    fin&gt;&gt;N;\n    mtx_back.resize(N);\n    fin&gt;&gt;M;\n    for (int i=0; i&lt;N; ++i)\n    {\n        mtx_back[i].resize(M);\n        for (int j=0; j&lt;M; ++j)\n        {\n            fin&gt;&gt;mtx_back[i][j];\n        }\n    }\n    fin.close();\n    return mtx_back;\n}\n</code></pre>\n<h4><span style="text-decoration: underline;"><strong>Keres&eacute;s a t&aacute;bl&aacute;zatban</strong></span></h4>\n<p>A keres&eacute;s algoritmusa k&ouml;nnyen megfogalmazhat&oacute;: n&eacute;zz&uuml;k v&eacute;gig az &ouml;sszes n&eacute;gyes szomsz&eacute;dot, szorozzuk &ouml;ssze &#337;ket, &eacute;s v&aacute;lasszuk ki a legnagyobb szorzatot. Teh&aacute;t v&iacute;zszintesen induljuk az bal fels&#337; sarokb&oacute;l. Legyen a sorok indexe i=0, az oszlopok&eacute; j=0. Ekkor a legbaloldalibb n&eacute;gyes az $i.$ sorban a $j.$, $j+1.$, $j+2.$ &eacute;s $j+3.$ elem szorzata. Amennyiben ezt v&eacute;gign&eacute;zz&uuml;k minden $i&lt;N$-re &eacute;s $j&lt;N-4$-re (ahol most $N=20$), &eacute;s kiv&aacute;lasztjuk a szorzatok k&ouml;z&uuml;l a legnagyobbat, megkapjuk a v&iacute;zszintes szorzatok maximum&aacute;t. <br />K&ouml;nnyen &eacute;szrevehet&#337;, hogy a f&uuml;gg&#337;leges ir&aacute;ny hasonl&oacute;, mind&ouml;ssze az indexeket kell kicser&eacute;lni: vagyis i legyen az oszlopok indexe, j pedig a sorok&eacute;. Teh&aacute;t nem sz&uuml;ks&eacute;ges k&uuml;l&ouml;n f&uuml;ggv&eacute;nyt &iacute;rni, mind&ouml;ssze egy &uacute;j v&aacute;ltoz&oacute; seg&iacute;ts&eacute;g&eacute;vel ki tudjuk v&aacute;lasztani a sorok &eacute;s az oszlopok k&ouml;z&uuml;l a legnagyobbat, a k&ouml;vetkez&#337; m&oacute;don:</p>\n<pre><code>int max_HV(mtx myGrid, int adjNumbers)\n{\n    int maxProduct = 1;\n    for (int i=0; i&lt;myGrid.size(); ++i)\n    {\n        for (int j=0; j&lt;myGrid.size()-adjNumbers; ++j)\n        {\n            int product1 = 1, product2 = 1;\n            for (int k=0; k&lt;adjNumbers; ++k)\n            {\n                product1*=myGrid[i][j+k];\n                product2*=myGrid[j+k][i];\n            }\n\n            if (product1 &gt; maxProduct)\n            {\n                maxProduct = product1;\n            }\n            if (product2 &gt; maxProduct)\n            {\n                  maxProduct = product2;\n            }\n        }\n    }\n    return maxProduct;\n}\n</code></pre>\n<p>Az &aacute;tl&oacute;k vizsg&aacute;lat&aacute;nak elve is ugyanez. Az i. sor j. oszlop&aacute;b&oacute;l indul&oacute; "f&#337;&aacute;lt&oacute;-r&eacute;szlet" koordin&aacute;t&aacute;i: $(i,j), (i+1,j+1), (i+2, j+2), (i+3, j+3)$. <br /> A "mell&eacute;k&aacute;tl&oacute;-r&eacute;szletek&eacute;" pedig: $(i,j), (i-1,i+1), (i-2,i+2), (i-3,j+3)$. <br />Ezek alapj&aacute;n a f&#337;&aacute;tl&oacute;kat vizsg&aacute;l&oacute; f&uuml;ggv&eacute;ny k&oacute;dja:</p>\n<pre><code>int max_mainDiag(mtx myGrid, int adjNumbers)\n{\n   int maxProduct = 1;\n    for (int i=0; i&lt;myGrid.size()-adjNumbers; ++i)\n    {\n        for (int j=0; j&lt;myGrid.size()-adjNumbers; ++j)\n        {\n            int product = 1;\n            for (int k=0; k&lt;adjNumbers; ++k)\n            {\n                product*=myGrid[i+k][j+k];\n            }\n            if (product &gt; maxProduct)\n            {\n                maxProduct = product;\n            }\n        }\n    }\n    return maxProduct;\n}\n</code></pre>\n<p>A mell&eacute;k&aacute;tl&oacute;k&eacute; pedig:</p>\n<pre><code>int max_minorDiag(mtx myGrid, int adjNumbers)\n{\n   int maxProduct = 1;\n    for (int i=adjNumbers-1; i&lt;myGrid.size(); ++i)\n    {\n        for (int j=0; j&lt;myGrid.size()-adjNumbers; ++j)\n        {\n            int product = 1;\n            for (int k=0; k&lt;adjNumbers; ++k)\n            {\n                product*=myGrid[i-k][j+k];\n            }\n            if (product &gt; maxProduct)\n            {\n                maxProduct = product;\n            }\n        }\n    }\n    return maxProduct;\n}\n</code></pre>\n<h4><span style="text-decoration: underline;"><strong>Megjegyz&eacute;s:</strong></span></h4>\n<p>Ezek a f&uuml;ggv&eacute;nyeket is <em>&ouml;ssze lehetne vonni</em> az el&#337;z&#337;vel, vagyis a 3 helyett <em>el&eacute;g lenne egyszer v&eacute;gign&eacute;zni</em> a t&aacute;bl&aacute;zatot, &eacute;s a n&eacute;gy maximumb&oacute;l kiv&aacute;lasztani a legnagyobbat. Ekkor azonban <span style="text-decoration: underline;">figyelni kell, hogy nehogy "kiindexelj&uuml;nk"</span> a t&aacute;bl&aacute;zatb&oacute;l: vagyis meg kell vizsg&aacute;lni, hogy a kiz&aacute;r&oacute;lag $0$ &eacute;s $N-1$ k&ouml;z&ouml;tti sorra &eacute;s oszlopra hivatkozzunk, k&uuml;l&ouml;nben hib&aacute;s eredm&eacute;nyt kapunk, amennyiben lefut a program, vagy <em>mem&oacute;riakezel&eacute;si hib&aacute;val le is &aacute;llhat</em> a fut&oacute; programunk. Ennek a megval&oacute;s&iacute;t&aacute;s&aacute;t most nem ismertetem, az &eacute;rdekl&#337;d&#337; olvas&oacute;ra b&iacute;zom! :)</p>', '2015-09-14 09:42:34', '2015-09-14 10:04:29'),
(45, 'comsciblog', 'Objektumorientált C++ - Halmaz osztály', 'hu', '<p style="text-align: left;"><strong>A mostani bejegyz&eacute;s szint&eacute;n a C++ programoz&aacute;si nyelvhez kapcsol&oacute;dik. Az elej&eacute;n nagyvonalakban le&iacute;rom az objektumorient&aacute;lt megk&ouml;zel&iacute;t&eacute;s alapjait, majd egy p&eacute;ld&aacute;n kereszt&uuml;l szeml&eacute;ltetem a f&#337;bb fogalmakat, illetve a C++ nyelvi saj&aacute;toss&aacute;gai(nak egy apr&oacute;cska szelet&eacute;)t, egy matematikailag teljesen alapvet&#337; feladat, halmazok &eacute;s halmazm&#369;veletek megval&oacute;s&iacute;t&aacute;s&aacute;val.&nbsp;<img class="img-responsive" class="img-responsive" style="margin: 0px auto; display: block;" src="http://www.veritasprep.com/blog/wp-content/uploads/2012/09/SetsThree_1_23Sept.jpg" alt="Halmazok Venn-diagaramja" width="337" height="298" /><br /></strong>Halmazok Venn-diagramos &aacute;br&aacute;zol&aacute;sa. A k&eacute;p forr&aacute;sa: <a href="http://www.veritasprep.com/blog/2012/09/quarter-wit-quarter-wisdom-three-overlapping-sets/" target="_blank">http://www.veritasprep.com/</a></p>\n<p>Mi is az az objektumorient&aacute;lt programoz&aacute;s? Egy olyan programoz&aacute;si m&oacute;dszertan, amelyben nem a m&#369;veletek &aacute;llnak a k&ouml;z&eacute;ppontban, hanem azok az egys&eacute;gek (objektumok), amelyeken v&eacute;gezz&uuml;k a m&#369;veleteket. A vil&aacute;g modellez&eacute;s&eacute;n alapul: a val&oacute; vil&aacute;g objektumait modellezz&uuml;k, &eacute;s oszt&aacute;lyokat hozunk l&eacute;tre, amelyet p&eacute;ld&aacute;nyos&iacute;tva megkapjuk a konkr&eacute;t objektumainkat. Az objektumok k&uuml;l&ouml;nf&eacute;le adatok &eacute;s rajtuk v&eacute;gzett m&#369;veletek egys&eacute;gbe z&aacute;r&aacute;sa, teh&aacute;t egy objektum k&uuml;l&ouml;nb&ouml;z&#337; adattagokat &eacute;s tagf&uuml;ggv&eacute;nyeket (met&oacute;dusokat) tartalmaz. Ezek az objektumok persze egym&aacute;ssal is tudnak kommunik&aacute;lni, egyes r&eacute;szek l&aacute;that&oacute;s&aacute;ga elt&eacute;rhet, az oszt&aacute;lyok &ouml;r&ouml;kl&#337;dhetnek egym&aacute;sb&oacute;l, &eacute;s m&eacute;g sorolhatn&aacute;m ... <br />[Kicsit elnagyolt voltam, de nem az a c&eacute;lom, hogy ebben a bejegyz&eacute;sben &iacute;rjam le a teljes elm&eacute;letet elej&eacute;t&#337;l a v&eacute;g&eacute;ig. Akit &eacute;rdekel b&#337;vebben, nyisson ki b&aacute;rmilyen t&eacute;m&aacute;ba v&aacute;g&oacute; k&ouml;nyvet, vagy olvasson el egy <a title="Objektumorient&aacute;lt Programoz&aacute;s - Wikip&eacute;dia" href="https://hu.wikipedia.org/wiki/Objektumorient%C3%A1lt_programoz%C3%A1s" target="_blank">Wikip&eacute;dia sz&oacute;cikket</a>. ]</p>\n<p>N&eacute;zz&uuml;nk egy p&eacute;ld&aacute;t: Valami okb&oacute;l szeretn&eacute;nk halmazokkal dolgozni C++-ban, viszont &uacute;gy gondoljuk, hogy a nyelvnek nincs ilyen be&eacute;p&iacute;tett adatt&iacute;pusa (<a title="C++ Set referencia" href="http://www.cplusplus.com/reference/set/set/" target="_blank">val&oacute;j&aacute;ban van</a>). <br />Ekkor 3 dolgot tehet&uuml;nk:</p>\n<ol>\n<li>Keres&uuml;nk egy m&aacute;sik programoz&aacute;si nyelvet, amelyben a Halmaz (Set) be&eacute;p&iacute;tett adatt&iacute;pusk&eacute;nt szerepel.</li>\n<li>Szerz&uuml;nk valahonnan (Internetr&#337;l) egy oszt&aacute;lyt, amely seg&iacute;ts&eacute;g&eacute;vel p&eacute;ld&aacute;nyos&iacute;thatunk nek&uuml;nk megfelel&#337; (halmaz) objektumokat.</li>\n<li>Mi magunk &iacute;rjuk meg a k&iacute;v&aacute;nt oszt&aacute;lyt, hogy k&eacute;s&#337;bb &uacute;jra felhaszn&aacute;lhassuk/m&aacute;s is felhaszn&aacute;lhassa.</li>\n</ol>\n<p>&Eacute;n a 3. lehet&#337;s&eacute;get mutatn&aacute;m be. Els&#337; l&eacute;p&eacute;sben k&eacute;sz&iacute;ts&uuml;nk egy &uacute;j oszt&aacute;lyt:</p>\n<pre><code> class SET {} </code></pre>\n<p>Adjunk hozz&aacute; az oszt&aacute;ly adattagjait. Egy hamaz eset&eacute;ben ez n db sz&aacute;m (egy&eacute;b objektum is lehetne, de maradjunk az eg&eacute;sz sz&aacute;mokn&aacute;l.) Ezt sorrendben egy t&ouml;mbben/vektorban t&aacute;rolhatjuk. Viszont nem szeretn&eacute;nk megmutatni a nagyvil&aacute;gnak, hogy a mi sz&eacute;p kis halmazunk, (<em>amelyben se sorrend, se t&ouml;bbsz&ouml;r&ouml;ss&eacute;g)</em> val&oacute;j&aacute;ban egy vektor, ahol <em>minden elemnek pontos helye van, &eacute;s egy elem ak&aacute;r t&ouml;bbsz&ouml;r is el&#337;fordulhat</em>. Ez&eacute;rt <strong>priv&aacute;tt&aacute;</strong> tessz&uuml;k:</p>\n<pre><code>class Set<br />{<br /> private:<br /> vector &lt;int&gt; elements;<br />}\n</code></pre>\n<p>Ezut&aacute;n j&ouml;hetnek a <strong>konstruktorok</strong>. Ezek olyan speci&aacute;lis f&uuml;ggv&eacute;nyek, amelyek az <em>objektum l&eacute;trej&ouml;ttekor h&iacute;v&oacute;dnak meg, inicializ&aacute;lj&aacute;k</em> (kezdeti &eacute;rt&eacute;ket adnak) az objektumot. Mindenk&eacute;ppen sz&uuml;ks&eacute;g van egy &uuml;res konstruktorra, akkor is, ha nem csin&aacute;l semmit, mivel ez az alap&eacute;rtelmezett. Teh&aacute;t ha nem mondunk m&aacute;st, ez h&iacute;v&oacute;dik meg. Ezen k&iacute;v&uuml;l &iacute;rhatunk k&uuml;l&ouml;nb&ouml;z&#337; &eacute;rt&eacute;kad&oacute; konstruktorokat is, mint p&eacute;ld&aacute;ul a k&ouml;vetkez&#337;, amely egy egyszer&#369; C t&ouml;mbben adja &aacute;t az &eacute;rt&eacute;ket a halmazunknak. Vagyis a k&ouml;vetkez&#337; sorok ker&uuml;ljenek a Set oszt&aacute;lyunk kapcsos z&aacute;r&oacute;jelei k&ouml;z&eacute;:</p>\n<pre><code> public:<br /> Set(){ }; /* alapertelmezett ures konstruktor */<br />\nSet(int * elems, int N)<br /> {<br />   for (int i=0; i&lt;N; ++i)<br />   {<br />     if (!isElement(elems[i]))<br />     this-&gt;elements.push_back(elems[i]);<br />   }<br /> }\nbool isElement(int elem)<br /> {<br />   for (int i=0; i&lt;elements.size(); ++i)<br />     if (elements[i]==elem)<br />       return true;<br />   return false;<br /> }\n</code></pre>\n<p>A fenti k&oacute;dban az isElement egy <strong>tagf&uuml;ggv&eacute;ny</strong>, vagyis az adott objektumon hajt&oacute;dik v&eacute;gre. Egy param&eacute;tere van, ami a halmaz egy lehets&eacute;ges eleme (jelen esetben eg&eacute;sz sz&aacute;m), &eacute;s azt ellen&#337;rzi, hogy a lehets&eacute;ges elem eleme-e a halmaznak.</p>\n<p>&Iacute;gy m&aacute;r egy haszn&aacute;lhat&oacute; k&oacute;dot kaptunk. Vagyis a k&ouml;vetkez&#337; k&oacute;dsorok m&aacute;r m&#369;k&ouml;dnek:</p>\n<pre><code> \nSet A(); /* a zarojel elhagyhato (alapertelmezett konstruktor) */<br />int arr[5] = {2,4,6,8,10};<br />Set B(arr, 5); /* ertekado konstruktor */<br />cout&lt;&lt;B.isElement(8)&lt;&lt;B.isElement(9)&lt;&lt;endl;\n</code></pre>\n<p>Persze c&eacute;lszer&#369; megcsin&aacute;lni egy ki&iacute;rat&oacute; met&oacute;dust is, amellyel megtekinthet&#337;k a t&ouml;mb elemei, valamint egy hozz&aacute;ad&aacute;s met&oacute;dust, amivel elemet adhatunk hozz&aacute; a halmazhoz, de ak&aacute;r k&eacute;sz&iacute;thet&uuml;nk egy olyan met&oacute;dust is, amivel az adott halmaz hatv&aacute;nyhalmaz&aacute;t &aacute;ll&iacute;tjuk el&#337;.</p>\n<p>A egy halmazon v&eacute;gzett m&#369;veleteken k&iacute;v&uuml;l fontosak lehetnek a <span style="text-decoration: underline;">t&ouml;bb halmazon v&eacute;gzett m&#369;veletek</span>: &uacute;ni&oacute;, metszet, k&uuml;l&ouml;nbs&eacute;g, szimmetrikus differencia, &eacute;s &iacute;gy tov&aacute;bb. Ezek n<em>em egy halmazobjektum met&oacute;dusai</em>, hanem f&uuml;ggv&eacute;nyek, amelyeknek param&eacute;terei az adott m&#369;velet operandusai (p&eacute;ld&aacute;ul&nbsp;${A \\cup B}$ eset&eacute;n $A$ &eacute;s $B$), &eacute;s visszat&eacute;r&eacute;si &eacute;rt&eacute;ke az eredm&eacute;ny&uuml;l kapott halmaz objektum.<br />Viszont a megval&oacute;s&iacute;t&aacute;s&aacute;hoz hozz&aacute; kell f&eacute;rn&uuml;nk az egyes objektumok f&eacute;ltve &#337;rz&ouml;tt priv&aacute;t adattagjaihoz, vagyis az elemeihez. A C++ nyelvben ezt a <strong>friend</strong> kulcssz&oacute; seg&iacute;ts&eacute;g&eacute;vel tehetj&uuml;k meg. A bar&aacute;t f&uuml;ggv&eacute;nyeket ugyan a<em>z oszt&aacute;lyon bel&uuml;l kell deklar&aacute;lnunk, m&eacute;gsem az oszt&aacute;ly met&oacute;dusai</em>, hanem egyszer&#369; f&uuml;ggv&eacute;nyek, amelyek k&eacute;pesek el&eacute;rni az adott oszt&aacute;ly priv&aacute;t tagjait is. Vagyis a</p>\n<pre><code> friend Set unio (Set &amp; A, Set &amp; B);</code></pre>\n<p>deklar&aacute;ci&oacute; az objektumon bel&uuml;lre ker&uuml;l, m&eacute;gis haszn&aacute;lat eset&eacute;n<br />C = unio(A,B); - k&eacute;nt kell hivatkozni r&aacute; (ahol A,B,C Set objektumok).</p>\n<p>De mi van, ha a halmazok uni&oacute;j&aacute;t 2 halmaz &ouml;sszeg&eacute;nek fogjuk fel, &eacute;s szeretn&eacute;nk C=A+B alakban haszn&aacute;lni az uni&oacute;k&eacute;pz&eacute;st. Erre szolg&aacute;l az &uacute;gynevezett oper&aacute;tor t&uacute;lt&ouml;lt&eacute;s (operator overloading). Teh&aacute;t ugyan&uacute;gy meg&iacute;rjuk a logik&aacute;t, mint ahogy egyszer&#369; f&uuml;ggv&eacute;nyn&eacute;l tenn&eacute;nk, viszont a deklar&aacute;ci&oacute; sor&aacute;n oper&aacute;tork&eacute;nt defini&aacute;ljuk, amelynek param&eacute;terei az oper&aacute;tor jobb &eacute;rt&eacute;ke &eacute;s bal &eacute;rt&eacute;ke (A+B eset&eacute;n A &eacute;s B). Vagyis az el&#337;z&#337; uni&oacute;s p&eacute;ld&aacute;n&aacute;l maradva a</p>\n<pre><code> friend Set operator + (Set &amp; A, Set &amp; B); </code></pre>\n<p>deklar&aacute;ci&oacute;val (a logika meg&iacute;r&aacute;sa ut&aacute;n) m&aacute;r haszn&aacute;lhatjuk a + oper&aacute;tort Set objektumokra is, viszont ett&#337;l m&eacute;g m&#369;k&ouml;dni fog a hagyom&aacute;nyos + a sz&aacute;mok &ouml;sszead&aacute;s&aacute;ra, illetve stringek &ouml;sszef&#369;z&eacute;s&eacute;re is.</p>\n<p>Egy teljes halmazoszt&aacute;ly el&eacute;rhet&#337; az al&aacute;bbi linken:<br /><a title="Set Class C++" href="http://pastebin.com/9gsw1LYT" target="_blank">http://pastebin.com/9gsw1LYT</a></p>\n<p>Akinek van kedve, olvasgassa, b&#337;v&iacute;tgesse, vagy egyszer&#369;en csak haszn&aacute;lja eg&eacute;szs&eacute;ggel!</p>', '2015-10-08 12:17:25', '2015-10-08 12:41:05'),
(46, 'comsciblog', 'Project Euler 13 – Tanuljunk meg összeadni!', 'hu', '<p>&nbsp;<strong>Aki esetleg valami okn&aacute;l fogva nem eml&eacute;kezne az &aacute;ltal&aacute;nos iskola 2. oszt&aacute;lyos matematika&oacute;r&aacute;kra, annak megtan&iacute;tok egy &uacute;j sz&aacute;mol&aacute;si elj&aacute;r&aacute;st, amivel tetsz&#337;legesen nagy sz&aacute;mokat tudunk (&iacute;r&aacute;sban) &ouml;sszeadni. Akinek m&eacute;gis r&eacute;mlik valami, &eacute;s szeretn&eacute; megtan&iacute;tani sz&aacute;m&iacute;t&oacute;g&eacute;p&eacute;nek ezt az elj&aacute;r&aacute;st, az is nyugodtan olvassa el a bejegyz&eacute;st, ugyanis a Project Euler 13. feladata: 50 jegy&#369; sz&aacute;mok &ouml;sszead&aacute;sa. A felhaszn&aacute;lt programoz&aacute;si nyelv ez&uacute;ttal is a C++ lesz.<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http://comsciblog.esy.es/img/irasbeli_osszeadas.jpeg" alt="&Iacute;r&aacute;sbeli &ouml;sszead&aacute;s" /><br /> </strong></p>\n<p>Rem&eacute;lem mindenki eml&eacute;kszik r&aacute;, hogy &aacute;ltal&aacute;nos iskol&aacute;ban hogyan tanult &iacute;r&aacute;sban &ouml;sszeadni: A<em> k&eacute;t &ouml;sszeadand&oacute; tagot egym&aacute;s al&aacute; &iacute;rta, &eacute;s a legkisebb helyi&eacute;rt&eacute;kt&#337;l indulva a legnagyobbig sz&aacute;mjegyenk&eacute;nt adta &ouml;ssze</em> a k&eacute;t nagy sz&aacute;mot. Amennyiben a k&eacute;t sz&aacute;mjegy &ouml;sszege <em>nagyobb volt t&iacute;zn&eacute;l</em>, vette az eredm&eacute;ny t&iacute;zzel vett <em>oszt&aacute;si marad&eacute;k&aacute;t</em> (levont t&iacute;zet), &eacute;s <em>&aacute;tvitelk&eacute;nt</em> megjegyezte. Majd &aacute;tvitel eset&eacute;n k&ouml;vetkez&#337; &bdquo;menetben&rdquo; eggyel n&ouml;velte a kapott eredm&eacute;nyt.</p>\n<p>Nagyj&aacute;b&oacute;l ugyanezt az algoritmust programoztam le a feladat elk&eacute;sz&iacute;t&eacute;s&eacute;hez. Az&eacute;rt volt r&aacute; sz&uuml;ks&eacute;gem, mivel a ugyan C++ nyelvben van &ouml;sszead&aacute;s m&#369;velet (mint b&aacute;rmely m&aacute;s programoz&aacute;si nyelvben, mivel a sz&aacute;m&iacute;t&oacute;g&eacute;pekben &aacute;ramk&ouml;r szinten megval&oacute;s&iacute;tva az &ouml;sszead&aacute;s), viszont a legnagyobb eg&eacute;sz sz&aacute;m t&iacute;pus 64 bites, amely $2^{64}$ &eacute;rt&eacute;k t&aacute;rol&aacute;s&aacute;ra k&eacute;pes, de nek&uuml;nk legal&aacute;bb $10^{52}$-es nagys&aacute;grend&#369; sz&aacute;mokat kell t&aacute;rolnunk. Ez&eacute;rt a feladathoz <strong>stringeket</strong> haszn&aacute;ltam, ahol <span style="text-decoration: underline;">egy karakter egy sz&aacute;mjegyet</span> jelentett. A sz&aacute;mokat soronk&eacute;nt egy f&aacute;jlb&oacute;l olvastam, &eacute;s a fent eml&iacute;tett algoritmussal &ouml;sszeadtam &#337;ket. <br />A program forr&aacute;sk&oacute;dja:</p>\n<pre><code> \nstring BigIntStrAdd(string left_str, string right_str)\n{\n    /* A bal oldali tag legyen a nagyobb */\n    if (right_str.size() &gt; left_str.size())\n        swap(right_str, left_str);\n\n    int numSize = left_str.size();\n    /* Kisebb ele kiegeszito nullak: */\n    while (right_str.size() != numSize)\n    {\n        right_str.insert(0,1,&apos;0&apos;);\n    }\n\n    /* Osszeadas algoritmus: legkisebb helyiertektol, atvitelekkel */\n    string result_str;\n    int carry = 0;\n    for (int i=numSize-1; i&gt;=0; --i)\n    {\n        int a = left_str[i]-&apos;0&apos;;\n        int b = right_str[i]-&apos;0&apos;;\n        int c = (a+b+carry)%10;\n        carry = (a+b+carry)/10;\n        result_str.push_back(c+&apos;0&apos;);\n    }\n    if (carry)\n        result_str.push_back(carry+&apos;0&apos;);\n    result_str = string(result_str.rbegin(), result_str.rend());\n    return result_str;\n}\n\nint main()\n{\n    ifstream fin("number.txt");\n    string number_str, line;\n\n    string sum_str = "";\n    while (!fin.eof())\n    {\n        getline(fin, line);\n        sum_str = BigIntStrAdd(sum_str, line);\n    }\n    fin.close();\n    cout&lt;&lt;sum_str.substr(0, 10)&lt;&lt;endl;\n\n    return 0;\n}\n\n</code></pre>\n<p>Az algoritmus sor&aacute;n felteszem, hogy <span style="text-decoration: underline;">egyenl&#337; hossz&uacute;ak</span> a sz&aacute;mok. Ha nem, a r&ouml;videbb elej&eacute;re <span style="text-decoration: underline;">kieg&eacute;sz&iacute;t&#337; null&aacute;kat</span> f&#369;z&ouml;k, amit&#337;l a sz&aacute;m &eacute;rt&eacute;ke nem v&aacute;ltozik meg. A ciklus a <em>stringek v&eacute;g&eacute;t&#337;l az elej&eacute;ig</em> (legkisebb helyi&eacute;rt&eacute;kt&#337;l legnagyobbig) megy. A k&eacute;t &ouml;sszeadand&oacute; sz&aacute;mjegyet az <strong>a</strong> &eacute;s <strong>b</strong> v&aacute;ltoz&oacute; t&aacute;rolja. Ez megegyezik az egyes stringek <span style="text-decoration: underline;">i. karakter&eacute;vel</span>, kivonva a nulla karakter k&oacute;dj&aacute;t, hogy ASCII-k&oacute;dok helyett val&oacute;ban 0 &eacute;s 9 k&ouml;z&ouml;tti sz&aacute;mokkal sz&aacute;moljunk. (A karakterk&oacute;dok &eacute;s a sz&aacute;mjegy &eacute;rt&eacute;kek k&ouml;z&ouml;tti k&uuml;l&ouml;nbs&eacute;gr&#337;l m&aacute;r volt sz&oacute; a <a title="Palindromok - Indul a g&ouml;r&ouml;g aludni!" href="http://comsciblog.esy.es/article/35/Project+Euler+04+-+Indul+a+g%C3%B6r%C3%B6g+aludni%21" target="_blank">palindromsz&aacute;mos bejegyz&eacute;sben</a>.) A <strong>carry</strong> v&aacute;ltoz&oacute; t&aacute;rolja, hogy <em>volt-e marad&eacute;k</em>, ami 0 vagy 1 lehet. Minden iter&aacute;ci&oacute; sor&aacute;n &ouml;sszeadom az adott <strong>a</strong> &eacute;s <strong>b</strong> sz&aacute;mjegyet &eacute;s a marad&eacute;kot, &eacute;s a t&iacute;zzel vett oszt&aacute;si marad&eacute;k biztos&iacute;tja, hogy val&oacute;ban <em>egyjegy&#369;</em> legyen az eredm&eacute;ny. A <strong>carry</strong> &eacute;rt&eacute;ke pedig pontosan akkor 1, ha az el&#337;z&#337; &ouml;sszeg nagyobb t&iacute;zn&eacute;l, vagyis ha t&iacute;zzel osztva (eg&eacute;szekre kerek&iacute;tve &ndash; integer oszt&aacute;s) 1 az eredm&eacute;ny. Majd az &iacute;gy kapott a kezdetben &uuml;res eredm&eacute;nyhez f&#369;z&ouml;m, term&eacute;szetesen visszaalak&iacute;tva sz&aacute;mkarakterr&eacute; (<strong>+&apos;0&apos;</strong>).</p>\n<p>Utols&oacute; l&eacute;p&eacute;sk&eacute;nt maradt az eredm&eacute;ny <span style="text-decoration: underline;">string megford&iacute;t&aacute;sa</span>, mivel az algoritmus a legkisebb helyi&eacute;rt&eacute;k&#369; sz&aacute;mjegyet f&#369;zte a string legelej&eacute;re, a m&aacute;sodik legkisebbet az m&ouml;g&eacute;, &hellip; , &eacute;s &iacute;gy a legnagyobb helyi&eacute;rt&eacute;k&#369; ker&uuml;lt a legv&eacute;g&eacute;re. <br />Miut&aacute;n ez is megt&ouml;rt&eacute;nt, a f&uuml;ggv&eacute;ny visszat&eacute;r a kapott eredm&eacute;nnyel.</p>\n<h3><span style="text-decoration: underline;"><strong>Megyjegyz&eacute;s:</strong></span></h3>\n<p>Ugyanehhez a feladathoz a megold&aacute;s programoz&aacute;si nyelvenk&eacute;nt elt&eacute;r&#337; lehet, ugyanis vannak nyelvek, amelyekhez van a nagy eg&eacute;sz sz&aacute;mok t&aacute;rol&aacute;s&aacute;ra alkalmas oszt&aacute;ly (big integer...), illetve van, ahol az alapvet&#337; eg&eacute;sz sz&aacute;m t&iacute;pussal k&eacute;pesek vagyunk tetsz&#337;legesen nagy sz&aacute;mokkal dolgozni. A fent le&iacute;rt &ouml;sszead&oacute; algoritmus akkor is felhaszn&aacute;lhat&oacute;, ha mi szeretn&eacute;nk a C++-hoz, &bdquo;BigInteger&rdquo; oszt&aacute;lyt &iacute;rni. Ekkor az oszt&aacute;ly priv&aacute;t adattagja a sz&aacute;mjegyeket t&aacute;rol&oacute; string (b&aacute;trabbaknak esetleg el&#337;jel.), &eacute;s az &ouml;sszead&oacute; + oper&aacute;tornak lehet a logik&aacute;ja a fent le&iacute;rt BigIntStrAdd nev&#369; f&uuml;ggv&eacute;ny. (Az OOP-r&#337;l b&#337;vebben l&aacute;sd: <a title="Objektumorient&aacute;lt programoz&aacute;s" href="http://comsciblog.esy.es/keyword/OOP" target="_blank">set oszt&aacute;ly</a>, vagy <a title="Objektumorient&aacute;lt programoz&aacute;s - Google keres&eacute;s" href="http://lmgtfy.com/?q=objektumorient%C3%A1lt+programoz%C3%A1s" target="_blank">Google-keres&eacute;s</a>.)&nbsp;</p>', '2015-10-19 10:06:56', '2015-10-19 10:16:37');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(61, 'comsciblog', 'Rénszarvas Olimpia - Advent of Code 14', 'hu', '<p><strong>Id&eacute;n rendezik a R&eacute;nszarvas Olimpi&aacute;t! A r&eacute;nszarvasok nagyon gyorsan k&eacute;pesek rep&uuml;lni, de n&eacute;ha meg kell &aacute;llniuk pihenni. A Mikul&aacute;s szeretn&eacute; tudni, melyik a leggyorsabb, ez&eacute;rt versenyt rendez. A r&eacute;nszarvasok vagy teljes sebess&eacute;ggel rep&uuml;lnek, vagy teljesen meg&aacute;llnak, &eacute;s pihennek. A r&eacute;nszarvasok k&uuml;l&ouml;nb&ouml;z&#337; sebess&eacute;gekkel k&eacute;pesek rep&uuml;lni k&uuml;l&ouml;nb&ouml;z&#337; ideig, de azt&aacute;n meg kell &aacute;llniuk pihenni. A pihen&eacute;s id&#337;tartama is r&eacute;nszarvasonk&eacute;nt v&aacute;ltozik. A szarvasok adatait a megadott <a href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day14_input.txt" target="_blank">day14_input.txt</a> sz&ouml;vegf&aacute;jl tartalmazza.<br /></strong><strong><span style="text-decoration: underline;">1. K&eacute;rd&eacute;s:</span> 2503 m&aacute;sodperc ut&aacute;n h&aacute;ny km t&aacute;vols&aacute;gig jut el a leggyorsabb r&eacute;nszarvas?</strong><br /><strong><span style="text-decoration: underline;">2. K&eacute;rd&eacute;s:</span> A Mikul&aacute;s el&eacute;gedetlen az eredm&eacute;nnyel, ez&eacute;rt v&aacute;ltoztat a szab&aacute;lyokon. <br />Pontoz&aacute;sos rendszert alak&iacute;t ki: minden egyes m&aacute;sodpercben az &eacute;ppen vezet&#337; r&eacute;nszarvas kap egy pontot. Holtverseny eset&eacute;n mindenki kap egy-egy pontot. A k&eacute;rd&eacute;s hogy kinek lesz a legt&ouml;bb pontja pontosan 2503 m&aacute;sodperc ut&aacute;n? (Mivel minden m&aacute;s id&#337;tartam eset&eacute;n az eg&eacute;sz verseny teljesen &eacute;rtelmetlen lenne.)</strong> <br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/Frozen_sven.jpg" alt="Sven a J&eacute;gvar&aacute;zs c&iacute;m&#369; rajzfilmb&#337;l." width="600" height="338" /><sub><br />Sven a J&eacute;gvar&aacute;zs c&iacute;m&#369; anim&aacute;ci&oacute;s filmb&#337;l. B&aacute;r &#337; szem&eacute;ly szerint nem a Mikul&aacute;s r&eacute;nszarvasa, illusztr&aacute;ci&oacute;nak az&eacute;rt megfelel. (A k&eacute;p egy&eacute;bk&eacute;nt a &nbsp;<a title="Disney.hu - Sven adatlapja" href="http:&#47;&#47;www.disney.hu/filmek/jegvarazs/szereplok/sven" target="_blank">disney.hu</a>&nbsp;oldalr&oacute;l sz&aacute;rmazik.)</sub></p>\r\n<p>A megval&oacute;s&iacute;t&aacute;shoz a Java nyelvet haszn&aacute;ltam. Az &ouml;tlet az volt, hogy <em>leszimul&aacute;lom a versenyt</em>, &iacute;gy k&ouml;zben m&eacute;g szurkolni is lehet a kedvenc r&eacute;nszarvasunknak. <span style="text-decoration: underline;">Gondolkodjunk objektumorient&aacute;ltan:</span> kezdetnek k&eacute;sz&iacute;ts&uuml;nk el a <strong>Reindeer</strong> oszt&aacute;lyt, aminek p&eacute;ld&aacute;nyai lesznek majd az egyes r&eacute;nszarvasok. Minden r&eacute;nszarvasnak van teh&aacute;t legal&aacute;bb 4 r&aacute; jellemz&#337; tulajdons&aacute;ga: n&eacute;v, sebess&eacute;g, rep&uuml;l&eacute;si id&#337;, &eacute;s pihen&#337;id&#337;. Ezen k&iacute;v&uuml;l minden szarvas k&eacute;t &aacute;llapotban lehet: rep&uuml;l &eacute;s pihen. Ezen k&iacute;v&uuml;l c&eacute;lszer&#369; lenne ismerni a szarvas &aacute;ltal megtett utat, teh&aacute;t ezt is felvehetj&uuml;k tulajdons&aacute;gnak.</p>\r\n<pre><code>public class Reindeer \r\n{\r\n	private int speed, flyTime, maxFlyTime, restTime, maxRestTime, distance;\r\n	private String name;\r\n\r\n	public Reindeer(String name, int speed, int maxFlyTime, int maxRestTime)\r\n	{\r\n		this.speed = speed;\r\n		this.maxFlyTime = this.flyTime = maxFlyTime;\r\n		this.maxRestTime = maxRestTime;\r\n		this.distance = 0;\r\n		this.restTime = 0;\r\n		this.name = name;\r\n	}\r\n}\r\n</code></pre>\r\n<p>A fenti k&oacute;dr&eacute;szletben a <strong>maxFlyTime</strong> jelenti azt az id&#337;t, amit egyhuzamban rep&uuml;lni k&eacute;pes a r&eacute;nszarvas. Hasonl&oacute;an a <strong>maxRestTime</strong> pedig azt az id&#337;t, amennyit pihennie kell. Ezeket kell param&eacute;terk&eacute;nt megadni. A <strong>flyTime</strong> &eacute;s <strong>restTime</strong> v&aacute;ltoz&oacute;kat az&eacute;rt vettem fel, hogy jelezze, hogy az adott m&aacute;sodpercben milyen &aacute;llapotban van a r&eacute;nszarvas: H&aacute;ny m&aacute;sodperce pihen, illetve mennyit tud m&eacute;g rep&uuml;lni. Vagyis ezek minden m&aacute;sodpercben v&aacute;ltoznak, m&iacute;g a <strong>maxFlyTime</strong> &eacute;s <strong>maxRestTime</strong> az &aacute;llatra jellemz&#337; tulajdons&aacute;gok, &aacute;lland&oacute;k. Kezdetben mindegyik&uuml;k kipihent, teh&aacute;t az indul&aacute;s id&#337;pillanat&aacute;ban mindegyik annyit rep&uuml;l, amennyit tud (teh&aacute;t <strong>maxFlyTime</strong>). Pihenni pedig egyiknek sem kell, ez&eacute;rt az 0.</p>\r\n<p>A r&eacute;nszarvasok reptet&eacute;s&eacute;hez sz&uuml;ks&eacute;g&uuml;k van egy met&oacute;dusra, amit megh&iacute;vva rep&uuml;lhetnek az &aacute;llatok. Ez a lenti k&oacute;dban a doAction, ami k&eacute;t dolgot tehet. Ha b&iacute;rnak m&eacute;g futni (<strong>flyTime&gt;0</strong>), akkor n&ouml;veli a megtett t&aacute;vols&aacute;got (<strong>distance</strong>), egy&eacute;bk&eacute;nt pihen, amennyit kell. Rep&uuml;l&eacute;s k&ouml;zben cs&ouml;kken a m&eacute;g egyhuzamban rep&uuml;lhet&#337; id&#337; (<strong>flyTime</strong>), pihen&eacute;s k&ouml;zben pedig n&#337; a pihen&eacute;ssel t&ouml;lt&ouml;tt id&#337; (<strong>restTime</strong>).</p>\r\n<pre><code>public class Reindeer \r\n{\r\n	private int speed, flyTime, maxFlyTime, restTime, maxRestTime, distance;\r\n	private String name;\r\n	\r\n	public Reindeer(String name, int speed, int maxFlyTime, int maxRestTime)\r\n	{\r\n		this.speed = speed;\r\n		this.maxFlyTime = this.flyTime = maxFlyTime;\r\n		this.maxRestTime = maxRestTime;\r\n		this.distance = 0;\r\n		this.restTime = 0;\r\n		this.name = name;\r\n	}\r\n	\r\n	public int getDistance()\r\n	{\r\n		return this.distance;\r\n	}\r\n	public String getName()\r\n	{\r\n		return this.name;\r\n	}\r\n	\r\n	public void doAction()\r\n	{\r\n		if (flyTime &gt; 0)\r\n		{\r\n			System.out.println("Running! Current distance: "+distance+" km");\r\n			distance+=speed;\r\n			--flyTime;\r\n			if (flyTime==0) &#47;&#47;if finish flying, starting to rest\r\n				restTime = 0;\r\n		}\r\n		else \r\n		{\r\n			System.out.println("Resting..."+(maxRestTime-restTime)+" seconds remaining");\r\n			++restTime;\r\n			if (restTime == maxRestTime)\r\n				flyTime = maxFlyTime;\r\n		}\r\n	}\r\n	\r\n	public String toString()\r\n	{\r\n		String back = "Name: "+name+" is in "+distance+" km (speed: "+speed+" km/s for "+maxFlyTime+" s, then rest "+maxRestTime+" s)\\n";\r\n		return back;\r\n	}\r\n}\r\n</code></pre>\r\n<p>Miut&aacute;n ez elk&eacute;sz&uuml;lt, elkezdhetj&uuml;k a f&#337; program meg&iacute;r&aacute;s&aacute;t. Ehhez el&#337;sz&ouml;r is<em> a bemeneti f&aacute;jlt kell feldolgozni</em>, &eacute;s "kiszedni" bel&#337;le az inform&aacute;ci&oacute;kat. Soronk&eacute;nti beolvas&aacute;ssal, sz&oacute;k&ouml;z&ouml;nk&eacute;nti t&ouml;rdel&eacute;ssel, illetve String eg&eacute;sz sz&aacute;mm&aacute; alak&iacute;t&aacute;s&aacute;val k&ouml;nnyen megoldhat&oacute;. Ha megvannak az adatok, <em>p&eacute;ld&aacute;nyos&iacute;thatjuk a szarvasokat</em>. Ezut&aacute;n nincs m&aacute;s dolgunk, mint 2503-szor lefuttatni <em>minden r&eacute;nszarvas doAction</em> met&oacute;dus&aacute;t, majd megvizsg&aacute;lni, hogy kinek a t&aacute;vols&aacute;ga a legnagyobb. Valahogy &iacute;gy:</p>\r\n<pre><code>import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class ReindeerRace \r\n{\r\n	public static ArrayList Reindeers = new ArrayList();\r\n	\r\n	public static void main (String[] args)\r\n	{\r\n		try \r\n		{\r\n			String fileName = "input14_reindeers.txt";\r\n			getReindeersFromFile(fileName);\r\n			for (int time=1; time&lt;=2503; ++time)\r\n			{\r\n				for (int i=0; i&lt;Reindeers.size(); ++i)\r\n				{\r\n					Reindeers.get(i).doAction();\r\n				}\r\n			}\r\n			&#47;&#47;Print the final distances\r\n			System.out.println(Reindeers);\r\n			\r\n		}\r\n		catch (Exception ex) \r\n		{\r\n			System.out.println("Fatal error: "+ex);\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n	\r\n	public static void getReindeersFromFile(String fileName) throws Exception\r\n	{\r\n		BufferedReader reader = new BufferedReader(new FileReader(fileName));\r\n		String line = reader.readLine();\r\n		while (line!=null)\r\n		{\r\n			String[] arr = line.split(" ");\r\n			String name = arr[0];\r\n			int speed = Integer.parseInt(arr[3]);\r\n			int maxFlyTime = Integer.parseInt(arr[6]);\r\n			int maxRestTime = Integer.parseInt(arr[13]);\r\n			Reindeer deer = new Reindeer(name, speed, maxFlyTime, maxRestTime);\r\n			Reindeers.add(deer);\r\n			line = reader.readLine();\r\n		}\r\n		reader.close();\r\n	}\r\n}\r\n</code></pre>\r\n<p>A futtat&aacute;sr&oacute;l annyit kell tudni, hogy mindk&eacute;t &aacute;llom&aacute;nyt le kell ford&iacute;tani, de csak a ReindeerRace oszt&aacute;lyt lehet futtatni, ugyanis csak annak van main met&oacute;dusa. A Reindeer oszt&aacute;lyt csak felhaszn&aacute;lja f&#337; program. Ha ford&iacute;t&aacute;s ut&aacute;n mapp&aacute;ban van a Reindeer.class &eacute;s a ReindeerRace.class (&eacute;s persze a bemeti f&aacute;jl, a<a href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day14_input.txt" target="_blank"> day14_input.txt</a>), akkor a ReindeerRace-t futtatva m&#369;k&ouml;dik a program. Vagyis:</p>\r\n<pre><code> javac Reindeer.java\r\n javac ReindeerRace.java\r\n java ReindeerRace\r\n</code></pre>\r\n<p>Persze aki valami integr&aacute;lt fejleszt&#337;eszk&ouml;zt (IDE: Pl.: Eclipse, NetBeans) haszn&aacute;l, ann&aacute;l csak arra kell figyelni, hogy egy Projecten bel&uuml;l legyenek a f&aacute;jlok. De &eacute;n most megmutattam az ID&Eacute;tlen v&aacute;ltozatot is.</p>\r\n<p>A m&aacute;sodik feladat eset&eacute;ben minden szarvast pontos a Mikul&aacute;s. Ehhez egy t&aacute;bl&aacute;zatot haszn&aacute;l, ahol mind a 8 szarvas nev&eacute;hez oda&iacute;rja az aktu&aacute;lis pontsz&aacute;m&aacute;t. Ezt a programban egy <strong>Hashtable</strong> objektummal oldottam meg, aminek<em> kulcsai a r&eacute;nszarvasok neve</em>, <em>&eacute;rt&eacute;kei pedig az aktu&aacute;lis pontsz&aacute;mok</em>. A feladat annyi, hogy minden m&aacute;sodpercben (time ciklus) megkeress&uuml;k az <em>&eacute;ppen vezet&#337; szarvas(ok) nev&eacute;t</em> (<strong>getLeadersName</strong>), &eacute;s n&ouml;velj&uuml;k a vezet&#337;(k) pontsz&aacute;m&aacute;nak &eacute;rt&eacute;k&eacute;t a <strong>ReindeerScore</strong> t&aacute;bl&aacute;zatban. Az els&#337; &eacute;s m&aacute;sodik r&eacute;sz &ouml;sszevont k&oacute;dja:</p>\r\n<pre><code>import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class ReindeerRace \r\n{\r\n	public static ArrayList Reindeers = new ArrayList();\r\n	public static Hashtable&lt;String, Integer&gt; ReindeerScore = new Hashtable&lt;String, Integer&gt;();\r\n	\r\n	public static void main (String[] args)\r\n	{\r\n		try \r\n		{\r\n			String fileName = "input14_reindeers.txt";\r\n			getReindeersFromFile(fileName);\r\n			for (int time=1; time&lt;=2503; ++time)\r\n			{\r\n				for (int i=0; i&lt;Reindeers.size(); ++i)\r\n				{\r\n					Reindeers.get(i).doAction();\r\n				}\r\n				ArrayList leadersName = getLeadersName();\r\n				for (int i=0; i&lt;leadersName.size(); ++i)\r\n				{\r\n					int leaderScore = ReindeerScore.get(leadersName.get(i)) + 1;\r\n					ReindeerScore.put(leadersName.get(i), leaderScore);\r\n				}\r\n			}\r\n			&#47;&#47;Print the final distances\r\n			System.out.println(Reindeers);\r\n			&#47;&#47;Print the final scores\r\n			System.out.println(ReindeerScore);\r\n			\r\n		}\r\n		catch (Exception ex) \r\n		{\r\n			System.out.println("Fatal error: "+ex);\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n	\r\n	public static void getReindeersFromFile(String fileName) throws Exception\r\n	{\r\n		BufferedReader reader = new BufferedReader(new FileReader(fileName));\r\n		String line = reader.readLine();\r\n		while (line!=null)\r\n		{\r\n			String[] arr = line.split(" ");\r\n			String name = arr[0];\r\n			int speed = Integer.parseInt(arr[3]);\r\n			int maxFlyTime = Integer.parseInt(arr[6]);\r\n			int maxRestTime = Integer.parseInt(arr[13]);\r\n			Reindeer deer = new Reindeer(name, speed, maxFlyTime, maxRestTime);\r\n			Reindeers.add(deer);\r\n			ReindeerScore.put(name, 0); &#47;&#47;for the second part\r\n			line = reader.readLine();\r\n		}\r\n		reader.close();\r\n	}\r\n	\r\n	public static ArrayList getLeadersName()\r\n	{\r\n		int maxDistance = Reindeers.get(0).getDistance();\r\n		ArrayList leadersName = new ArrayList();\r\n		\r\n		for (int i=0; i&lt;Reindeers.size(); ++i)\r\n		{\r\n			if (Reindeers.get(i).getDistance() == maxDistance) 	&#47;&#47;multiple lead\r\n			{\r\n				leadersName.add(Reindeers.get(i).getName());\r\n			}\r\n			else if (Reindeers.get(i).getDistance() &gt; maxDistance) &#47;&#47;new leader\r\n			{\r\n				maxDistance = Reindeers.get(i).getDistance();\r\n				leadersName.clear();\r\n				leadersName.add(Reindeers.get(i).getName());\r\n			}\r\n		}\r\n		return leadersName;\r\n	}\r\n}\r\n</code></pre>\r\n<p>Egy&eacute;bk&eacute;nt mind a <a href="http:&#47;&#47;pastebin.com/pi8wbBfe" target="_blank">Reindeer</a>, mind a <a href="http:&#47;&#47;pastebin.com/pui9jvvn" target="_blank">ReindeerRace </a>forr&aacute;sk&oacute;dja el&eacute;rhet&#337; Pastebinen is. Aki pedig eddig kitartott, az megn&eacute;zheti a R&eacute;nszarvas Olimpia Javascriptben, HTML canvason szimul&aacute;lt v&aacute;ltozat&aacute;t. A m&#369;k&ouml;d&eacute;si elve hasonl&oacute;, csak a rajzol&aacute;s benne a plusz, de pont ett&#337;l sokkal l&aacute;tv&aacute;nyosabb:</p>\r\n<p><iframe src="http:&#47;&#47;progmatinfo.netii.net/ReindeerRace/index.html" width="800" height="600"> </iframe></p>', '2016-02-16 02:47:17', '2016-02-16 08:18:15'),
(48, 'comsciblog', 'Ruth-Aaron párok tesztelése - dailyprogrammer', 'hu', '<p><strong>A most bemutat&aacute;sra ker&uuml;l&#337; feladv&aacute;ny ism&eacute;t a <a href="https://www.reddit.com/r/dailyprogrammer/comments/3nkanm/20151005_challenge_235_easy_ruthaaron_pairs/" title="Reddit dailyprogrammer" target="_blank" > Reddit dailyprogrammer </a>oldal&aacute;r&oacute;l sz&aacute;rmazik. A feladat: megadott bemenet(ek)r&#337;l eld&ouml;nteni, hogy Ruth-Aaron p&aacute;rok-e. A <a href="http://mathworld.wolfram.com/Ruth-AaronPair.html" title="Ruth-Aaron pairs - Wolfram Mathworld" target="_blank">Ruth-Aaron p&aacute;r </a> a sz&aacute;melm&eacute;letben k&eacute;t olyan egym&aacute;st k&ouml;vet&#337; term&eacute;szetes sz&aacute;m, amelyek pr&iacute;mt&eacute;nyez&#337;i diszjunktak, valamint az egyes sz&aacute;mok pr&iacute;mt&eacute;nyez&#337;inek &ouml;sszege megegyezik. A mai bejegyz&eacute;semben ezt a feladatot oldom meg, a C programoz&aacute;si nyelv seg&iacute;ts&eacute;g&eacute;vel.</strong>&nbsp;<br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/No_image_available.svg/500px-No_image_available.svg.png" alt="No image available... sorry" width="400" height="400" /><br />Sajnos nem tal&aacute;ltam megfelel&#337; illusztr&aacute;ci&oacute;t, &iacute;gy ezzel kell be&eacute;rnetek. A k&eacute;p egy&eacute;bk&eacute;nt a <a title="No image available - Wikimedia" href="https://commons.wikimedia.org/wiki/File:No_image_available.svg" target="_blank">Wikimedia</a>&nbsp;oldalr&oacute;l sz&aacute;rmazik.</p>\n<p>Vagyis a <span style="text-decoration: underline;">bemenet</span>: $n$, amely a bemen&#337; sz&aacute;mp&aacute;rok sz&aacute;ma, valamint $n$ darab sz&aacute;mp&aacute;r. Hasonl&oacute;an az <a href="http://comsciblog.esy.es/article/47/Leghosszabb+le%C3%ADrhat%C3%B3+sz%C3%B3%2C+elromlott+billenty%C5%B1zettel+-+dailyprogrammer" target="_blank">el&#337;z&#337; bejegyz&eacute;shez</a>, itt is <em>t&ouml;bb bemenetre kell m&#369;k&ouml;dnie</em> a programnak. Ebben az esetben azonban parancssori argumentumok helyett a felhaszn&aacute;l&oacute;t&oacute;l k&eacute;rem be a bemenetet a program fut&aacute;sa k&ouml;zben. Az elv azonban ugyanaz: ugyanazt a tesztel&eacute;st v&eacute;gzi a program mind az $n$ inputon.</p>\n<h3><span style="text-decoration: underline;"><strong>De hogyan d&ouml;nts&uuml;k el, hogy egy adott sz&aacute;mp&aacute;r Ruth-Aaron p&aacute;r-e?</strong></span></h3>\n<p>Amint azt m&aacute;r a bevezet&eacute;sben le&iacute;rtam, ahhoz, hogy egy sz&aacute;mp&aacute;r Ruth-Aaron p&aacute;r legyen, 3 felt&eacute;telnek kell teljes&uuml;lnie.</p>\n<ol>\n<li>&nbsp;Szomsz&eacute;dosak legyenek. Vagyis $(a, b)$ sz&aacute;mp&aacute;r eset&eacute;n $a=b+1$ vagy $b=a+1$.</li>\n<li>Pr&iacute;mfaktoriz&aacute;ci&oacute;juk diszjunkt, vagyis nincs k&ouml;z&ouml;s pr&iacute;moszt&oacute;juk. A pr&iacute;mfelbont&aacute;sr&oacute;l m&aacute;r volt sz&oacute; a <a href="http://comsciblog.esy.es/article/36/Project+Euler+3+-+Pr%C3%ADmfelbont%C3%A1s%2C+legnagyobb+pr%C3%ADm+oszt%C3%B3"> Project Euler 3. feladat&aacute;r</a> &oacute;l sz&oacute;l&oacute; bejegyz&eacute;semben. Vagyis fel kell bontanunk a sz&aacute;mokat pr&iacute;mt&eacute;nyez&#337;kre, &eacute;s ellen&#337;rizni, hogy van-e k&ouml;z&ouml;s r&eacute;sz&uuml;k.</li>\n<li>&nbsp;Pr&iacute;mt&eacute;nyez&#337;ik &ouml;sszege megegyezik. Vagyis ugyan&uacute;gy pr&iacute;mt&eacute;nyez&#337;kre bont&aacute;s, &eacute;s &ouml;sszegz&eacute;s.</li>\n</ol>\n<p>A meg&iacute;rt programom forr&aacute;sk&oacute;dja:</p>\n<pre><code>int main(int argc, char ** argv)\n{\n    int count, first, second, k, prime, sum1, sum2, disjoint;\n    printf("count: ");\n    scanf("%d", &amp;count);\n    for (k=0; k&lt;count; ++k) /*k input count*/\n    {\n        printf("\\n\\n%d. pair: \\nFirst number: ", k+1);\n        scanf("%d", &amp;first);\n        printf("Second number: ");\n        scanf("%d", &amp;second);\n\n        if (first+1 != second &amp;&amp; second+1 != first) /*if not consecutive integers*/\n        {\n            printf("NOT VALID\\n");\n            continue;\n        }\n       disjoint = 1;\n       prime = 2;\n       sum1 = 0;\n       sum2 = 0;\n       /*first number prime factorization (and sum the dividers)*/\n       while (first &gt; 1 &amp;&amp; disjoint)\n       {\n            while (first%prime == 0 &amp;&amp; disjoint)\n            {\n                first/=prime;\n                sum1+=prime;\n                if (second%prime == 0) /*if they not disjoint*/\n                {\n                    disjoint = 0;\n                    printf("NOT VALID\\n");\n                }\n            }\n            ++prime;\n       }\n       if (disjoint)\n       {\n            /*second number prime factorization (to sum the dividers)*/\n            prime = 2;\n            while (second &gt; 1 &amp;&amp; sum1 &gt; sum2)\n            {\n                while (second%prime==0)\n                {\n                    second/=prime;\n                    sum2+=prime;\n                }\n                ++prime;\n            }\n\n            if (sum1 == sum2)\n                printf("VALID\\n");\n            else\n                printf("NOT VALID\\n");\n       }\n       else\n            printf("NOT VALID\\n");\n    }\n    return 0;\n}\n</code></pre>\n<p>A program bek&eacute;ri a bemenetek sz&aacute;m&aacute;t ($n$), majd egy<em> $k$ index&#369; ciklus $n$-szer</em>&nbsp;fut le, bek&eacute;ri a $k.$ sz&aacute;mp&aacute;rt. <br />Az szomsz&eacute;doss&aacute;got k&ouml;nny&#369; ellen&#337;rizni: <em>Ha egyik sem pontosan eggyel nagyobb a m&aacute;sikn&aacute;l</em>, akkor nem szomsz&eacute;dosak, teh&aacute;t biztosan nem lehetnek Ruth-Aaron p&aacute;r (13. sor, if felt&eacute;tel). Vagyis a <strong>continue</strong> ugr&oacute; utas&iacute;t&aacute;s seg&iacute;ts&eacute;g&eacute;vel el&#337;r&ouml;l kezdhetj&uuml;k a ciklust, a $k:=k+1$ l&eacute;p&eacute;st&#337;l.</p>\n<p><br /><em>Ha nem ugrottunk ki</em>, az azt jelenti, hogy <em>szomsz&eacute;dosak</em>. Ekkor a <a title="Sz&aacute;melm&eacute;let alapt&eacute;tele - Wikip&eacute;dia" href="https://hu.wikipedia.org/wiki/A_sz%C3%A1melm%C3%A9let_alapt%C3%A9tele" target="_blank">sz&aacute;melm&eacute;let alapt&eacute;tele</a> szerint (b&#337;vebben l&aacute;sd:<a title=" Project Euler 3 - Pr&iacute;mfelbont&aacute;s, legnagyobb pr&iacute;m oszt&oacute;" href="http://comsciblog.esy.es/article/36/Project+Euler+3+-+Pr%C3%ADmfelbont%C3%A1s%2C+legnagyobb+pr%C3%ADm+oszt%C3%B3" target="_blank"> Project Euler 3</a>) felbontjuk az egyik sz&aacute;mot pr&iacute;mt&eacute;nyez&#337;kre (23. sor, <strong>while</strong> ciklus). A pr&iacute;mt&eacute;nyez&#337;ket pedig &ouml;sszegezz&uuml;k (28. sor). Mindek&ouml;zben figyelj&uuml;k, nehogy valamely pr&iacute;mt&eacute;nyez&#337; oszt&oacute;ja legyen a m&aacute;sik sz&aacute;mnak (29. sor, <strong>if</strong> felt&eacute;tel). Ha ez megt&ouml;rt&eacute;nne, <em>nem diszjunktak, teh&aacute;t biztosan nem Ruth-Aaron p&aacute;r</em>. Bukta!<br />Ha viszont nincs bukta, vagyis diszjunktak a pr&iacute;mt&eacute;nyez&#337;k (37. sor), nincs m&aacute;s dolgunk, mint a m&aacute;sik sz&aacute;mot is felbontani, &eacute;s &ouml;sszegezni az &#337; pr&iacute;mt&eacute;nyez&#337;it is (41. sort&oacute;l). Ha a k&eacute;t &ouml;sszeg megegyezik,<em> Ruth-Aaron p&aacute;rt tal&aacute;ltunk</em>, egy&eacute;bk&eacute;nt nem.</p>\n<h3><span style="text-decoration: underline;"><strong>Megjegyz&eacute;s:</strong></span></h3>\n<p>El&#337;fordulhat, hogy valakinek ez nem el&eacute;gg&eacute; &aacute;ttekinthet&#337;, mivel az els&#337; pr&iacute;mt&eacute;nyez&#337;k &ouml;sszegz&eacute;se &eacute;s a diszjunkts&aacute;g vizsg&aacute;lata nem k&uuml;l&ouml;n&uuml;l el teljesen. Ez&eacute;rt az is megtehet&#337;, hogy az pr&iacute;mt&eacute;nyez&#337;k keres&eacute;sekor az &ouml;sszegzend&#337; pr&iacute;mt&eacute;nyez&#337;ket t&aacute;roljuk valamilyen adatszerkezetben (tipikusan j&oacute; ilyesmire egy <a title=" Objektumorient&aacute;lt C++ - Halmaz oszt&aacute;ly" href="http://comsciblog.esy.es/article/45/Objektumorient%C3%A1lt+C%2B%2B+-+Halmaz+oszt%C3%A1ly" target="_blank">Halmaz oszt&aacute;ly</a>), &eacute;s a k&eacute;t pr&iacute;mhalmazr&oacute;l/pr&iacute;mlist&aacute;r&oacute;l eld&ouml;ntj&uuml;k, hogy tartalmaznak-e k&ouml;z&ouml;s elemet. <br />A fent k&ouml;z&ouml;lt megold&aacute;shoz ilyesmire nincs sz&uuml;ks&eacute;g, ez&eacute;rt (valamivel) kevesebb mem&oacute;ri&aacute;ra van sz&uuml;ks&eacute;ge, &eacute;s n&eacute;mileg kevesebb a m&#369;veletig&eacute;nye is.</p>\n<p>&nbsp;</p>', '2015-11-11 10:18:46', '2015-11-11 10:36:53'),
(49, 'comsciblog', 'Project Euler 14 - Collatz-sorozatok', 'hu', '<p><strong>Az mai bejegyz&eacute;sben ism&eacute;t egy Project Euler probl&eacute;m&aacute;val foglalkozom, eg&eacute;sz pontosan a <a href="https://projecteuler.net/problem=14" target="_blank">14. feladattal</a>. A feladatban sorozatokat kell k&eacute;pezni megadott kezd&#337;pontokt&oacute;l egy egyszer&#369; szab&aacute;ly szerint: &uacute;gynevezett Collatz-sorozatokat. Ezek a sorozatok k&ouml;nnyen el&#337;&aacute;ll&iacute;that&oacute;k, ugyanakkor m&aacute;ig megoldatlan matematikai probl&eacute;ma (a <a href="https://hu.wikipedia.org/wiki/Collatz-sejt%C3%A9s" target="_blank"> Collatz-sejt&eacute;s</a>), hogy van-e olyan kezd&#337;pont, amelyre m&aacute;r megadott tag ut&aacute;n nem v&aacute;lik periodikuss&aacute; a sorozat. Nek&uuml;nk azonban szerencs&eacute;re nem ezt kell bel&aacute;tni vagy c&aacute;folni, mind&ouml;ssze a meg kell keresn&uuml;nk azt az 1000000 alatti sz&aacute;mot, amelyt&#337;l ind&iacute;tva ez a sorozat a lehet&#337; leghosszabb ideig nem kezd el &bdquo;cikliz&aacute;lni&rdquo;.</strong></p>\n<p>A pontos&iacute;t&aacute;s kedv&eacute;&eacute;rt: A Collatz-sorozat olyan sorozat, amely tetsz&#337;leges $a_0$ kezd&#337;pontb&oacute;l indul, &eacute;s az $n.$ tagot a k&ouml;vetkez&#337; &ouml;sszef&uuml;gg&eacute;s adja meg:</p>\n<p><img class="img-responsive" src="http://comsciblog.esy.es/img/Collatz.png" alt="" width="281" height="60" /></p>\n<p>Vagyis p&aacute;ros tag eset&eacute;n a k&ouml;vetkez&#337; tagot az el&#337;tte lev&#337; megfelez&eacute;s&eacute;vel kapjuk, p&aacute;ratlan eset&eacute;n pedig a h&aacute;romszoros&aacute;t eggyel megn&ouml;velve. P&aacute;ratlan sz&aacute;mot teh&aacute;t mindig p&aacute;ros k&ouml;vet. A sejt&eacute;s azt &aacute;ll&iacute;tja, hogy<em> b&aacute;rmely $a_0 \\in \\mathbb{N}$ kezd&#337;pont esetl&eacute;n lesz olyan $n$, hogy az $n.$ tag 1</em>, vagyis $a_n = 1$. M&aacute;sk&eacute;ppen fogalmazva: <span style="text-decoration: underline;">n-t&#337;l kezd&#337;d&#337;en a sorozat ciklikus</span>, ugyanis, az eggyel kezd&#337;d&#337; sorozat: $ 1 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow &hellip; $, vagyis egy h&aacute;rom k&uuml;l&ouml;nb&ouml;z&#337; &eacute;rt&eacute;k&#369; tagb&oacute;l &aacute;ll&oacute;, ism&eacute;tl&#337;d&#337; sorozat.<br /><br /></p>\n<p><span style="text-decoration: underline;">A feladatunk:</span> Minden 1 &eacute;s 1000000 k&ouml;z&ouml;tti eg&eacute;sz $a_0$ kezd&#337;ponthoz kisz&aacute;molni a sorozat &bdquo;nem ism&eacute;tl&#337;d&#337; r&eacute;sz&eacute;nek&rdquo; hossz&aacute;t, vagyis hogy mennyi elem van azel&#337;tt az $n.$ tag el&#337;tt, amelyre $a_n = 1$. A k&eacute;rd&eacute;s pedig annak az $a_0$ kezd&#337;pontnak a megtal&aacute;l&aacute;sa, amelyre ez az &eacute;rt&eacute;k a legnagyobb. (A tov&aacute;bbiakban ezt az &eacute;rt&eacute;ket az egyszer&#369;s&eacute;g kedv&eacute;&eacute;rt <em>Collatz-sz&aacute;m</em>nak h&iacute;vom.)</p>\n<p>Vagyis ki kell sz&aacute;molni minden 1000000 alatti kezd&#337;pontra a sorozat tagjait, am&iacute;g valamelyik tag nem lesz egyenl&#337; eggyel. A sejt&eacute;s szerint minden kezd&#337;pont eset&eacute;n el&#337;bb-ut&oacute;bb lesz olyan tag, aminek &eacute;rt&eacute;ke egy. De mi van, ha a sejt&eacute;s nem igaz? A gyakorlatban az sem jelent nek&uuml;nk gondot, mivel a Wiki&eacute;pdia szerint a sejt&eacute;st m&aacute;r minden $n \\leq 5\\cdot 2^{60}$ kezd&#337;sz&aacute;mra igazolt&aacute;k, teh&aacute;t (ha mindent j&oacute;l csin&aacute;lunk) nem kell f&eacute;ln&uuml;nk a v&eacute;gtelen ciklust&oacute;l.</p>\n<p>A feladatot megold&oacute; C program k&oacute;dja:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define LIMIT 1000000\n\nlong long int Collatz(long long int);\n\nint main(int argc, char ** argv)\n{\n    long long int i, max_value=0, max_number=0;\n    /** LIMIT alatti leghosszabb Collatz-sorozat hossza */\n    for (i=1; i&lt;LIMIT; ++i)\n    {\n        if (Collatz(i)&gt;max_value)\n        {\n            max_value=Collatz(i);\n            max_number = i;\n        }\n    }\n    printf("%llu adja leghosszabb, %llu hosszu sorozatot.\\n",max_number, max_value);\n    return 0;\n}\n\n/** Visszaadja a megadott szamtol indulo Collatz-sorozat hosszat */\nlong long int Collatz(long long int number)\n{\n    long long int length=1;\n    while (number!=1)\n    {\n        if (number&amp;1)\n            number=3*number+1;\n        else \n            number&gt;&gt;=1;\n        ++length;\n    }\n  return length;\n}\n</code></pre>\n<p>A program main f&uuml;ggv&eacute;nye gyakorlatilag egy sz&aacute;ml&aacute;l&oacute; ciklus (<strong>for</strong>), &eacute;s egy <em>maximum kiv&aacute;laszt&aacute;s</em>. Kiv&aacute;lasztja, hogy a megadott sz&aacute;mok k&ouml;z&uuml;l melyikek a legnagyobb a &bdquo;<em>Collatz-sz&aacute;ma</em>&rdquo;. A <strong>Collatz</strong> nev&#369; f&uuml;ggv&eacute;ny pedig ezt a sz&aacute;mot adja vissza a param&eacute;terben megadott kezd&#337;pontra.</p>\n<p>A program kevesebb, mint egy m&aacute;sodperc alatt lefutott a g&eacute;pemen, azonban <span style="text-decoration: line-through;">vagyok annyira vaddiszn&oacute;, hogy</span> m&eacute;g szeretn&eacute;m<em> gyors&iacute;tani az algoritmust</em>.<span style="text-decoration: underline;"> Gyors&iacute;t&aacute;si lehet&#337;s&eacute;g:</span> amelyik sz&aacute;mnak m&aacute;r egyszer kisz&aacute;moltuk a &bdquo;<em>Collatz-sz&aacute;m&aacute;t</em>&rdquo;, <strong>azt t&aacute;roljuk el</strong>, hogy k&eacute;s&#337;bbiekben felhaszn&aacute;lhassuk. (J&oacute; &ouml;tletek&eacute;rt egy&eacute;bk&eacute;nt &eacute;rdemes a <a title="Mathblog.dk - Project Euler 14" href="https://projecteuler.net/problem=14" target="_blank">mathblog.dk</a> blogot olvasni). Vagyis t&aacute;roljuk el a m&aacute;r kisz&aacute;molt &bdquo;Collatz-sz&aacute;mokat&rdquo; egy t&ouml;mbben. Ha egy feladat sor&aacute;n olyan sz&aacute;mhoz &eacute;rt&uuml;nk, aminek m&aacute;r kisz&aacute;moltuk a Collatz-&eacute;rt&eacute;k&eacute;t, akkor &uacute;jb&oacute;li kisz&aacute;mol&aacute;s helyett egyszer&#369;en olvassuk ki a megfelel&#337; &eacute;rt&eacute;ket. <br />P&eacute;ld&aacute;ul a <span style="font-family: &apos;Trebuchet MS&apos;, sans-serif;"><span style="font-size: medium;">13 &rarr; 40 &rarr; 20 &rarr; 10 &rarr; 5 &rarr; 16 &rarr; 8 &rarr; 4 &rarr; 2 &rarr; 1</span></span> sorozatban <em>10 ut&aacute;n m&aacute;r felesleges sz&aacute;molnunk</em>, mivel az $i=13$ el&#337;tti ciklusok sor&aacute;n m&aacute;r kisz&aacute;moltuk 10 Collatz-sz&aacute;m&aacute;t, ami 7, a t&iacute;zesig vezet&#337; &uacute;t hossza pedig 3, &iacute;gy a 13 Collatz sz&aacute;ma 10. Megspr&oacute;roltunk 7 iter&aacute;ci&oacute;t.</p>\n<p><br />&Iacute;gy ugyan valamivel t&ouml;bb mem&oacute;ri&aacute;ra van sz&uuml;ks&eacute;g, viszont j&oacute;val kevesebb m&#369;veletre. A m&oacute;dos&iacute;tott <strong>Collatz</strong> f&uuml;ggv&eacute;ny:</p>\n<pre><code>long long int Collatz(long long int number)\n{\n    long long int length=1, start_number = number;\n    while (number!=1)\n    {\n        if (number&amp;1)\n            number=3*number+1;\n        else \n            number&gt;&gt;=1;\n        	             \n        if (number&lt;LIMIT &amp;&amp; cache[number]!=0)\n        {\n    	  cache[start_number] = cache[number]+length;\n 	return cache[start_number];\n    	}\n    	++length;  \n  }\n  cache[start_number] = length;\n  return length;\n}\n</code></pre>\n<p>Itt a <strong>cache</strong> t&ouml;mb egy <strong>LIMIT+1</strong> m&eacute;ret&#369; glob&aacute;lis t&ouml;mb, amelynek minden eleme a <em>0 kezd&#337;&eacute;rt&eacute;ket</em> kapja.&nbsp;Ha a f&uuml;ggv&eacute;ny fut&aacute;sa sor&aacute;n a t&ouml;mb megfelel&#337; &eacute;rt&eacute;ke <em>nem nulla</em>, az azt jelenti, hogy <em>m&aacute;r kisz&aacute;moltuk</em> a megfelel&#337; &eacute;rt&eacute;ket. Vagyis a program visszat&eacute;rhet az eddig sz&aacute;molt hossz &eacute;s a jelenlegi &bdquo;<em>Collatz-sz&aacute;m</em>&rdquo; &ouml;sszeg&eacute;vel.</p>\n<p>Ez az apr&oacute;cska tr&uuml;kk <span style="text-decoration: underline;">sokat jav&iacute;t</span> az algoritmuson: ha a <strong>LIMIT</strong>-et 1 helyett 10 milli&oacute;ra &aacute;ll&iacute;tjuk (vagyis a 10000000 alatti sz&aacute;mok k&ouml;z&uuml;l keress&uuml;k a legnagyobb &bdquo;<em>Collatz-&eacute;rt&eacute;k&#369;t</em>&rdquo;), akkor a cachel&eacute;s n&eacute;lk&uuml;li (n&aacute;lam) t&ouml;bb, mint 11 m&aacute;sodpercet ig&eacute;nyel, m&iacute;g a gyors&iacute;tott m&eacute;g mindig 1 m&aacute;sodpercen bel&uuml;l lefut. Amennyiben a LIMIT 100 milli&oacute;, &uacute;gy a gyors&iacute;tott program m&eacute;rt fut&aacute;sideje nagyj&aacute;b&oacute;l 20 m&aacute;sodperc, m&iacute;g a gyors&iacute;tatlan 2 perc 14 m&aacute;sodpercig futott.</p>\n<p>&nbsp;</p>', '2015-11-25 07:05:53', '2015-11-25 07:20:50'),
(54, 'comsciblog', 'Advent of Code - 1-3. napi feladatok', 'hu', '<p><strong>A mostani bejegyz&eacute;sben&nbsp;egy nagyon is aktu&aacute;lis feladatsorozatr&oacute;l, az <a title="Advent of Code programming challenge" href="http:&#47;&#47;adventofcode.com" target="_blank">Advent of Code </a>nev&#369; remek Internetes kih&iacute;v&aacute;st aj&aacute;nlok kezd&#337;knek &eacute;s halad&oacute;knak is. A feladatokat az advent &uuml;nnepe k&ouml;r&eacute; &eacute;p&iacute;tett&eacute;k, a feladatok sz&ouml;vegez&eacute;s&eacute;ben visszat&eacute;r&#337; elem a Mikul&aacute;s, a man&oacute;k, aj&aacute;nd&eacute;koz&aacute;s, r&eacute;nszarvasok. Minden napra k&eacute;t feladatot k&iacute;n&aacute;l megold&aacute;sra, egy-egy csillag jutalom&eacute;rt. Ha elk&eacute;sz&uuml;ltek a feladatok, a kar&aacute;csonyfa adott szintje kiz&ouml;ld&uuml;l, illetve felragyognak a d&iacute;szek.</strong> <br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/ascii_christmas_tree.png" alt="Kar&aacute;csonyfa ASCII karakterekb&#337;l" width="350" height="362" /><br />A kar&aacute;csonyfa kezdei &aacute;llapota. A k&eacute;p forr&aacute;sa: <a title="Advent of Code" href="https:&#47;&#47;cptjackowski.wordpress.com/2015/12/02/advent-of-code/" target="_blank">cptjakowski.wordpress.com</a></p>\r\n<p>Ez a bejegyz&eacute;s kiss&eacute; elt&eacute;r az el&#337;z&#337;ekt&#337;l. Ugyanis most a feladat megold&aacute;sa helyett mind&ouml;ssze a probl&eacute;m&aacute;t &iacute;rom le. &nbsp;Ennek k&eacute;t oka is van: egyr&eacute;szt szeretn&eacute;m meg&#337;rzini a feladatokat, ha valamilyen okn&aacute;l fogva (pl.: v&eacute;ge a kar&aacute;csonynak) leker&uuml;lne a webr&#337;l e csod&aacute;s oldal. M&aacute;sr&eacute;szr&#337;l lehet&#337;s&eacute;get adok annak is gondolkodni, aki valamif&eacute;le <span style="text-decoration: line-through;">kar&aacute;csonyi</span>&nbsp;csoda folyt&aacute;n ide vet&#337;dik, &eacute;s e sorokat olvassa. Akkor teh&aacute;t a feladatok:</p>\r\n<h3>1. nap</h3>\r\n<p>A Mikul&aacute;s egy &oacute;ri&aacute;si lak&oacute;&eacute;p&uuml;letben pr&oacute;b&aacute;lja az aj&aacute;nd&eacute;kokat sz&eacute;tosztani a lak&oacute;k k&ouml;z&ouml;tt, de sohasem tal&aacute;lja meg a megfelel&#337; emeletet. A f&ouml;ldszintr&#337;l indul (0. szint), &eacute;s a k&ouml;vetkez&#337; utas&iacute;t&aacute;sokat k&ouml;veti: Nyit&oacute; z&aacute;r&oacute;jel <strong>&apos;(&apos;</strong> eset&eacute;n felfel&eacute; kell mennie egy emeletet, z&aacute;r&oacute; <strong>&apos;)&apos;</strong> eset&eacute;n pedig lefel&eacute;. Az &eacute;p&uuml;let v&eacute;gtelen&uuml;l magas, &eacute;s az alagsor v&eacute;gtelen&uuml;l m&eacute;ly, teh&aacute;t sohasem &eacute;r a legfels&#337;/legals&oacute; szintre. <br />P&eacute;ld&aacute;ul a <strong>"))((((("</strong> utas&iacute;t&aacute;s elv&eacute;gz&eacute;se ut&aacute;n a Mikul&aacute;s (a f&ouml;ldszintr&#337;l indulva) a 3. szintre, m&iacute;g a <strong>")())())"</strong> elv&eacute;gz&eacute;se ut&aacute;n a -3. szintre &eacute;r.</p>\r\n<p><span style="text-decoration: underline;">1. K&eacute;rd&eacute;s:</span> H&aacute;nyadik szintre &eacute;r a Mikul&aacute;s b&aacute;csi az utas&iacute;t&aacute;sok v&eacute;grehajt&aacute;sa ut&aacute;n?</p>\r\n<p><span style="text-decoration: underline;">2. K&eacute;rd&eacute;s:</span> Melyik az az els&#337; poz&iacute;ci&oacute;, amely ut&aacute;n a Mikul&aacute;s b&aacute;csi az els&#337; alagsori szintre &eacute;r? Vagyis h&aacute;ny l&eacute;p&eacute;s ut&aacute;n ker&uuml;l a -1. szintre?</p>\r\n<h3>2. nap</h3>\r\n<p><span style="text-decoration: underline;">1. k&eacute;rd&eacute;s:</span> A man&oacute;knak fogyt&aacute;n a csomagol&oacute;pap&iacute;rjuk, ez&eacute;rt &uacute;j adagot kell rendelni&uuml;k. Szerencs&eacute;re el&#337;re fel&iacute;rt&aacute;k minden csomagoland&oacute; doboz hossz&aacute;t (l), sz&eacute;less&eacute;g&eacute;t (w) &eacute;s magass&aacute;g&aacute;t (h), &iacute;gy pontosan tudj&aacute;k, mennyit kell rendelni&uuml;k. Mivel minden aj&aacute;nd&eacute;k doboza t&eacute;glatest alak&uacute;, ez&eacute;rt k&ouml;nnyen kisz&aacute;molhat&oacute; a csomagok fel&uuml;lete: $2 \\cdot l \\cdot w+2 \\cdot w \\cdot h+2 \\cdot h \\cdot l$. Ezen k&iacute;v&uuml;l m&eacute;g extra csomagol&oacute;pap&iacute;rra van sz&uuml;ks&eacute;g&uuml;k a hajt&aacute;sokhoz: a legkisebb ter&uuml;let&#369; oldal ter&uuml;let&eacute;re.</p>\r\n<p>P&eacute;ld&aacute;ul egy $2 \\cdot 3 \\cdot 4$ m&eacute;ret&#369; csomag eset&eacute;n $2 \\cdot 6+2 \\cdot 12+2 \\cdot 8$ dm<sup>2</sup> csomagl&oacute;pap&iacute;rra van sz&uuml;ks&eacute;g&uuml;k, plusz 6 dm<sup>2</sup>-re a hajt&aacute;shoz, &ouml;sszesen teh&aacute;t 58 dm<sup>2</sup>-re.<br />A k&eacute;rd&eacute;s, hogy mennyi dm<sup>2</sup> csomagol&oacute;pap&iacute;rt rendeljenek.</p>\r\n<p><span style="text-decoration: underline;">2. k&eacute;rd&eacute;s:</span> A man&oacute;k a szalagb&oacute;l is kifogytak. A szalag sz&eacute;less&eacute;ge adott, csak a rendelni k&iacute;v&aacute;nt szalag hossz&aacute;val kell t&ouml;r&#337;dni&uuml;k. Egy aj&aacute;nd&eacute;kon l&eacute;v&#337; szalag hossz&aacute;nak a doboz legkisebb ker&uuml;let&#369; oldal&aacute;nak ker&uuml;lete, ami ment&eacute;n k&ouml;rbetekerik a csomagon. Ezen k&iacute;v&uuml;l minden csomagra kell egy masni szalagb&oacute;l, aminek hossza megegyezik annak a doboznak a t&eacute;rfogat&aacute;val, amire r&aacute;teszik. Ne akard tudni, hogy a man&oacute;k hogy k&ouml;tik a masnit: ez man&oacute;titok, amit sohasem fognak elmondani.</p>\r\n<p>P&eacute;ld&aacute;ul egy $2 \\cdot 3 \\cdot 4$-es csomag &aacute;tk&ouml;t&eacute;s&eacute;hez $2+2+3+3 = 10 $ dm szalagra van sz&uuml;ks&eacute;g, plusz $2 \\cdot 3 \\cdot 4 = 24$ dm szalag kell a masnihoz, vagyis &ouml;sszesen 34 dm kell ehhez a csomaghoz. A k&eacute;rd&eacute;s, hogy az &ouml;sszes csomaghoz mennyi&nbsp;dm szalagot rendeljenek.</p>\r\n<h3>3. nap</h3>\r\n<p>A Mikul&aacute;s egy v&eacute;gtelenszer-v&eacute;gtelen m&eacute;ret&#369;, 2 dimenzi&oacute;s n&eacute;gyzetr&aacute;cson sz&aacute;ll&iacute;t aj&aacute;nd&eacute;kokat. A r&aacute;cs csom&oacute;pontjai a h&aacute;zak, ahov&aacute; aj&aacute;nd&eacute;kot sz&aacute;ll&iacute;t.</p>\r\n<p><span style="text-decoration: underline;">1. k&eacute;rd&eacute;s:</span> Elindul egy kezdeti poz&iacute;ci&oacute;b&oacute;l (ledobj&aacute;k a sz&aacute;nk&oacute;r&oacute;l), majd egy man&oacute; az &Eacute;szaki Sarkr&oacute;l r&aacute;di&oacute; ad&oacute;-vev&#337;n mondja dikt&aacute;lja neki az &uacute;tvonalat: &Eacute;szak: (<strong>^</strong>), D&eacute;l (<strong>v</strong>), Kelet (<strong>&gt;</strong>) vagy nyugat (<strong>&lt;</strong>). Minden l&eacute;p&eacute;s ut&aacute;n egy-egy &uacute;jabb aj&aacute;nd&eacute;kkal gazdag&iacute;tja az adott helyen l&eacute;v&#337; h&aacute;z lak&oacute;it.<br />Viszont a man&oacute; az &Eacute;szaki Sarkon t&uacute;l sok toj&aacute;slik&#337;rt ivott, ez&eacute;rt kiss&eacute; pontatlanok az instrukci&oacute;i, ez&eacute;rt a Mikul&aacute;sb&aacute;csi n&eacute;h&aacute;ny h&aacute;zat t&ouml;bbsz&ouml;r is megl&aacute;togat.</p>\r\n<p>P&eacute;ld&aacute;ul <strong>"&gt;"</strong> utas&iacute;t&aacute;s eset&eacute;n 2 h&aacute;zhoz visz 1-1 aj&aacute;nd&eacute;kot. <strong>"^&gt;v&lt;"</strong> esetben 4 h&aacute;zhoz sz&aacute;ll&iacute;t aj&aacute;nd&eacute;kot, a kezdeti poz&iacute;ci&oacute; lak&oacute;i k&eacute;tszer is kapnak. A <strong>"^v^v^v^v^v"</strong> utas&iacute;t&aacute;s hat&aacute;s&aacute;ra mind&ouml;ssze 2 h&aacute;zban lak&oacute; gyerekek kapnak sok-sok aj&aacute;nd&eacute;kot. A k&eacute;rd&eacute;s: H&aacute;ny h&aacute;zhoz kap legal&aacute;bb egy aj&aacute;nd&eacute;kot?</p>\r\n<p><span style="text-decoration: underline;">2. k&eacute;rd&eacute;s:</span> J&ouml;v&#337; &eacute;vben a folyamat felgyors&iacute;t&aacute;s&aacute;ra a Mikul&aacute;s b&aacute;csi l&eacute;trehozza saj&aacute;t m&aacute;solat&aacute;t, a Robotmikul&aacute;st, akivel egy&uuml;tt indul &uacute;tnak. Ugyanarr&oacute;l a helyr&#337;l indulnak, majd aszerint az utas&iacute;t&aacute;sok szerint folytatj&aacute;k &uacute;tjukat, amit isz&aacute;kos man&oacute;nk az el&#337;z&#337; &eacute;vben le&iacute;rt. El&#337;sz&ouml;r a Mikul&aacute;s l&eacute;p, majd a k&ouml;vetkez&#337; utas&iacute;t&aacute;s a Robotmikul&aacute;s&eacute;.</p>\r\n<p>P&eacute;ld&aacute;ul <strong>"^v"</strong> l&eacute;p&eacute;ssorozattal 3 h&aacute;zat l&aacute;togatnak meg, mivel a Mikul&aacute;s megy &eacute;szakra, a Robotmikul&aacute;s pedig d&eacute;lre. A<strong>"^&gt;v&lt;"</strong> utas&iacute;t&aacute;s ut&aacute;n 3 h&aacute;zat l&aacute;togatnak meg, &eacute;s a v&eacute;g&eacute;n a Mikul&aacute;s &eacute;s a Robotmikul&aacute;s tal&aacute;lkozik. A <strong>"^v^v^v^v^v"</strong> &nbsp;pedig &iacute;gy m&aacute;r 11 h&aacute;zat l&aacute;togat meg, mivel eszerint a Mikul&aacute;s mindig &eacute;szakra megy, a Robotmikul&aacute;s pedig mindig d&eacute;lre. A k&eacute;rd&eacute;s ugyanaz: H&aacute;ny h&aacute;zhoz kap legal&aacute;bb egy aj&aacute;nd&eacute;kot?<br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/santa_elves.gif" alt="T&eacute;lap&oacute; man&oacute;i m&aacute;r k&eacute;sz&uuml;l&#337;dnek" width="500" height="199" /><small>A T&eacute;lap&oacute; man&oacute;i m&aacute;r k&eacute;sz&uuml;l&#337;dnek. A k&eacute;p forr&aacute;sa: <a title="Valamif&eacute;le &aacute;ltal&aacute;nos iskola weboldala" href="http:&#47;&#47;www.midlothian-isd.net/~melodi_kunn/?OpenItemURL=S05617DE5" target="_blank">http:&#47;&#47;www.midlothian-isd.net/</a>&nbsp;(egy&eacute;bk&eacute;nt <a title="Google K&eacute;pek" href="https:&#47;&#47;www.google.hu/imghp?hl=hu&amp;tab=wi&amp;ei=MHtwVp_bMabnygOM2ZKICA&amp;ved=0EKouCBAoAQ" target="_blank">Google k&eacute;pkeres&eacute;s</a>, csak&uacute;gy, mint a legt&ouml;bb.)</small></p>\r\n<p>Rem&eacute;lem mindenkinek legal&aacute;bb annyira tetszenek a feladv&aacute;nyok, mint nekem. Fel fogom t&ouml;lteni a megold&aacute;saikat is, valamint a t&ouml;bbi feladatot is igyekszem lementeni, de mindenekel&#337;tt megoldani &#337;ket, ugyanis egy kis lemarad&aacute;sban vagyok n&eacute;h&aacute;nnyal. Mindenkinek kellemes id&#337;t&ouml;lt&eacute;st, &eacute;s boldog &uuml;nnepeket!</p>\r\n<p><small><span style="text-decoration: underline;">Megyjegyz&eacute;s:</span> A 2. feladatn&aacute;l <a title="Advent of Code - Day 2" href="http:&#47;&#47;adventofcode.com/day/2" target="_blank">az eredeti feladatban</a> a dm helyett l&aacute;b (feet) m&eacute;rt&eacute;kegys&eacute;g van, nekem azonban k&ouml;zelebb &aacute;ll a sz&iacute;vemhez az SI m&eacute;rt&eacute;kegys&eacute;grendszer, ez&eacute;rt kisebbre vettem a dobozok m&eacute;ret&eacute;t: eln&eacute;z&eacute;st a man&oacute;kt&oacute;l.</small></p>', '2015-12-15 09:11:42', '2015-12-15 09:44:18');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(55, 'comsciblog', 'Advent of Code - 1-3. feladatok megoldásai', 'hu', '<p><strong>Ebben a bejegyz&eacute;sben az Advent of Code els&#337; h&aacute;rom feladat&aacute;nak megold&aacute;sait &iacute;rom le. A megold&aacute;sokhoz a b&ouml;ng&eacute;sz&#337;k webkonzolj&aacute;t &eacute;s Javascriptet haszn&aacute;ltam. Nyilv&aacute;nval&oacute;an sok egy&eacute;b eszk&ouml;zzel &eacute;s m&oacute;dszerrel megoldhat&oacute;k lettek volna. Val&oacute;sz&iacute;n&#369;leg l&eacute;tezik enn&eacute;l m&eacute;g jobb, eleg&aacute;nsabb, hat&eacute;konyabb megold&aacute;s, akit &eacute;rdekel, b&aacute;tran n&eacute;zzen sz&eacute;t a vil&aacute;gh&aacute;l&oacute;n.&nbsp;</strong> <br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/ascii_christmas_tree.png" alt="" width="350" height="362" /></p>\r\n<h3>1. feladat</h3>\r\n<p>Adott egy bemenet (day1_input.txt) amiben felv&aacute;ltva szerepelnek <strong>&apos;(&apos;</strong> &eacute;s <strong>&apos;)&apos;</strong> karakterek. A <strong>&apos;(&apos;</strong> jelent&eacute;se: <em>"a T&eacute;lap&oacute; menjen egy emeletet felfel&eacute;"</em>, a <strong>&apos;)&apos;</strong> pedig <em>"a T&eacute;lap&oacute; menjen egy emeletet lefel&eacute;"</em>. Kezdetben 0-r&oacute;l indul. A megold&aacute;st <em>JavaScriptben</em> k&eacute;sz&iacute;tettem, mind&ouml;ssze p&aacute;r sor az eg&eacute;sz. A futtat&aacute;s&aacute;hoz nyissuk meg a bemeneti f&aacute;jlt egy tetsz&#337;leges <strong>webb&ouml;ng&eacute;sz&#337;ben</strong> (<a title="Mozzilla Firefox" href="https:&#47;&#47;www.mozilla.org/hu/firefox/new/" target="_blank">Firefox</a>, <a title="Google Chrome" href="http:&#47;&#47;www.google.com/intl/hu_hu/chrome/browser/desktop/index.html" target="_blank">Google Chrome</a>, <a title="Internet Explorer" href="http:&#47;&#47;windows.microsoft.com/hu-hu/internet-explorer/download-ie" target="_blank">Internet Explorer</a> &eacute;s t&aacute;rsaik...), majd tekints&uuml;k meg az oldal elemeinek k&oacute;dj&aacute;t: Ezt &aacute;ltal&aacute;ban jobb kattint&aacute;s ut&aacute;n az &apos;<em>Elem megtekint&eacute;se/vizsg&aacute;lata</em>&apos; men&uuml;pont kiv&aacute;laszt&aacute;s&aacute;val &eacute;rhetj&uuml;k el, de b&ouml;ng&eacute;sz&#337;nk&eacute;nt elt&eacute;r&#337; lehet. Ha megvan, l&aacute;thatjuk, hogy a sima sz&ouml;vegf&aacute;jlunkat a b&ouml;ng&eacute;sz&#337; kieg&eacute;sz&iacute;ti &eacute;rv&eacute;nyes HTML dokumentumm&aacute;, &eacute;s a teljes sz&ouml;vegr&eacute;szt a <strong>body</strong> r&eacute;szben, egy <strong>pre</strong> elembe teszi. A sz&ouml;veg beolvas&aacute;s&aacute;hoz nincs m&aacute;s dolgunk, mint lek&eacute;rni az adott elem tartalm&aacute;t egy v&aacute;ltoz&oacute;ba. Ehhez nyissuk meg a b&ouml;ng&eacute;sz&#337; <strong>webkonzolj&aacute;t</strong> (<em>jobb kattint&aacute;s/Elem megtekint&eacute;se/Konzol</em> f&uuml;l - de b&ouml;ng&eacute;sz&#337;nk&eacute;nt elt&eacute;rhet...), amely seg&iacute;ts&eacute;g&eacute;vel Javascript k&oacute;dunk futtathatjuk az adott dokumentumra (<a href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day1_input.txt" target="_blank">day1_input.txt</a>) vonatkz&oacute;an. <br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/web_console.png" alt="Google Chrome webb&ouml;ng&eacute;sz&#337; &eacute;s az elemvizsg&aacute;l&oacute;" width="500" height="234" /><br /><small>P&eacute;lda a b&ouml;ng&eacute;sz&#337; elemvizsg&aacute;l&oacute;j&aacute;ra. A webkonzolt az utols&oacute;, Console felirat&#369; f&uuml;lre kattintva &eacute;rhetj&uuml;k el</small>.<br /><br />A sz&ouml;veg beolvas&aacute;s&aacute;hoz adjuk ki a k&ouml;vetez&#337; parancsot:</p>\r\n<pre><code> var str = document.body.firstChild.innerText; console.log(str); </code></pre>\r\n<p>Ha mindent j&oacute;l csin&aacute;ltunk, ez a konzolra &iacute;rja a dokumentumunk sz&ouml;veg&eacute;t: ugyanis a dokumentumunk body r&eacute;sz&eacute;ben mind&ouml;ssze egyetlen elem van (<strong>pre = firstChild</strong>), aminek a tartalm&aacute;t sz&ouml;vegk&eacute;nt elk&eacute;rt&uuml;k, majd a console.log seg&iacute;ts&eacute;g&eacute;vel ki&iacute;rattuk. Innent&#337;l kezdve nem maradt m&aacute;s dolgunk, <em>mint egy egyszer&#369; &ouml;sszegz&eacute;s</em>: v&eacute;gign&eacute;zz&uuml;k a <strong>str</strong> v&aacute;ltoz&oacute; (a bemenet) minden karakter&eacute;t, &eacute;s <strong>&apos;(&apos;</strong> eset&eacute;n n&ouml;velj&uuml;k az aktu&aacute;lis szintet (ami kezdetben 0, teh&aacute;t f&ouml;ldszintr&#337;l indul a Mikul&aacute;s), egy&eacute;bk&eacute;nt cs&ouml;kentj&uuml;k. A teljes k&oacute;d:</p>\r\n<pre><code>var floor=0, str = document.body.firstChild.innerText;\r\nfor (i in str) \r\n{ \r\n	if (str[i]==&apos;(&apos;) \r\n		floor++; \r\n	else \r\n		floor--; \r\n} \r\nconsole.log(floor);\r\n</code></pre>\r\n<p>A feladat m&aacute;sodik r&eacute;sze sem sokkal bonyolultabb: ott <em>az els&#337; olyan poz&iacute;ci&oacute;t keress&uuml;k, amikor a T&eacute;lap&oacute; az els&#337; alagsori szintre (-1. szint) ker&uuml;l.</em> Az aktu&aacute;lis poz&iacute;ci&oacute;kat a <span style="text-decoration: underline;">string indexei</span> tartalmazz&aacute;k: a poz&iacute;ci&oacute; mindig eggyel t&ouml;bb, mint a string indexe, mivel a Javascript 0-t&oacute;l, a T&eacute;lap&oacute; pedig 1-t&#337;l kezdi a sz&aacute;mol&aacute;st. Teh&aacute;t ha az adott emelet (floor) &eacute;rt&eacute;ke -1, egyszer&#369;en kiugrunk a ciklusb&oacute;l, &eacute;s a jelenlegi index+1 lesz a keresett poz&iacute;ci&oacute;. Vagyis a k&oacute;d:</p>\r\n<pre><code>var floor=0, str = document.body.firstChild.innerText; \r\nfor (i in str) \r\n{ \r\n	if (str[i]==&apos;(&apos;) \r\n		floor++; \r\n	else f\r\n		loor--; \r\n	if (floor==-1) break; \r\n} \r\nconsole.log(++i);\r\n</code></pre>\r\n<h3>2. feladat</h3>\r\n<p>A feladat bemenete szint&eacute;n egy sz&ouml;vegf&aacute;jl, &eacute;s a feladatot szint&eacute;n az el&#337;bb bemutatott b&ouml;ng&eacute;sz&#337;+Javascript konzolon m&oacute;dszerrel k&eacute;sz&iacute;tettem el. A bemenet (<a href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day2_input.txt" target="_blank">day2_input.txt</a>) <em>soronk&eacute;nt</em> tartalmazza a csomagok sz&eacute;less&eacute;g&eacute;t, hossz&uacute;s&aacute;g&aacute;t &eacute;s magass&aacute;g&aacute;t, <strong>&apos;x&apos;</strong> karakterrel elv&aacute;lasztva. A teljes bemenet ugyan&uacute;gy &eacute;rhet&#337; el, mint az el&#337;z&#337; feladatn&aacute;l. A feldolgoz&aacute;shoz azonban c&eacute;lszer&#369; sz&eacute;tv&aacute;lasztani a fontos adatokat: ez&eacute;rt <em>v&aacute;gjuk sz&eacute;t a stringet</em>, &eacute;s a m&eacute;reteket t&aacute;roljuk el egy t&ouml;mbben:</p>\r\n<pre><code> var arr = document.body.firstChild.innerText.split(/x|\\n/).map(Number); </code></pre>\r\n<p>A document.body.firstChild.innerText r&eacute;sz a teljes bemenet sz&ouml;veg&eacute;t adja vissza, a <a title="JavaScript split method" href="http:&#47;&#47;www.w3schools.com/jsref/jsref_split.asp" target="_blank">split</a>&nbsp;met&oacute;dus pedig megadott elv&aacute;laszt&oacute;karakter vagy kifejez&eacute;s ment&eacute;n feldarabolja a sz&ouml;veget, &eacute;s a darabok t&ouml;mbj&eacute;vel t&eacute;r vissza. A splitben megadtam egy &uacute;gynevezett <a title="JavaScript RegExp reference" href="http:&#47;&#47;www.w3schools.com/jsref/jsref_obj_regexp.asp" target="_blank">regul&aacute;ris kifejez&eacute;st</a>, ami <strong>&apos;x&apos;</strong> karakterre VAGY sort&ouml;r&eacute;s (<strong>&apos;\\n&apos;</strong>) karakterre illeszkedik. A <a title="Array.prototype.map - MDN" href="https:&#47;&#47;developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map(Number)</a>&nbsp;pedig a stringekb&#337;l &aacute;ll&oacute; t&ouml;mb &ouml;sszes elem&eacute;t sz&aacute;mm&aacute; konvert&aacute;lja, &iacute;gy a sor eredm&eacute;nye a<em> bemenetben szerepl&#337; &ouml;sszes sz&aacute;m! </em></p>\r\n<p>Arra azonban figyelni kell, hogy a t&ouml;mb h&aacute;rom elemenk&eacute;nt alkot egy egys&eacute;get: vagyis <strong>arr[0]</strong> az els&#337; doboz <em>sz&eacute;less&eacute;ge</em>, <strong>arr[1]</strong> a <em>magass&aacute;ga</em>, <strong>arr[2]</strong> a <em>hossz&uacute;s&aacute;ga</em>, m&iacute;g <strong>arr[3]</strong> m&aacute;r a k&ouml;vetkez&#337; doboz <em>sz&eacute;less&eacute;ge</em>, &eacute;s &iacute;gy tov&aacute;bb. Teh&aacute;t<em> h&aacute;rmas&aacute;val l&eacute;pkedve</em> kell felsz&iacute;nt, illetve a legkisebb oldal ter&uuml;let&eacute;t kisz&aacute;molni, &eacute;s k&ouml;zben ezeket &ouml;sszegezni. A forr&aacute;sk&oacute;d:</p>\r\n<pre><code>var arr = document.body.firstChild.innerText.split(/x|\\n/).map(Number), total=0; \r\nfor (i=2; i&lt;arr.length; i+=3) \r\n{ \r\n	total+=2*(arr[i-2]*arr[i-1]+arr[i-1]*arr[i]+arr[i]*arr[i-2])+Math.min(arr[i-2]*arr[i-1], arr[i-1]*arr[i], arr[i]*arr[i-2]); \r\n} \r\nconsole.log(total);\r\n</code></pre>\r\n<p>A m&aacute;sodik r&eacute;sze is hasonl&oacute;. A legkisebb oldal ker&uuml;let&eacute;t az negyedik sorban az els&#337; tag adja meg, a t&eacute;rfogatot pedig a m&aacute;sodik, a h&aacute;romtag&uacute; szorzat:</p>\r\n<pre><code>var arr = document.body.firstChild.innerText.split(/x|\\n/).map(Number), ribbon=0; \r\nfor (i=2; i&lt;arr.length; i+=3) \r\n{ \r\n	ribbon+=2*Math.min(arr[i]+arr[i-1], arr[i-1]+arr[i-2], arr[i-2]+arr[i]) + arr[i]*arr[i-1]*arr[i-2]; \r\n} \r\nconsole.log(ribbon);\r\n</code></pre>\r\n<h3>3. feladat</h3>\r\n<p>Szint&eacute;n <strong>Javascript</strong>, szint&eacute;n dokumentum (<a href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day3_input.txt" target="_blank">day3_input.txt</a>) sz&ouml;veg&eacute;nek lek&eacute;r&eacute;se. A bemenet m&aacute;r megvan. Az &ouml;tletem az volt, hogy egy t&ouml;mbben&nbsp;<em>elt&aacute;rolok minden egyes poz&iacute;ci&oacute;t, ahol a T&eacute;lap&oacute; m&aacute;r j&aacute;rt</em>. &Iacute;gy a v&eacute;g&eacute;n ennek a <em>t&ouml;mbnek a m&eacute;rete</em> lesz azon h&aacute;zak sz&aacute;ma, ahol m&aacute;r kaptak aj&aacute;nd&eacute;kot! Minden <em>poz&iacute;ci&oacute; egy x &eacute;s egy y koordin&aacute;t&aacute;val</em> &iacute;rhat&oacute; le, ami kezdetben (0,0). Nyugatra l&eacute;p&eacute;s (&apos;<strong>&lt;&apos;</strong>) eset&eacute;n x cs&ouml;kken, m&iacute;g keletre l&eacute;p&eacute;s (<strong>&apos;&gt;&apos;</strong>) eset&eacute;n x n&#337;. Hasonl&oacute;an d&eacute;lre (<strong>&apos;v&apos;</strong>) l&eacute;p&eacute;s eset&eacute;n y cs&ouml;kken, m&iacute;g &eacute;szakra l&eacute;p&eacute;s eset&eacute;n (<strong>&apos;^&apos;</strong>) y n&#337;.</p>\r\n<p>Figyelni kell azonban arra, hogy <em>egy poz&iacute;ci&oacute;t csak egyszer t&aacute;roljunk</em>. Ez&eacute;rt minden egyes l&eacute;p&eacute;s sor&aacute;n vizsg&aacute;lni kell, hogy m&aacute;r benne van-e az a t&ouml;mbben a jelenlegi poz&iacute;ci&oacute;. Az aktu&aacute;lis poz&iacute;ci&oacute; egy <em>x,y kooridn&aacute;t&aacute;kb&oacute;l &aacute;ll&oacute; objektum</em>, ugyanakkor az egyszer&#369;s&eacute;g kedv&eacute;&eacute;rt sz&ouml;vegk&eacute;nt t&aacute;rolom el &#337;ket az &ouml;sszes poz&iacute;ci&oacute; t&ouml;mbj&eacute;ben. A stringg&eacute; alak&iacute;t&aacute;s&eacute;rt a <strong>JSON.stringify</strong> felel. Azt, hogy m&aacute;r benne van-e a t&ouml;mbben az adott poz&iacute;ci&oacute;, a t&ouml;mb <a title="JavaScript indexOf method" href="http:&#47;&#47;www.w3schools.com/jsref/jsref_indexof.asp" target="_blank">indexOf</a>&nbsp;met&oacute;dus&aacute;val vizsg&aacute;lom: ez visszaadja a keresett elem index&eacute;t a t&ouml;mbben, ha benne van. Ha pedig nincs benne -1-gyel t&eacute;r vissza: teh&aacute;t azt kell vizsg&aacute;lni, hogy -1-e ez az &eacute;rt&eacute;k az adott poz&iacute;ci&oacute;ra.</p>\r\n<pre><code>var text=document.body.firstChild.innerText, pos = {x: 0, y: 0}, allPos = [JSON.stringify(pos)]; \r\nfor (i in text) \r\n{\r\n	if(text[i]==&apos;&lt;&apos;) pos.x--; \r\n	if(text[i]==&apos;&gt;&apos;) pos.x++; \r\n	if(text[i]==&apos;^&apos;) pos.y++; \r\n	if(text[i]==&apos;v&apos;) pos.y--; \r\n	pos_str = JSON.stringify(pos); \r\n	if (allPos.indexOf(pos_str)==-1) \r\n		allPos.push(pos_str); \r\n} \r\nconsole.log(allPos.length);\r\n</code></pre>\r\n<p>A m&aacute;sodik r&eacute;sz szint&eacute;n nagyon hasonl&oacute;, azzal a k&uuml;l&ouml;nbs&eacute;ggel, hogy itt a Mikul&aacute;s &eacute;s a Robotmikul&aacute;s felv&aacute;ltva l&eacute;pked: &iacute;gy a ciklusom <em>kettes&eacute;vel halad</em>, &eacute;s az i. karakter eset&eacute;n az igazi Mikul&aacute;s poz&iacute;ci&oacute;j&aacute;t v&aacute;ltoztatom a megadott szab&aacute;ly szerint, az (i+1). karakter eset&eacute;n pedig a Robotmikul&aacute;s&eacute;t.</p>\r\n<p>var text=document.body.firstChild.innerText, pos = {x: 0, y: 0}, roboPos={x:0, y:0}, allPos = [JSON.stringify(pos)];</p>\r\n<pre><code>for (var i=0; i&lt;text.length; i+=2) \r\n{\r\n	if(text[i]==&apos;&lt;&apos;) pos.x--; \r\n	if(text[i]==&apos;&gt;&apos;) pos.x++; \r\n	if(text[i]==&apos;^&apos;) pos.y++; \r\n	if(text[i]==&apos;v&apos;) pos.y--; \r\n	if(text[i+1]==&apos;&lt;&apos;) roboPos.x--;\r\n	if(text[i+1]==&apos;&gt;&apos;) roboPos.x++;\r\n	if(text[i+1]==&apos;^&apos;) roboPos.y++;\r\n	if(text[i+1]==&apos;v&apos;) roboPos.y--; \r\n	pos_str = JSON.stringify(pos); \r\n	if (allPos.indexOf(pos_str)==-1) \r\n		allPos.push(pos_str); \r\n	pos_str = JSON.stringify(roboPos); \r\n	if (allPos.indexOf(pos_str)==-1) \r\n		allPos.push(pos_str); \r\n}\r\nconsole.log(allPos.length);\r\n</code></pre>', '2015-12-16 05:26:02', '2015-12-16 06:00:28'),
(56, 'comsciblog', 'Karácsony vége - Advent of Code 5. és 6. napi feladata', 'hu', '<p><strong>V&eacute;get &eacute;rt h&aacute;t a kar&aacute;csony, rem&eacute;lem mindenkinek nagyszer&#369;en telt. A kar&aacute;csonnyal egy&uuml;tt v&eacute;ge lett az adventi id&#337;szaknak is, &eacute;s vele az <a title="Advent of Code" href="http:&#47;&#47;adventofcode.com/" target="_blank">Advent of Code </a>nev&#369; kih&iacute;v&aacute;snak is. Ez azt jelenti, hogy nem lesz t&ouml;bb feladv&aacute;ny, viszont az el&#337;z&#337;ek (<a title="M&#369;k&ouml;dik-e a link?" href="http:&#47;&#47;adventofcode.com/" target="_blank">egyenl&#337;re</a>) el&eacute;rhet&#337;ek maradtak. Nekem sajnos (<a title="Na &eacute;s ez a link m&#369;k&ouml;dik?" href="http:&#47;&#47;adventofcode.com/" target="_blank">egyenl&#337;re</a>) nem siker&uuml;lt felgy&uacute;jtanom az adventi napt&aacute;rom (ASCII-feny&#337;fa) minden f&eacute;ny&eacute;t, pillanatnyilag 29 csillagot szereztem meg az 50-b&#337;l. Viszont a feladatok nagyon teteszettek, mindenkinek aj&aacute;nlom &#337;ket, &eacute;s alkalomadt&aacute;n m&eacute;g fogok &iacute;rni r&oacute;luk. P&eacute;ld&aacute;ul most: hiszen k&eacute;t feladat le&iacute;r&aacute;s&aacute;t fogom k&ouml;zz&eacute;tenni.<br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/ascii_christmas_tree.png" alt="Advent of Code ASCII kar&aacute;csonyfa" width="350" height="362" /><br /></strong></p>\r\n<h2>5. feladat</h2>\r\n<h3><span style="text-decoration: underline;">1. k&eacute;rd&eacute;s</span></h3>\r\n<p>A Mikul&aacute;s b&aacute;csinak&nbsp;ism&eacute;t sz&uuml;ks&eacute;ge van r&aacute;d! Neked kell ugyanis eld&ouml;ntened, hogy a neki &iacute;rt levelekben melyik sz&oacute; sz&eacute;p, &eacute;s melyik cs&uacute;nya sz&oacute;.</p>\r\n<p style="text-align: center;"><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/uncle_santa wants_you.jpg " alt="" width="223" height="400" /><sub>Bizony, a j&oacute; &ouml;reg Mikul&aacute;snak&nbsp;sz&uuml;ks&eacute;ge van r&aacute;d! A k&eacute;p&eacute;t k&ouml;sz&ouml;net: <a title="Uncle Santa needs you!" href="http:&#47;&#47;channelsanta.blogspot.hu/2010/11/santa-needs-you.html" target="_blank">channelsanta.blogspot.com</a></sub></p>\r\n<p>A sz&eacute;p sz&oacute; tulajdons&aacute;gai:</p>\r\n<ol>\r\n<li>Legal&aacute;bb 3 mag&aacute;nhangz&oacute;t tartalmaz (az angol &aacute;b&eacute;c&eacute;b&#337;l: aeiou).</li>\r\n<li>Legal&aacute;bb egy dupla bet&#369;t tartalmaz.</li>\r\n<li>Nem tartalmazza a k&ouml;vetkez&#337; sz&ouml;vegr&eacute;szeket: ab, cd, pq, vagy xy.</li>\r\n</ol>\r\n<p>P&eacute;ld&aacute;ul:</p>\r\n<ul>\r\n<li><strong>ugknbfddgicrmopn</strong> sz&eacute;p sz&oacute;, mert tartalmaz legal&aacute;bb h&aacute;rom mag&aacute;nhangz&oacute;t, egy dupla bet&#369;t (dd), &eacute;s nem tartalmaz tiltott sz&ouml;vegr&eacute;szt.</li>\r\n<li><strong>aaa</strong> is sz&eacute;p, mert tartalmaz legal&aacute;bb h&aacute;rom mag&aacute;nhangz&oacute;t, &eacute;s dupla bet&#369;t is. Nem probl&eacute;ma, hogy ezek &aacute;tlapol&oacute;dnak.</li>\r\n<li>Viszont <strong>jchzalrnumimnmhp</strong> cs&uacute;nya sz&oacute;, mert nincs benne dupla bet&#369;, <strong>dvszwmarrgswjxmb</strong> az&eacute;rt, mert csak egy mag&aacute;nhangz&oacute;t tartalmaz, <strong>haegwjzuvuyypxyu</strong> pedig az&eacute;rt, mert tartalmazza az xy tiltott sz&ouml;vegr&eacute;szt.</li>\r\n</ul>\r\n<p><span style="text-decoration: underline;">K&eacute;rd&eacute;s</span>: H&aacute;ny sz&eacute;p sz&oacute; tal&aacute;lhat&oacute; az <a title="5. feladat bemeneti &aacute;llom&aacute;nya" href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day5_input.txt" target="_blank">day5_input.txt</a>&nbsp;sz&ouml;vegf&aacute;jlban? (ahol egy sorban egy sz&oacute; tal&aacute;lhat&oacute;)</p>\r\n<h3><span style="text-decoration: underline;">2. k&eacute;rd&eacute;s</span></h3>\r\n<p>A Mikul&aacute;s&nbsp;k&ouml;zben r&aacute;j&ouml;tt a m&oacute;dszer hib&aacute;ira, &eacute;s egy jobb modelt fejlesztett ki annak eld&ouml;nt&eacute;s&eacute;re, hogy a sz&oacute; sz&eacute;p vagy cs&uacute;nya. Mostant&oacute;l egyeten r&eacute;gi szab&aacute;ly sem &eacute;rv&eacute;nyes, ugyanis kider&uuml;lt, hogy mindegyik nevets&eacute;gesen rossz.</p>\r\n<p>A sz&eacute;p sz&oacute; &uacute;j tulajdons&aacute;gai:</p>\r\n<ul>\r\n<li>&nbsp;Tartalmaz egy olyan k&eacute;tbet&#369;s r&eacute;szt, amelyik legal&aacute;bb k&eacute;tszer megjelenik a sz&oacute;ban, &aacute;tlapol&oacute;d&aacute;s n&eacute;lk&uuml;l. P&eacute;ld&aacute;ul <strong>xyxy</strong> (a k&eacute;tbet&#369;s r&eacute;sz <strong>xy</strong>), vagy <strong>aabcdefgaa</strong> (a k&eacute;tbet&#369;s r&eacute;sz <strong>aa</strong>) ilyen, de <strong>aaa</strong> nem (mivel <strong>aa</strong> &aacute;tlapol&oacute;dik).</li>\r\n<li>&nbsp;Tartalmaz legal&aacute;bb egy bet&#369;t, ami megism&eacute;tl&#337;dik &uacute;gy, hogy pontosan 1 bet&#369; van a k&eacute;t el&#337;fordul&aacute;s k&ouml;z&ouml;tt: P&eacute;ld&aacute;ul <strong>xyx</strong>, <strong>abcdefeghi</strong> (az <strong>efe</strong> r&eacute;sz miatt), vagy ak&aacute;r az <strong>aaa</strong>. (Vagyis tartalmaz olyan h&aacute;rombet&#369;s r&eacute;szt, amelyben az 1. &eacute;s 3. bet&#369; megegyezik.)</li>\r\n</ul>\r\n<p>P&eacute;ld&aacute;ul:</p>\r\n<ul>\r\n<li><strong>qjhvhtzxzqqjkmpb</strong> sz&eacute;p, mert <strong>qj</strong> p&aacute;r k&eacute;tszer megjelenik, &eacute;s van olyan h&aacute;rombet&#369;s r&eacute;sz, ahol az 1. &eacute;s a 3. bet&#369; megegyezik. (<strong>zxz</strong>)</li>\r\n<li><strong>xxyxx</strong> is sz&eacute;p, mert <strong>xx</strong> k&eacute;tszer megjelenik, &eacute;s <strong>xyx</strong> megfelel&#337; h&aacute;rombet&#369;s r&eacute;sz. Az nem gond, hogy a k&eacute;t szab&aacute;ly &aacute;tlapol&oacute;dik.</li>\r\n<li><strong>uurcxstgmygtbstg</strong> cs&uacute;nya sz&oacute;, mert ugyan van ism&eacute;tl&#337;d&#337; p&aacute;r (<strong>tg</strong>), de nincs benne megfelel&#337; h&aacute;rombet&#369;s r&eacute;sz.</li>\r\n<li><strong>ieodomkazucvgmuy</strong> pedig az&eacute;rt cs&uacute;nya, mert hi&aacute;ba tartalmaz megfelel&#337; h&aacute;rombet&#369;s r&eacute;szt (<strong>odo</strong>), de nincs benne ism&eacute;tl&#337;d&#337; p&aacute;r.</li>\r\n</ul>\r\n<p><span style="text-decoration: underline;">A k&eacute;rd&eacute;s ugyanaz:</span> H&aacute;ny sz&eacute;p sz&oacute; tal&aacute;lhat&oacute; a (v&aacute;ltozatlan) <a title="5. feladat bemeneti &aacute;llom&aacute;nya" href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day5_input.txt" target="_blank">day5_input.txt</a> f&aacute;jlban az &uacute;j szab&aacute;lyok figyelembev&eacute;tel&eacute;vel?</p>\r\n<h2>6. feladat</h2>\r\n<h3><span style="text-decoration: underline;">1. k&eacute;rd&eacute;s</span></h3>\r\n<p>Mivel tavaly a szomsz&eacute;daid cs&uacute;ny&aacute;n ell&aacute;tt&aacute;k a bajod a kar&aacute;csonyi h&aacute;zd&iacute;sz&iacute;t&#337;-versenyen, &uacute;gy d&ouml;nt&ouml;tt&eacute;l, hogy id&eacute;n <em>egymilli&oacute; &eacute;g&#337;t telep&iacute;tesz a h&aacute;zadra, egy 1000x1000-es r&aacute;cs form&aacute;j&aacute;ban</em>. Tov&aacute;bb&aacute;, mivel id&eacute;n k&uuml;l&ouml;n&ouml;sen j&oacute;l viselkedt&eacute;l, a T&eacute;lap&oacute; &iacute;rt egy levelet (<a title="A T&eacute;lap&oacute; levele (utas&iacute;t&aacute;sok)" href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day6_input.txt" target="_blank">day6_input.txt</a>), <em>hogyan &aacute;ll&iacute;tsd be</em> megfelel&#337;en a f&eacute;nyeket.<br />A f&eacute;nyek a r&aacute;csban 0-t&oacute;l 999-ig vannak sorsz&aacute;mozva f&uuml;gg&#337;legesen &eacute;s v&iacute;zszintesen is: teh&aacute;t a sarokban l&eacute;v&#337; &eacute;g&#337;k koordin&aacute;t&aacute;i: (0, 0), (0, 999), (999, 999) &eacute;s (999, 0). A <em>T&eacute;lap&oacute; utas&iacute;t&aacute;sat</em>&nbsp; (a <a title="A T&eacute;lap&oacute; levele (utas&iacute;t&aacute;sok)" href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day6_input.txt" target="_blank">day6_input.txt</a> f&aacute;jlban) tartalmazz&aacute;k, hogy a r&aacute;cs melyik r&eacute;sz&eacute;t kell felkapcsolni, lekapcsolni, illetve &aacute;tkapcsolni. A megadott koordin&aacute;tap&aacute;rok az adott t&eacute;glalap jobb fels&#337; &eacute;s bal als&oacute; sark&aacute;t reprezent&aacute;lj&aacute;k: p&eacute;ld&aacute;ul a "<strong>(0,0) through (2,2)</strong>" <em>9 &eacute;g&#337;t jelent egy 3x3-as n&eacute;gyzetben</em>. Kezdetben egyetlen &eacute;g&#337; sem vil&aacute;g&iacute;t.<br />Ahhoz, hogy legy&#337;zd a szomsz&eacute;daid, csak k&ouml;vetned kell a T&eacute;lap&oacute; utas&iacute;t&aacute;sait sorrendben.</p>\r\n<p style="text-align: center;"><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/A-nagy-kar&aacute;csonyi-izz&oacute;csata-9.jpg " alt="Feld&iacute;sz&iacute;tett h&aacute;z a &apos;Nagy kar&aacute;csonyi izz&oacute;csata&apos; c&iacute;m&#369; filmb&#337;l" width="500" height="333" /><sub>R&eacute;szlet a &apos;Nagy kar&aacute;csonyi izz&oacute;csata&apos; c&iacute;m&#369; filmb&#337;l. A k&eacute;p forr&aacute;sa: <a title="A Nagy kar&aacute;csonyi izz&oacute;csata" href="http:&#47;&#47;www.mediaklikk.hu/2013/12/18/a-nagy-karacsonyi-izzocsata/" target="_blank">mediaklikk.hu</a></sub></p>\r\n<p>P&eacute;ld&aacute;ul:</p>\r\n<ul>\r\n<li><strong>turn on 0,0 through 999,999</strong> - kikapcsol minden &eacute;g&#337;t.</li>\r\n<li><strong>toggle 0,0 through 999,0</strong> - &aacute;tkapcsolja az els&#337; sor 1000 &eacute;g&#337;j&eacute;t: amelyik vil&aacute;g&iacute;tott, az nem vil&aacute;g&iacute;t, amelyik pedig nem vil&aacute;g&iacute;tott, az vil&aacute;g&iacute;t.</li>\r\n<li><strong>turn off 499,499 through 500,500</strong> - kikapcsolja a k&ouml;z&eacute;ps&#337; n&eacute;gy &eacute;g&#337;t.</li>\r\n</ul>\r\n<p><span style="text-decoration: underline;">K&eacute;rd&eacute;s:</span> Az utas&iacute;t&aacute;sok elv&eacute;gz&eacute;se ut&aacute;n h&aacute;ny &eacute;g&#337; fog vil&aacute;g&iacute;tani?</p>\r\n<h3><span style="text-decoration: underline;">2. k&eacute;rd&eacute;s</span></h3>\r\n<p>M&aacute;r &eacute;pp elk&eacute;sz&uuml;lt a gy&#337;ztes f&eacute;nybe&aacute;ll&iacute;t&aacute;s, mikor r&aacute;j&ouml;tt&eacute;l, mekkora <em>hib&aacute;t v&eacute;tett&eacute;l</em>, amikor a T&eacute;lap&oacute; level&eacute;t <em>&#337;si &eacute;szaki-man&oacute;nyelvr&#337;l</em> ford&iacute;tottad a saj&aacute;t anyanyelvedre! Ugyanis a lev&eacute;l az <em>&#337;si &eacute;szaki-man&oacute;nyelv egy ritka dialektu&aacute;sban</em> &iacute;r&oacute;dott, &iacute;gy a <span style="text-decoration: underline;">tartalma teljesen m&aacute;s</span>, mint azel&#337;tt gondoltad! Az &uacute;j ford&iacute;t&aacute;s szerint minden &eacute;g&#337;nek <strong>szab&aacute;lyozhat&oacute; f&eacute;nyereje</strong> van: minden &eacute;g&#337; 0 vagy t&ouml;bb egys&eacute;gnyi f&eacute;nnyel rendelkezhet. Az &ouml;sszes &eacute;g&#337; f&eacute;nyess&eacute;ge kezdetben 0. <br />A "<strong>turn on</strong>" jelent&eacute;se helyes ford&iacute;t&aacute;sban: "<em>n&ouml;veld meg a f&eacute;nyess&eacute;g&eacute;t 1-gyel</em>", a m&iacute;g "<strong>turn off</strong>" jelent&eacute;se, hogy "<em>cs&ouml;kkentsd a f&eacute;nyess&eacute;g&eacute;t 1-gyel</em>" (legfeljebb null&aacute;ig). A "<strong>toggle</strong>" jelent&eacute;se pedig, hogy "<em>n&ouml;veld meg a f&eacute;nyess&eacute;g&eacute;t 2-vel</em>".</p>\r\n<p><span style="text-decoration: underline;">A k&eacute;rd&eacute;s:</span> Mennyi lesz a teljes f&eacute;nyess&eacute;g az utas&iacute;t&aacute;sok v&eacute;grehajt&aacute;sa ut&aacute;n?</p>\r\n<p>P&eacute;ld&aacute;ul:</p>\r\n<ul>\r\n<li><strong>turn on 0,0 through 0,0</strong> - eggyel n&ouml;veli a teljes f&eacute;nyess&eacute;get.</li>\r\n<li><strong>toggle 0,0 through 999,999</strong> - 2000000-val n&ouml;veli a teljes f&eacute;nyess&eacute;get. (Az &ouml;sszeset n&ouml;veli 2-vel)</li>\r\n</ul>', '2015-12-27 10:26:55', '2015-12-28 11:11:10'),
(57, 'comsciblog', 'Advent of Code 5. feladat megoldása', 'hu', '<p><strong>Ma az <a title="Kar&aacute;csony v&eacute;ge - Advent of Code 5. &eacute;s 6. napi feladata" href="http:&#47;&#47;comsciblog.esy.es/article/56/Kar%C3%A1csony+v%C3%A9ge+-+Advent+of+Code+5.+%C3%A9s+6.+napi+feladata" target="_blank">el&#337;z&#337; bejegyz&eacute;sben</a> le&iacute;rt feladatokat fogom k&ouml;zz&eacute;tenni. A v&aacute;ltozatoss&aacute;g kedv&eacute;&eacute;rt ezekn&eacute;l a feladatokn&aacute;l a Java programoz&aacute;si nyelvet haszn&aacute;ltam. A bejegyz&eacute;sben kit&eacute;rek a Java n&eacute;h&aacute;ny nagyon alapvet&#337; technikai r&eacute;szlet&eacute;re (&eacute;n sem vagyok nagy Java-szak&eacute;rt&#337;, b&aacute;r egyre jobban megkedvelem), majd a bemutatom a le&iacute;rt programot. Ebben a bejegyz&eacute;sben csak az 5. feladat megold&aacute;s&aacute;t teszem k&ouml;zz&eacute;, a 6.-at egy k&ouml;vetkez&#337;ben fogom (mivel &iacute;gy is hossz&uacute;ra siker&uuml;lt). Rem&eacute;lem tetszik majd annak, aki olvassa!<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/ascii_christmas_tree.png" alt="Advent of Code kar&aacute;csonyfa ASCII karakterekb&#337;l" width="300" height="311" /></strong></p>\r\n<h2>Kezdj&uuml;k az elej&eacute;n!</h2>\r\n<p>&nbsp;<em>Mi&eacute;rt is v&aacute;lasztottam a Java nyelvet?</em> (P&eacute;ld&aacute;ul C++ helyett?). A v&aacute;lasz tal&aacute;n t&uacute;ls&aacute;gosan is szimpla: szerettem volna kicsit gyakorolni, mivel m&aacute;r el&eacute;g r&eacute;g haszn&aacute;ltam utolj&aacute;ra. &Eacute;s akkor sem t&uacute;l sokat.<br />A <a title="Java programoz&aacute;si nyelv - Wikip&eacute;dia sz&oacute;cikk" href="https:&#47;&#47;hu.wikipedia.org/wiki/Java_(programoz%C3%A1si_nyelv)" target="_blank">Java nyelv</a> (szemben a C++-al) <em>teljesen objektumorient&aacute;lt.</em> Ez azt jelenti, hogy minden program meg&iacute;r&aacute;s&aacute;hoz sz&uuml;ks&eacute;g&uuml;nk van legal&aacute;bb egy Java oszt&aacute;lyra, aminek r&eacute;sze a main statikus met&oacute;dus. A java forr&aacute;sk&oacute;dok kiterjeszt&eacute;se hagyom&aacute;nyosan java, a nev&uuml;k pedig az oszt&aacute;ly neve. Teh&aacute;t a Hello World program Jav&aacute;ban valahogy &iacute;gy n&eacute;z ki:</p>\r\n<pre><code>public class MyHelloClass \r\n{\r\n public static void main(String[] args)\r\n {\r\n System.out.println("Hello world!"); \r\n }\r\n}\r\n</code></pre>\r\n<p>A Java program ford&iacute;t&aacute;sa a <strong>javac</strong> paranccsal t&ouml;rt&eacute;nik (felt&eacute;ve, ha van telep&iacute;tva <a title="Oracle hivatalos oldala - Java SE Development Kit 8" href="http:&#47;&#47;www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank">valamif&eacute;le jdk</a> a sz&aacute;m&iacute;t&oacute;g&eacute;p&uuml;nkre. Windows eset&eacute;n ezen k&iacute;v&uuml;l m&eacute;g c&eacute;lszer&#369;&nbsp;lehet be&aacute;ll&iacute;tani a <a title="Java PATH be&aacute;ll&iacute;t&aacute;sa (angol)" href="https:&#47;&#47;www.java.com/en/download/help/path.xml" target="_blank">PATH k&ouml;rnyezeti v&aacute;ltoz&oacute;ba</a> a<strong> javac.exe</strong> el&eacute;r&eacute;si &uacute;tj&aacute;t.). A ford&iacute;t&oacute; azonban nem az adott rendszer g&eacute;pi k&oacute;dj&aacute;ra ford&iacute;t, hanem a<a title="Java virtu&aacute;lis g&eacute;p - Wikip&eacute;dia sz&oacute;cikk" href="https:&#47;&#47;hu.wikipedia.org/wiki/Java_virtu&aacute;lis_g&eacute;p" target="_blank"> Java Virtu&aacute;lis G&eacute;p (JVM)</a> saj&aacute;t g&eacute;pi k&oacute;dj&aacute;ra, &uacute;gynevezett bytek&oacute;dra. &Iacute;gy a javac ford&iacute;t&aacute;s eredm&eacute;nyezi a Java oszt&aacute;lyoket (*.class kiterjeszt&eacute;s). Ezeket a JVM k&eacute;pes futtatni a <strong>java</strong> paranccsal (persze csak ha telep&iacute;tve van.)<br />Az el&#337;z&#337; p&eacute;lda ford&iacute;t&aacute;sa (<em>MyHelloClass.java</em> a f&aacute;jln&eacute;v $\\rightarrow$ l&aacute;sd feljebb)</p>\r\n<pre><code> $ javac MyHelloClass.java </code></pre>\r\n<p>Ez a sor egy <em>MyHelloClass.class</em> Java oszt&aacute;lyt eredm&eacute;nyez, aminek futtat&aacute;sa:</p>\r\n<pre><code> $ java MyHelloClass </code></pre>\r\n<h2>T&eacute;rj&uuml;nk r&aacute; a konkr&eacute;t feladatra!</h2>\r\n<p>A feladat megadott<em> bizonyos szavakat (soronk&eacute;nt)</em> egy&nbsp;<a title="day5_input.txt" href="http:&#47;&#47;comsciblog.esy.es/adventofcode/day5_input.txt" target="_blank">bemeneti f&aacute;jlban</a>. Els&otilde; l&eacute;p&eacute;sk&eacute;nt c&eacute;lszer&ucirc; a bemeneti f&aacute;jlt <em>soronk&eacute;nt beolvasni</em>. A Java nyelvben ezt k&ouml;nnyed&eacute;n megtehetj&uuml;k a <strong>BufferedReader</strong> oszt&aacute;ly p&eacute;ld&aacute;nyos&iacute;t&aacute;s&aacute;val. Ugyanis a <strong>BufferedReader</strong>-nek van egy <strong>readLine</strong> met&oacute;dusa, ami a megadott bemenetr&otilde;l soronk&eacute;nt olvashatunk egy Stringbe. (Hasonl&oacute; m&oacute;don, mint a C++ eset&eacute;n a <strong>getline</strong> olvasott a file streamb&otilde;l.) Vagyis a soronk&eacute;nt beolvas&oacute; program main met&oacute;dusa:</p>\r\n<pre><code>public static void main(String[] args)\r\n{\r\n	String fileName = "day5_input.txt";\r\n	try \r\n	{\r\n		BufferedReader reader = new BufferedReader(new FileReader(fileName) );\r\n		String line = reader.readLine();\r\n		while (line!=null)\r\n		{\r\n			System.out.println(line); &#47;&#47;test print\r\n			line = reader.readLine();\r\n		}\r\n	}\r\n	catch (FileNotFoundException ex)\r\n	{\r\n		System.out.println("File not found: "+fileName);\r\n		ex.printStackTrace();\r\n	}\r\n	catch(Exception ex)\r\n	{\r\n		System.out.println("Fatal error!");\r\n		ex.printStackTrace();\r\n	}\r\n}\r\n</code></pre>\r\n<p>A fenti program a beolvas&aacute;son k&iacute;v&uuml;l n&eacute;mi alapvet&#337; hibakezel&eacute;st is v&eacute;gez: az &aacute;tlagos Java haszn&aacute;l&oacute; ugyanis nem hallgatott a <a title="Tedd, vagy ne tedd! De ne pr&oacute;b&aacute;ld!" href="https:&#47;&#47;www.youtube.com/watch?v=h5SNAluOj6U" target="_blank">b&ouml;lcs Yoda szavaira</a>, &eacute;s ez&eacute;rt miel&otilde;tt b&aacute;rmit is tenne, el&#337;bb megpr&oacute;b&aacute;lja (<strong>try</strong> blokk.) Ha m&eacute;gsem siker&uuml;lne, a Java dob egy kiv&eacute;telt (<strong>Exception</strong>), amit a <strong>catch</strong> blokk(ok) seg&iacute;ts&eacute;g&eacute;vel elkaphatunk. P&eacute;ld&aacute;ul ha nem tal&aacute;lhat&oacute; a megadott f&aacute;jl, <strong>FileNotFoundException</strong>-t dob, amit a fenti k&oacute;dban l&eacute;v&#337; els&#337; catch blokkal kezel&uuml;nk le (Udvariasan t&aacute;j&eacute;koztatjuk a felhaszn&aacute;l&oacute;t, hogy nincs ilyen nev&ucirc; f&aacute;jlja a megadott &uacute;tvonalon). Ha egy&eacute;b, &aacute;ltal&aacute;sos hib&aacute;t dobna, a m&aacute;sodik <strong>catch</strong> blokk l&eacute;p &eacute;rv&eacute;nybe, egy nem t&uacute;l cizell&aacute;lt <strong>"Fatal error!"</strong> &uuml;zenet k&iacute;s&eacute;ret&eacute;ben. (Term&eacute;szetesen a <strong>catch</strong> blokkokba ker&uuml;lhet egy&eacute;b Java k&oacute;d is).</p>\r\n<p style="text-align: center;"><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/do_or_do_not.jpg" alt="Tedd, vagy ne tedd! De ne pr&oacute;b&aacute;ld! - Yoda k&eacute;p&eacute;vel, angolul" width="500" height="378" /><sub><em>"Tedd, vagy ne tedd! De ne pr&oacute;b&aacute;ld!</em>" - ezt m&aacute;r Yoda mester is megmondta a Birodalom visszav&aacute;g c&iacute;m&#369; filmben.<br />(A k&eacute;p forr&aacute;sa: <a href="http:&#47;&#47;memegenerator.net/instance/53996301" target="_blank">memegenerator.net</a>)</sub><br /><br /></p>\r\n<p>Term&eacute;szetesen a bemeneti f&aacute;jlnevet &aacute;tadhatjuk a programnak parancssori argumentumk&eacute;nt. Erre szolg&aacute;l a <strong>main</strong> met&oacute;dusunk <strong>args</strong> param&eacute;tere, amely a futatt&aacute;skor megadott argumentumokat tartalmazza, Stringek t&ouml;mbjek&eacute;nt. Az els&#337; argumentum az <strong>args[0]</strong> elem (ellent&eacute;tben a C-vel, ahol az <strong>argv[0]</strong> &aacute;ltal&aacute;ban a futtathat&oacute; &aacute;llom&aacute;ny neve). Ha nem adunk meg argumentumot, a Java program szint&eacute;n kiv&eacute;telt dob, mivel az <strong>args[0]</strong> nem defini&aacute;lt (<strong>null</strong>), vagyis nincs 0. eleme, teh&aacute;t <strong>ArrayIndexOutOfBoundsException</strong>, amit szint&eacute;n elkaphatunk, hogy a megfelel&#337; hiba&uuml;zenetet ki&iacute;rjuk.</p>\r\n<p><span style="text-decoration: underline;">Megjegyz&eacute;s:</span></p>\r\n<p>Fontos, hogy a catch blokkokat milyen sorrendben &iacute;rjuk, ugyanis egym&aacute;s ut&aacute;n hajt&oacute;dnak v&eacute;gre. Teh&aacute;t ha egy kiv&eacute;tel nem p&eacute;ld&aacute;nya a <strong>IndexOutOfBoundsException</strong> oszt&aacute;lynak, akkor teljesen felesleges m&ouml;g&eacute; <strong>ArrayIndexOutOfBoundsException</strong>-t, vagy <strong>StringIndexOutOfBoundsException</strong>-t &iacute;rni, mivel ut&oacute;bbi lesz&aacute;rmazottja az el&#337;bbinek. Vagyis c&eacute;lszer&#369; az utols&oacute; <strong>catch</strong>-nek mindig sima <strong>Exception</strong>-nek lennie, az ugyanis minden kiv&eacute;telt elkap.</p>\r\n<p><img class="img-responsive" src="http:&#47;&#47;comsciblog.esy.es/img/catch_em_all.png" alt="Pok&eacute;mon! Szerezd meg h&aacute;t mind! - log&oacute; angol nyelven" width="640" height="308" /></p>\r\n<p style="text-align: center;"><sub>Egy nehezen leford&iacute;that&oacute; sz&oacute;j&aacute;t&eacute;k. Akinek nem esik le, &iacute;gy j&aacute;rt. </sub><br /><sub>(K&eacute;p forr&aacute;sa: <a href="http:&#47;&#47;logos.wikia.com/wiki/File:Pok%C3%A9mon_Gotta_Catch_&apos;Em_All_1.png" target="_blank">logos.wikia.com</a>)</sub></p>\r\n<p><br />Ezek ut&aacute;n nincs m&aacute;s dolgunk, mint <em>&ouml;sszesz&aacute;ml&aacute;lni</em>, hogy a beolvasott sorok k&ouml;z&uuml;l <em>mennyi a sz&eacute;p sz&oacute;</em>. Ez egy egyszer&#369; sz&aacute;mol&aacute;s: ha egy felt&eacute;tel teljes&uuml;l, n&ouml;vel&uuml;nk egy v&aacute;ltoz&oacute;t. A programunk main met&oacute;dusa teh&aacute;t:</p>\r\n<pre><code>public static void main (String[] args)\r\n{\r\n String fileName = "";\r\n try \r\n {\r\n	fileName = args[0]; &#47;&#47;fileName from argument!\r\n	BufferedReader reader = new BufferedReader(new FileReader(fileName) );\r\n	String line = reader.readLine();\r\n	int nice1Count = 0, nice2Count = 0;\r\n	while (line!=null)\r\n	{\r\n	 if (isNice1(line)) \r\n		++nice1Count;\r\n	 if (isNice2(line))\r\n		++nice2Count;\r\n	 line = reader.readLine();\r\n	}\r\n	System.out.println("Nice1 words in "+fileName+": "+nice1Count);\r\n	System.out.println("Nice2 words in "+fileName+": "+nice2Count);\r\n }\r\n catch(ArrayIndexOutOfBoundsException ex)\r\n {\r\n	 System.out.println("Program argument: &lt;inputfile&gt;");\r\n	 ex.printStackTrace();\r\n }\r\n catch (FileNotFoundException ex)\r\n {\r\n	 System.out.println("File not found: "+fileName);\r\n	 ex.printStackTrace();\r\n }\r\n catch(Exception ex)\r\n {\r\n	 System.out.println("Fatal error!");\r\n	 ex.printStackTrace();\r\n }\r\n}\r\n</code></pre>\r\n<p>Megfigyelhet&#337;, hogy ez a <strong>main</strong> haszn&aacute;lhat&oacute; mindk&eacute;t r&eacute;szfeladat eset&eacute;ben, mivel a<span style="text-decoration: underline;"> k&eacute;rd&eacute;s ugyanaz</span>: <em>mennyi sz&eacute;p sz&oacute; tal&aacute;lhat&oacute; a sz&ouml;vegben</em>? Mind&ouml;ssze a "sz&eacute;p sz&oacute;" defin&iacute;ci&oacute;ja v&aacute;ltozik, teh&aacute;t az <strong>isNice1</strong> helyett egy <strong>isNice2</strong> met&oacute;dust kell h&iacute;vnunk. Ez&eacute;rt is van <em>k&eacute;t tesztel&eacute;s, k&eacute;t &ouml;sszegz&eacute;s &eacute;s k&eacute;t ki&iacute;rat&aacute;s</em> a fenti programk&oacute;dban. Az <strong>isNice</strong>(1/2) teh&aacute;t mindk&eacute;t esetben egy <strong>boolean</strong> visszat&eacute;r&eacute;s&#369; f&uuml;ggv&eacute;ny, ami visszaadja, hogy a param&eacute;terben &aacute;tadott sz&oacute; sz&eacute;p-e? A feladat sz&ouml;vege alapj&aacute;n teh&aacute;t az <strong>isNice1</strong> met&oacute;dus:</p>\r\n<pre><code>public static boolean isNice1(String word)\r\n{\r\n	String[] bad = {"ab", "cd", "pq", "xy"}; &#47;&#47;bad part list\r\n	String[] vowel = {"a", "e", "i", "o", "u"}; &#47;&#47;vowel list\r\n	int vovelCount = 0;\r\n	boolean hasDouble = false;\r\n		\r\n	for (int i=0; i&lt;word.length(); ++i)\r\n	{\r\n	 if (Arrays.asList(vowel).contains(word.substring(i, i+1))) &#47;&#47;i. char vowel?\r\n		++vovelCount;\r\n	}		\r\n	if (vovelCount&lt;3) \r\n	 return false;\r\n		\r\n	for (int i=0; i&lt;word.length()-1; ++i)\r\n	{\r\n		String sub = word.substring(i, i+2);\r\n		if (Arrays.asList(bad).contains(sub)) &#47;&#47;contains bad word?\r\n		 return false;\r\n		if (sub.charAt(0)==sub.charAt(1)) &#47;&#47;is double character\r\n		 hasDouble = true;\r\n	}\r\n	return hasDouble;\r\n}\r\n</code></pre>\r\n<p>Az <strong>isNice2</strong> met&oacute;dus pedig:</p>\r\n<pre><code>public static boolean isNice2(String word)\r\n{\r\n	boolean found = false;\r\n	&#47;&#47;check repeat with exactly 1 letter between them\r\n	for (int i=0; i&lt;word.length()-2; ++i)\r\n	{\r\n		String sub = word.substring(i, i+3);\r\n		if (sub.charAt(0) == sub.charAt(2))\r\n			found = true;\r\n	}\r\n	if (!found)\r\n		return false;\r\n		\r\n	&#47;&#47;check pairs without overlapping\r\n	for (int i=0; i&lt;word.length()-1; ++i)\r\n	{\r\n		for (int j=i+2; j&lt;word.length()-1; ++j)\r\n		{\r\n			if (word.substring(i, i+2).equals(word.substring(j, j+2)) )\r\n				return true;\r\n		}\r\n	}\r\n	return false;\r\n}\r\n</code></pre>', '2015-12-28 08:36:26', '2015-12-28 09:36:57');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(58, 'comsciblog', 'Advent of Code 6. feladat - megoldás', 'hu', '<p style="text-align: left;"><strong>Ma az Advent of Code hatodik feladat&aacute;nak megold&aacute;s&aacute;t fogom megosztani. Az <a title="Advent of Code 5. feladat megold&aacute;sa" href="http:&#47;&#47;comsciblog.esy.es/article/57/Advent+of+Code+5.+feladat+megold%C3%A1sa" target="_blank">el&#337;z&#337; feladat megold&aacute;s&aacute;hoz</a> hasonl&oacute;an, itt&nbsp;is a Java programoz&aacute;si nyelvet&nbsp;haszn&aacute;ltam. Ebben a bejegyz&eacute;sben azonban kevesebbet &iacute;rok a Java nyelvr&#337;l, &eacute;s t&ouml;bbet a feladatmegold&aacute;som r&eacute;szleteir&#337;l.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="https:&#47;&#47;pbs.twimg.com/media/CXG6YRoWYAUxpIA.png" alt="Sajnos az eny&eacute;m (m&eacute;g) nem n&eacute;z ki &iacute;gy." width="300" height="315" /></strong><sub>A kar&aacute;csonyfa teljes pomp&aacute;j&aacute;ban. Sajnos az eny&eacute;m (m&eacute;g) nem n&eacute;z ki &iacute;gy. A k&eacute;p forr&aacute;sa: <a title="#adventofcode" href="https:&#47;&#47;twitter.com/hashtag/adventofcode" target="_blank">Twitter</a></sub><strong><br /></strong></p>\r\n<p>A feladat, hogy az (Mikul&aacute;s &aacute;ltal) megadott utas&iacute;t&aacute;sok alapj&aacute;n fel/le kapcsolgassunk egy 1000x1000 &eacute;g&#337;b&#337;l &aacute;ll&oacute; vil&aacute;g&iacute;t&aacute;st. Az &eacute;g&#337;ket egy 1000x1000 m&eacute;ret&#369; t&aacute;bl&aacute;zatk&eacute;nt k&eacute;pzelhetj&uuml;k el, vagyis a sz&aacute;m&iacute;t&oacute;g&eacute;pen <em>1000x1000 m&eacute;ret&#369; m&aacute;trixk&eacute;nt,</em> azaz k&eacute;t dimenzi&oacute;s t&ouml;mbk&eacute;nt &aacute;br&aacute;zolhat&oacute; a h&aacute;zunk d&iacute;szkivil&aacute;g&iacute;t&aacute;sa. Ha a m&aacute;trix i. sor&aacute;nak j. eleme 0, akkor az azt jelenti, hogy az az elem nem vil&aacute;g&iacute;t az &eacute;g&#337;soron. Ha pedig az adott elem 1, akkor az &eacute;g&#337; vil&aacute;g&iacute;t. (Term&eacute;szetesen tetsz&#337;leges egy&eacute;b jel&ouml;l&eacute;st is haszn&aacute;lhatjunk: p&eacute;ld&aacute;ul a nem vil&aacute;g&iacute;t&aacute;s lehetne -1 is, vagy b&aacute;rmi egy&eacute;b, ak&aacute;rcsak a vil&aacute;g&iacute;t&aacute;s.) Vagyis v&aacute;laszthatn&aacute;nk a m&aacute;trixot ak&aacute;r <strong>boolean</strong> t&iacute;pus&uacute;ra is. Viszont ha kicsit el&#337;retekint&uuml;nk, l&aacute;thatjuk, hogy a m&aacute;sodik r&eacute;szben m&aacute;r k&uuml;l&ouml;nb&ouml;z&#337; f&eacute;nyintenzit&aacute;sokat t&aacute;rolunk. Ez&eacute;rt c&eacute;lszer&#369;bb az <strong>int</strong> t&iacute;pus.</p>\r\n<p>A bemeneti<em> f&aacute;jl beolvas&aacute;sa ugyan&uacute;gy soronk&eacute;nt</em> t&ouml;rt&eacute;nik, ahogy az 5. feladat megold&aacute;sa sor&aacute;n is. A beolvasott sort azonban<em> tov&aacute;bb sz&eacute;tv&aacute;ghatjuk</em>, megk&ouml;nny&iacute;tve a sz&ouml;veg feldolgoz&aacute;s&aacute;t. Erre lehet&#337;s&eacute;get ny&uacute;jt a Java nyelvben a <strong>String <a title="Split example - tutorialspoint.com" href="http:&#47;&#47;www.tutorialspoint.com/java/java_string_split.htm" target="_blank">split</a></strong> met&oacute;dusa, amely hasonl&oacute;an m&#369;k&ouml;dik, mint <a title="JS split - w3schools.com" href="http:&#47;&#47;www.w3schools.com/jsref/jsref_split.asp" target="_blank">Javascriptes testv&eacute;re</a> (amir&#337;l m&aacute;r volt sz&oacute; egy <a title="Advent of Code - 1-3. feladatok megold&aacute;sai" href="http:&#47;&#47;comsciblog.esy.es/article/55/Advent+of+Code+-+1-3.+feladatok+megold%C3%A1sai" target="_blank">el&#337;z&#337; bejegyz&eacute;sben</a>). C&eacute;lszer&#369; az adott sort (azaz Mikul&aacute;s-f&eacute;le utas&iacute;t&aacute;st) a sz&oacute;k&ouml;z&ouml;k &eacute;s a vessz&#337;k ment&eacute;n elv&aacute;gni, &iacute;gy az eredm&eacute;ny&uuml;l kapott t&ouml;mb minden eleme egy-egy sz&oacute; vagy sz&aacute;m lesz. Vagyis a</p>\r\n<pre><code>String[] arr = line.split("\\\\s|,");\r\n</code></pre>\r\n<p>sor seg&iacute;ts&eacute;g&eacute;vel pont ezt &eacute;rhetj&uuml;k el (ahol a line egy adott sor a sz&ouml;vegf&aacute;jlb&oacute;l): a <a title="String split - Java documentation" href="https:&#47;&#47;docs.oracle.com/javase/7/docs/api/java/lang/String.html#split(java.lang.String,%20int)" target="_blank"><strong>split</strong> </a>param&eacute;tere az elv&aacute;laszt&oacute; sz&ouml;vegr&eacute;sz, ami ment&eacute;n darabolunk. Ebben az esetben egy <a title="Regul&aacute;ris kifejez&eacute;s - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Regul%C3%A1ris_kifejez%C3%A9s" target="_blank">regul&aacute;ris kifejez&eacute;s</a>, ami whitespace (&apos;\\s&apos; sz&oacute;k&ouml;z, tabul&aacute;tor, vagy sort&ouml;r&eacute;s) karakterre vagy (&apos;|&apos;) vessz&#337; (&apos;,&apos;) karakterre illeszkedik.</p>\r\n<p>&Iacute;gy az <strong>arr</strong> t&ouml;mb akut&aacute;lis &eacute;rt&eacute;kei alapj&aacute;n eld&ouml;nthet&#337;, hogy mi t&ouml;rt&eacute;njen, &eacute;s melyik &eacute;g&#337;k&ouml;n. Ha &ouml;ssze szeretn&eacute;nk vonni a k&eacute;t r&eacute;szfeladatot (&eacute;s mi&eacute;rt ne szeretn&eacute;nk :) ), akkor lehet&#337;s&eacute;g&uuml;nk van<em> a felhaszn&aacute;l&oacute;t&oacute;l bek&eacute;rni, hogy melyik r&eacute;szfeladatot oldja meg</em>. &Iacute;gy kapunk egy sok param&eacute;teres <strong>changeLights</strong> met&oacute;dust, aminek viselked&eacute;se f&uuml;gg az &eacute;ppen beolvasott (Mikul&aacute;st&oacute;l kapott) utas&iacute;t&aacute;st&oacute;l, &eacute;s a felhaszn&aacute;l&oacute; &aacute;ltal (parancssori argumentumk&eacute;nt) megadott m&oacute;dt&oacute;l (1/2). Ezek alapj&aacute;n a main met&oacute;dus (term&eacute;szetesen egy csinos<strong> try-catch</strong> blokkon bel&uuml;l):</p>\r\n<pre><code>	fileName = args[0];\r\n	mode = Integer.parseInt(args[1]);\r\n			\r\n	&#47;&#47;reading input file\r\n	BufferedReader reader = new BufferedReader(new FileReader(fileName));\r\n	String line = "";\r\n	while((line = reader.readLine()) != null) \r\n	{\r\n		String[] arr = line.split("\\\\s|,"); &#47;&#47;split line to array\r\n		if (arr[0].equals("turn"))\r\n		{\r\n			int start_x = Integer.parseInt(arr[2]);\r\n			int start_y = Integer.parseInt(arr[3]);\r\n			int end_x = Integer.parseInt(arr[5]);\r\n			int end_y = Integer.parseInt(arr[6]);\r\n				\r\n			if (arr[1].equals("on") ) &#47;&#47;turn on\r\n				changeLights(start_x, start_y, end_x, end_y, 1, mode);\r\n			else &#47;&#47;turn off\r\n				changeLights(start_x, start_y, end_x, end_y, -1, mode);\r\n		}\r\n		else &#47;&#47;toggle\r\n		{\r\n			int start_x = Integer.parseInt(arr[1]);\r\n			int start_y = Integer.parseInt(arr[2]);\r\n			int end_x = Integer.parseInt(arr[4]);\r\n			int end_y = Integer.parseInt(arr[5]);\r\n			changeLights(start_x, start_y, end_x, end_y, 2, mode);\r\n		}\r\n } \r\n reader.close(); \r\n</code></pre>\r\n<p>A <strong>changeLights</strong> f&uuml;ggv&eacute;ny param&eacute;terei a jobb fels&#337; (<strong>start_x</strong>, <strong>start_y</strong>) illetve a bal als&oacute; (<strong>end_x</strong>, <strong>end_y</strong>) koordin&aacute;t&aacute;i. Ezeket a<em> Mikul&aacute;s utas&iacute;t&aacute;s&aacute;nak</em> megfelel&#337; r&eacute;szek&eacute;nt kapjuk. Mivel azonban ezek eredetileg <strong>String</strong> form&aacute;tumban vannak, az <strong>Integer</strong> oszt&aacute;ly <a title="Integer.parseInt - Java dokument&aacute;ci&oacute;" href="https:&#47;&#47;docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank"><strong>parseInt</strong> </a>met&oacute;dusa seg&iacute;ts&eacute;g&eacute;vel<em> eg&eacute;sz sz&aacute;mm&aacute; kell alak&iacute;tani</em>. A <strong>changeLights </strong><em>5. param&eacute;tere</em> egy sz&aacute;m amely jelzi, hogy az adott utas&iacute;t&aacute;s <em>turn on (1), turn off (-1), vagy toggle (2).</em> A <em>6. param&eacute;ter</em> pedig a mode param&eacute;ter, ami lehet 1 vagy 2, att&oacute;l f&uuml;gg&#337;en, hogy<em> az els&#337; vagy a m&aacute;sodik r&eacute;szfeladatra</em> vagyunk k&iacute;v&aacute;ncsiak.</p>\r\n<p>A m&aacute;sodik r&eacute;sz (mode param&eacute;ter = 2) ezek ut&aacute;n trivi&aacute;lis: csak <em>hozz&aacute; kell adni az 5. param&eacute;ter &eacute;rt&eacute;k&eacute;t</em> a megfelel&#337; &eacute;g&#337;k f&eacute;nyess&eacute;g&eacute;hez: vagyis amelyeknek x koordin&aacute;t&aacute;ja (v&iacute;zszintesen) <strong>start_x</strong> &eacute;s <strong>end_x</strong> k&ouml;z&ouml;tt, y koordin&aacute;t&aacute;ja (f&uuml;gg&#337;legesen) pedig <strong>start_y</strong> &eacute;s <strong>end_y</strong> k&ouml;z&ouml;tt van. Az els&#337; r&eacute;szfeladatn&aacute;l pedig ha 1-gyel jel&ouml;lj&uuml;k azt, hogy vil&aacute;g&iacute;t, -1-gyel pedig hogy nem, mind&ouml;ssze a toggle-vel kell foglalkozni: ha vil&aacute;g&iacute;t (1), akkor -1-re &aacute;ll&iacute;tjuk, egy&eacute;bk&eacute;nt +1-re.</p>\r\n<p style="text-align: center;"><br /><img class="img-responsive" class="img-responsive" style="margin: 0 auto 0;" src="http:&#47;&#47;comsciblog.esy.es/img/A-nagy-kar&aacute;csonyi-izz&oacute;csata-9.jpg" alt="R&eacute;szlet a Nagy kar&aacute;csonyi izz&oacute;csata c&iacute;m&#369; filmb&#337;l" width="500" height="333" align="center" /><br /><sub>R&eacute;szlet a Nagy kar&aacute;csonyi izz&oacute;csata c&iacute;m&#369; filmb&#337;l. A k&eacute;p forr&aacute;sa: <a href="http:&#47;&#47;www.mediaklikk.hu/2013/12/18/a-nagy-karacsonyi-izzocsata/" target="_blank">mediaklikk.hu</a></sub></p>\r\n<p><span style="text-decoration: underline;">Megjegyz&eacute;s:</span><br /><br />Mivel a Java az <strong>int</strong> v&aacute;ltoz&oacute;k<em> kezdeti &eacute;rt&eacute;k&eacute;t null&aacute;ra</em> &aacute;ll&iacute;tja be, ez&eacute;rt az els&#337; r&eacute;szfeladatn&aacute;l a nulla is azt jel&ouml;li, hogy nem az adott &eacute;g&#337; nem &eacute;g (mert az volt a kezdeti &aacute;llapot, hogy semmi sem vil&aacute;g&iacute;t), &eacute;s a -1 is. A 0-&aacute;s &eacute;s -1-es "nem vil&aacute;g&iacute;t" k&ouml;z&ouml;tt annyi a k&uuml;l&ouml;nbs&eacute;g, hogy a -1 eset&eacute;n m&aacute;r &eacute;gett az adott &eacute;g&#337;, &eacute;s mi kapcsoltuk le, m&iacute;g 0 eset&eacute;n hozz&aacute; sem ny&uacute;ltunk. Teh&aacute;t az els&#337; feladatr&eacute;sz eset&eacute;n<em> a vil&aacute;g&iacute;t&oacute; &eacute;g&#337;k 1-gyel</em> vannak jel&ouml;lve,<em> a nem vil&aacute;g&iacute;t&oacute; &eacute;g&#337;k pedig NEM 1-gyel.<br /></em></p>\r\n<p>A feladat v&eacute;g&eacute;n pedig &iacute;rhatunk egy-egy <em>&ouml;sszesz&aacute;ml&aacute;l&oacute; f&uuml;ggv&eacute;nyt (</em><strong>countLightnings</strong><em>, </em><strong>totalBrightness</strong><em>)</em>, amelyek megadj&aacute;k a v&aacute;laszt a k&eacute;rd&eacute;s&uuml;nkre: az els&#337; r&eacute;szfeladat (mode param&eacute;ter = 1) eset&eacute;n sz&aacute;moljuk &ouml;ssze a m&aacute;trix egyeseit, m&iacute;g a m&aacute;sodik (mode param&eacute;ter = 2) esetben adjuk &ouml;ssze a m&aacute;trix minden elem&eacute;t, hogy megkapjuk a teljes f&eacute;nyess&eacute;get. Ezek alapj&aacute;n a megold&aacute;s teljes forr&aacute;sk&oacute;dja:</p>\r\n<pre><code>import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class ChristmasLights\r\n{\r\n	static int[][] lights = new int[1000][1000];\r\n	static String fileName = "";\r\n	static int mode = 1;\r\n	\r\n	public static void main(String args[])\r\n	{\r\n		try \r\n		{\r\n			fileName = args[0]; &#47;&#47;input file name - argument 1\r\n			mode = Integer.parseInt(args[1]); &#47;&#47;mode - argument 2 (1/2 value)\r\n			\r\n			&#47;&#47;reading input file\r\n			BufferedReader reader = new BufferedReader(new FileReader(fileName));\r\n			String line = "";\r\n			while((line = reader.readLine()) != null) \r\n			{\r\n				String[] arr = line.split("\\\\s|,"); &#47;&#47;split line to array\r\n				if (arr[0].equals("turn"))\r\n				{\r\n					int start_x = Integer.parseInt(arr[2]);\r\n					int start_y = Integer.parseInt(arr[3]);\r\n					int end_x = Integer.parseInt(arr[5]);\r\n					int end_y = Integer.parseInt(arr[6]);\r\n				\r\n					if (arr[1].equals("on") ) &#47;&#47;turn on\r\n						changeLights(start_x, start_y, end_x, end_y, 1, mode);\r\n					else &#47;&#47;turn off\r\n						changeLights(start_x, start_y, end_x, end_y, -1, mode);\r\n				}\r\n				else &#47;&#47;toggle\r\n				{\r\n					int start_x = Integer.parseInt(arr[1]);\r\n					int start_y = Integer.parseInt(arr[2]);\r\n					int end_x = Integer.parseInt(arr[4]);\r\n					int end_y = Integer.parseInt(arr[5]);\r\n					changeLights(start_x, start_y, end_x, end_y, 2, mode);\r\n				}\r\n		 } \r\n reader.close(); \r\n if (mode==1)\r\n 	System.out.println("Lighting lights: "+countLightings());\r\n else\r\n 	System.out.println("Total brightness: "+totalBrightness() );\r\n		}\r\n		catch (FileNotFoundException ex)\r\n		{\r\n			System.out.println("File not found: "+fileName);\r\n			ex.printStackTrace();\r\n		}\r\n		catch (IOException ex)\r\n		{\r\n			System.out.println("Error while reading file: "+fileName);\r\n			ex.printStackTrace();\r\n		}\r\n		catch (IndexOutOfBoundsException ex)\r\n		{\r\n			System.out.println("Program&apos;s arguments: Input file name, Mode: 1 - count lights, 2 - count total brightness");\r\n			ex.printStackTrace();\r\n		}\r\n		\r\n		catch (Exception ex)\r\n		{\r\n			System.out.println("Fatal error!");\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n		\r\n	public static void changeLights(int start_x, int start_y, int end_x, int end_y, int sign, int mode)\r\n	{\r\n		for (int x=start_x; x&lt;=end_x; ++x)\r\n		{\r\n			for (int y=start_y; y&lt;=end_y; ++y)\r\n			{\r\n				if (mode==1)\r\n				{\r\n					if (sign==2)\r\n					{\r\n						if (lights[x][y]==1)\r\n							lights[x][y] = -1;\r\n						else \r\n							lights[x][y] = 1;\r\n					}\r\n					else \r\n						lights[x][y] = sign;\r\n				}\r\n				else if (mode==2) \r\n				{\r\n					lights[x][y]+=sign;\r\n					if (lights[x][y] &lt; 0)\r\n						lights[x][y] = 0;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	\r\n	/** Count lightnings (used in mode 1) */\r\n	public static int countLightings()\r\n	{\r\n		int count = 0;\r\n		for (int i=0; i&lt;lights.length; ++i)\r\n		{\r\n			for (int j=0; j&lt;lights[i].length; ++j)\r\n			{\r\n			 if (lights[i][j]==1)\r\n			 	++count;\r\n			 }\r\n	 }\r\n	 return count;\r\n	}\r\n		\r\n	/** Count total brightness (used in mode 2) */\r\n	public static int totalBrightness()\r\n	{\r\n		int total = 0;\r\n		for (int i=0; i&lt;lights.length; ++i)\r\n		{\r\n			for (int j=0; j&lt;lights[i].length; ++j)\r\n			{\r\n				total+=lights[i][j];\r\n			}\r\n	 }\r\n	 return total;\r\n	}\r\n	\r\n}<br /><br />A megold&aacute;som forr&aacute;sk&oacute;dj&aacute;t felt&ouml;lt&ouml;ttem a <a title="A feladat megold&aacute;s&aacute;nak teljes Java forr&aacute;sk&oacute;dja" href="http:&#47;&#47;pastebin.com/Mg1bG5YV" target="_blank">Pastebin.com</a> oldalra is. Aki ellen&aacute;lhatatlan v&aacute;gyat &eacute;rez a k&oacute;dom olvas&aacute;s&aacute;ra, akkor rajtam ne m&uacute;ljon az &ouml;r&ouml;me. :)</code></pre>', '2015-12-29 08:17:13', '2015-12-29 09:15:03'),
(59, 'comsciblog', 'ArnoldC - HASTA LA VISTA, BABY', 'hu', '<p style="text-align: left;"><strong>B&aacute;r a 2015. &eacute;v ugyan v&eacute;get &eacute;rt, aggodalomra azonban semmi ok, mivel lett helyette &uacute;jabb, nevezetesen a 2016. Boldog &uacute;j &eacute;vet k&iacute;v&aacute;nok mindenkinek! (Annak is, aki augusztusban tal&aacute;l r&aacute; a blogra.) A mai bejegyz&eacute;semben az ArnoldC nev&#369; programoz&aacute;si nyelvvel ismerkedhet meg az olvas&oacute;. A nev&eacute;t feltehet&#337;leg onnan kapta, hogy a nyelv elemei a vil&aacute;gh&iacute;r&#369; test&eacute;p&iacute;t&#337;/sz&iacute;n&eacute;sz/korm&aacute;nyz&oacute; Arnold Schwarzenegger <a title="Arnold Schwarzenegger quotes - video" href="https:&#47;&#47;www.youtube.com/watch?v=pDxn0Xfqkgw" target="_blank">filmes aranyk&ouml;p&eacute;seib&#337;l</a> &aacute;llnak. Ezt az ezoterikus programoz&aacute;si nyelvet egy viszonylag egyszer&#369; programon mutatom be: a&nbsp;<a title="Problem 1 - Project Euler" href="https:&#47;&#47;projecteuler.net/problem=1" target="_blank">Project Euler 1.</a> feladat&aacute;n.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/terminator.jpg" alt="Arnold Schwarzenegger a Termin&aacute;tor szerep&eacute;ben" width="600" height="338" /> </strong> <br /> <small>A sz&iacute;n&eacute;sz, aki n&eacute;lk&uuml;l nem j&ouml;hetett volna l&eacute;tre ez a programoz&aacute;si nyelv, avagy egy &aacute;tlagos &eacute;letk&eacute;p egy &aacute;tlagos Termin&aacute;tor &aacute;tlagos napj&aacute;b&oacute;l. (A k&eacute;p forr&aacute;sa:<a href="http:&#47;&#47;www.blastr.com/2014-10-30/heres-our-first-official-look-arnolds-aging-terminator-genisys" target="_blank"> blastr.com</a>)</small></p>\r\n<p>A feladat elkezd&eacute;s&eacute;hez el&#337;sz&ouml;r is szerezz&uuml;nk be egy <strong>ArnoldC ford&iacute;t&oacute;t</strong>! Ehhez nagyszer&#369; seg&iacute;ts&eacute;get ny&uacute;jt <a title="ArnoldC implement&aacute;ci&oacute;" href="https:&#47;&#47;github.com/lhartikk/ArnoldC" target="_blank">ez a repository a GitHubon</a> . Itt r&ouml;gt&ouml;n megtal&aacute;ljuk a dokument&aacute;ci&oacute;j&aacute;nak egy r&eacute;sz&eacute;t is. A Quickstart c&iacute;msz&oacute; alatt seg&iacute;ts&eacute;get tal&aacute;lunk a haszn&aacute;lat&aacute;ra. Mind&ouml;ssze annyi a dolgunk, hogy let&ouml;ltj&uuml;k az <a title="ArnoldC.jar let&ouml;lt&eacute;se..." href="http:&#47;&#47;lhartikk.github.io/ArnoldC.jar" target="_blank">ArnoldC.jar</a> nev&#369; Java &aacute;llom&aacute;nyt (Linux eset&eacute;ben a <strong>wget</strong> is haszn&aacute;lhat&oacute;, de &uacute;gy is let&ouml;lthetj&uuml;k [tetsz&#337;leges rendszerre], ha a b&ouml;ng&eacute;sz&#337;nk c&iacute;msor&aacute;ba &iacute;rjuk az el&eacute;r&eacute;si utat <a title="ArnoldC.jar let&ouml;lt&eacute;se..." href="http:&#47;&#47;lhartikk.github.io/ArnoldC.jar" target="_blank">http:&#47;&#47;lhartikk.github.io/ArnoldC.jar</a>). Ez a futtathat&oacute; Java arch&iacute;vum a <em>ford&iacute;t&oacute;program</em>, aminek ha parancssori argumentumk&eacute;nt &aacute;tadjuk az ArnoldC forr&aacute;sk&oacute;dunk nev&eacute;t &eacute;s lefuttatjuk (<strong>java -jar</strong> parancs), leford&iacute;thatjuk a forr&aacute;sk&oacute;dunk. <em>A kapott t&aacute;rgyk&oacute;d egy Java oszt&aacute;ly</em>, amit a java paranccsal futtathatunk. Rem&eacute;nyeim szerint az itt le&iacute;rtak, &eacute;s a <a title="ArnoldC Quickstart" href="https:&#47;&#47;github.com/lhartikk/ArnoldC#quick-start" target="_blank">GitHubos dokument&aacute;ci&oacute;</a> alapj&aacute;n mindenkinek siker&uuml;lt egy <em>Hello World</em> programot &iacute;rnia &eacute;s lefuttatnia.</p>\r\n<h3>Megjegyz&eacute;s</h3>\r\n<p>Nem teljesen &eacute;rtem, mi&eacute;rt az ArnoldC nevet kapta. Od&aacute;ig rendben van, hogy kedvenc akci&oacute;h&#337;s&uuml;nk besz&oacute;l&aacute;saib&oacute;l &eacute;p&iacute;tett&eacute;k fel a teljes nyelvet. Viszont els&#337; r&aacute;n&eacute;z&eacute;sre semmi k&ouml;ze a C-hez (&eacute;s m&aacute;sodikra sincs). Technikailag k&ouml;zelebb &aacute;ll a Javahoz, mivel a ford&iacute;t&oacute;program is Java arch&iacute;vum, &eacute;s a ford&iacute;t&aacute;s eredm&eacute;nye, a futtathat&oacute; &aacute;llom&aacute;ny is Java oszt&aacute;ly. Teh&aacute;t <span style="text-decoration: line-through;">Schwarzi</span> a korm&aacute;nyz&oacute; &uacute;r mondatai Java nyelvre fordulnak. Lehet, hogy az ArnoldJava nem cseng olyan j&oacute;l?</p>\r\n<h3>T&eacute;rj&uuml;nk r&aacute; a feladatra!</h3>\r\n<p>A feladat: Keress&uuml;k meg az 1000 alatti, 3-mal vagy 5-tel sz&aacute;mok &ouml;sszeg&eacute;t!<br /> Mivel nem vagyunk profik az ArnoldC szintaktik&aacute;j&aacute;ban, ez&eacute;rt megn&eacute;zz&uuml;k a <a title="ArnoldC dokument&aacute;ci&oacute;" href="https:&#47;&#47;github.com/lhartikk/ArnoldC/wiki/ArnoldC" target="_blank">teljes dokument&aacute;ci&oacute;t a wiki f&uuml;l&ouml;n</a>. Ezek alapj&aacute;n tudunk v&aacute;ltoz&oacute;kat deklar&aacute;lni &eacute;s &eacute;rt&eacute;ket adni nekik; v&eacute;gre tudjuk hajtani a n&eacute;gy alapvet&#337; aritmetikai (+,-,*,/) valamint n&eacute;h&aacute;ny logikai m&#369;veletet. Haszn&aacute;lhatunk felt&eacute;telt, ciklust, s&#337;t szubrutint is!</p>\r\n<p>A feladat sor&aacute;n minden 1 &eacute;s 1000 k&ouml;z&ouml;tti sz&aacute;mot v&eacute;gig kell vizsg&aacute;lni: sz&uuml;ks&eacute;g van teh&aacute;t egy ciklusra 1-t&#337;l 1000-ig (<strong>STICK AROUND</strong>), egy felt&eacute;telre (<strong>BECAUSE I&apos;M GOING TO SAY PLEASE</strong>), ami teljes&uuml;l, <em>ha az adott sz&aacute;m oszthat&oacute;(!!!) 3-mal vagy 5-tel</em>. Vagyis tudnunk kellene, hogy 3-mal (vagy 5-tel) osztva nulla-e a marad&eacute;k. <em>Ilyen m&#369;velet&uuml;nk azonban nincs.</em> <span style="text-decoration: underline;">Viszont k&ouml;nnyed&eacute;n megval&oacute;s&iacute;that&oacute;:</span> Tegy&uuml;k fel, hogy $a$ &eacute;s $b$ oszt&aacute;si marad&eacute;k&aacute;t keress&uuml;k, &eacute;s k&eacute;pesek vagyunk marad&eacute;k n&eacute;lk&uuml;li oszt&aacute;sra, szoroz&aacute;sra &eacute;s kivon&aacute;sra. Ebben az esetben keress&uuml;k meg a h&aacute;nyadosuk eg&eacute;szr&eacute;sz&eacute;t, $[\\frac{a}{b}]$. Legyen az mondjuk $q$ (quotient). Majd az &iacute;gy kapott $q$ sz&aacute;mot szorozzuk meg az oszt&oacute;val ($b$-vel), &eacute;s ezt az &iacute;gy kapott sz&aacute;mot vonjuk ki az osztand&oacute;b&oacute;l ($a$-b&oacute;l), &eacute;s m&aacute;r meg is van az oszt&aacute;si marad&eacute;k! Ez az elve a <a title="Modulo f&uuml;ggv&eacute;ny ArnoldC nyelven" href="https:&#47;&#47;github.com/lhartikk/ArnoldC/wiki/ArnoldC#declaring-a-modulo-function-and-using-it-from-the-main-method" target="_blank">modulo f&uuml;ggv&eacute;nynek a dokument&aacute;ci&oacute;</a>&nbsp;p&eacute;ld&aacute;j&aacute;ban. De &eacute;n nem haszn&aacute;ltam ezt (m&aacute;r csak az&eacute;rt sem).</p>\r\n<p>A feladat azonban<em> megoldhat&oacute; marad&eacute;kos oszt&aacute;s n&eacute;lk&uuml;l is</em>: Adjuk &ouml;ssze a sz&aacute;mokat 0-t&oacute;l 1000-ig <em>h&aacute;rmas&aacute;val</em>, majd <em>&ouml;t&ouml;s&eacute;vel</em> l&eacute;pkedve, majd adjuk &ouml;ssze az &iacute;gy kapott k&eacute;t sz&aacute;mot! &Iacute;gy megvannak azok a sz&aacute;mok, amelyek oszthat&oacute;k 3-mal vagy 5-tel. Viszont <em>minden 15-tel oszthat&oacute;t k&eacute;tszer sz&aacute;moltunk</em>! Ez&eacute;rt &uacute;jb&oacute;l v&eacute;gig kell menni a sz&aacute;mokon tizen&ouml;t&ouml;s&eacute;vel l&eacute;pkedve, &eacute;s <em>ki kell vonni</em> a kapott &ouml;sszegb&#337;l. Egy ilyen ciklus e csod&aacute;s nyelven &iacute;gy valahogy &iacute;gy fest:</p>\r\n<pre><code>	STICK AROUND isLessThan1000		\r\n		GET TO THE CHOPPER number\r\n		HERE IS MY INVITATION number\r\n		GET UP 3\r\n		ENOUGH TALK\r\n		\r\n		GET TO THE CHOPPER isLessThan1000\r\n		HERE IS MY INVITATION 1000\r\n		LET OFF SOME STEAM BENNET number\r\n		ENOUGH TALK\r\n		\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET UP number\r\n		ENOUGH TALK\r\n	CHILL\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET DOWN number\r\n		ENOUGH TALK\r\n</code></pre>\r\n<p>Az <strong>isLessThan1000</strong> egy logikai v&aacute;ltoz&oacute;, ami kezdetben <strong>IGAZ</strong>, a number pedig a ciklusv&aacute;loz&oacute;, a null&aacute;t&oacute;l indul. A ciklus felt&eacute;tele az isLessThan1000, ami <strong>HAMIS</strong> &eacute;rt&eacute;ket kap, ha $number&gt;1000$ (<strong>LET OFF SOME STEAM BENNET</strong>). Mivel azonban az utols&oacute; iter&aacute;ci&oacute; sor&aacute;n m&aacute;r <em>a legels&#337; 1000-n&eacute;l nagyobb h&aacute;rommal oszthat&oacute; sz&aacute;mot is hozz&aacute;adunk</em> (1002), ez&eacute;rt ezt ki kell vonni. A m&aacute;sik k&eacute;t ciklus hasonl&oacute;. A teljes k&oacute;d:</p>\r\n<pre><code>IT&apos;S SHOWTIME\r\n &#47;&#47; isLessThan := tru,e number := 0, sum := 0 \r\n	HEY CHRISTMAS TREE isLessThan1000\r\n	YOU SET US UP @NO PROBLEMO \r\n	HEY CHRISTMAS TREE number\r\n	YOU SET US UP 0\r\n	HEY CHRISTMAS TREE sum\r\n	YOU SET US UP 0\r\n		\r\n	&#47;&#47;ciklus harmasaval lepkedve (+3)\r\n	STICK AROUND isLessThan1000		\r\n		GET TO THE CHOPPER number\r\n		HERE IS MY INVITATION number\r\n		GET UP 3\r\n		ENOUGH TALK\r\n		\r\n		GET TO THE CHOPPER isLessThan1000\r\n		HERE IS MY INVITATION 1000\r\n		LET OFF SOME STEAM BENNET number\r\n		ENOUGH TALK\r\n		\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET UP number\r\n		ENOUGH TALK\r\n	CHILL\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET DOWN number\r\n		ENOUGH TALK\r\n	\r\n	&#47;&#47;valtozok visszaallitasa\r\n	GET TO THE CHOPPER number\r\n	HERE IS MY INVITATION number\r\n	GET DOWN number\r\n	ENOUGH TALK\r\n	\r\n	GET TO THE CHOPPER isLessThan1000\r\n	HERE IS MY INVITATION isLessThan1000\r\n	GET DOWN 1\r\n	ENOUGH TALK\r\n\r\n 	&#47;&#47;ciklus otosevel lepkedve (+5)\r\n	STICK AROUND isLessThan1000\r\n		GET TO THE CHOPPER number\r\n		HERE IS MY INVITATION number\r\n		GET UP 5\r\n		ENOUGH TALK\r\n		\r\n		GET TO THE CHOPPER isLessThan1000\r\n		HERE IS MY INVITATION 1000\r\n		LET OFF SOME STEAM BENNET number\r\n		ENOUGH TALK\r\n			\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET UP number\r\n		ENOUGH TALK\r\n	CHILL\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET DOWN number\r\n		ENOUGH TALK\r\n\r\n	&#47;&#47;valtozok visszaallitasa\r\n	GET TO THE CHOPPER number\r\n	HERE IS MY INVITATION number\r\n	GET DOWN number\r\n	ENOUGH TALK\r\n	\r\n	GET TO THE CHOPPER isLessThan1000\r\n	HERE IS MY INVITATION isLessThan1000\r\n	GET DOWN 1\r\n	ENOUGH TALK\r\n	\r\n	&#47;&#47;ciklus tizenotosevel lepkedve, kivonva az osszegbol (-15)\r\n	STICK AROUND isLessThan1000\r\n\r\n		GET TO THE CHOPPER number\r\n		HERE IS MY INVITATION number\r\n		GET UP 15\r\n		ENOUGH TALK\r\n				\r\n		GET TO THE CHOPPER isLessThan1000\r\n		HERE IS MY INVITATION 1000\r\n		LET OFF SOME STEAM BENNET number\r\n		ENOUGH TALK\r\n		\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET DOWN number\r\n		ENOUGH TALK\r\n	CHILL\r\n		GET TO THE CHOPPER sum\r\n		HERE IS MY INVITATION sum\r\n		GET UP number\r\n		ENOUGH TALK\r\n	\r\n	TALK TO THE HAND "SUM: "\r\n	TALK TO THE HAND sum\r\nYOU HAVE BEEN TERMINATED\r\n</code></pre>\r\n<h3>Megjegyz&eacute;s</h3>\r\n<p>A fenti programban j&oacute;l l&aacute;that&oacute;, hogy h&aacute;romszor v&eacute;geztem el szinte ugyanazt a m&#369;veletet, m&aacute;s param&eacute;terekkel. Mivel az ArnoldC is ad lehet&#337;s&eacute;get a f&uuml;ggv&eacute;nyek &iacute;r&aacute;s&aacute;ra (<strong>LISTEN ME CAREFULLY</strong>), &iacute;gy<em> &iacute;rhatunk egy &ouml;sszegz&#337; f&uuml;ggv&eacute;nyt</em> (<strong>sumFunction</strong>). A f&uuml;ggv&eacute;ny&uuml;nknek param&eacute;terk&eacute;nt &aacute;tadhat&oacute; a jelenlegi &ouml;sszeg (<strong>sum</strong>), a l&eacute;p&eacute;s m&eacute;rete (<strong>step</strong>), valamint az, hogy &ouml;sszeadni vagy kivonni szeretn&eacute;nk-e (<strong>isNegative</strong>). A f&#337; f&uuml;ggv&eacute;ny&uuml;nk (<strong>IT&apos;S SHOWTIME</strong>) ett&#337;l sokat leegyszer&#369;s&ouml;dik, &eacute;s a teljes k&oacute;d is valamivel r&ouml;videbb lesz, mivel <em>a ciklust csak egyszer &iacute;rtuk meg</em> (igaz n&eacute;mi plusz logik&aacute;val), &eacute;s a v&aacute;ltoz&oacute;k (<strong>number, isNegative</strong>) vissza&aacute;ll&iacute;t&aacute;s&aacute;t is megtakar&iacute;tottuk (b&aacute;r a f&uuml;ggv&eacute;ny deklar&aacute;l&aacute;sa jelent p&aacute;r sort). Az &iacute;gy kapott m&oacute;dos&iacute;tott programom el&eacute;rhet&#337; a <a title="ArnoldC Project Euler 1 - f&uuml;ggv&eacute;nnyel" href="http:&#47;&#47;pastebin.com/FJ7hQ5YZ" target="_blank">Pastebinen</a>.</p>\r\n<h3>&Uacute;jabb Megjegyz&eacute;s&nbsp;</h3>\r\n<p>A nyelvben <em>nem m&#369;k&ouml;dnek a megjegyz&eacute;s sorok</em>, &iacute;gy c&eacute;lszer&#369; &#337;ket kivenni futtat&aacute;skor. Csak az&eacute;rt &iacute;rtam, hogy &eacute;rhet&#337;bb legyen a k&oacute;d. Ezen k&iacute;v&uuml;l m&eacute;g felt&#369;nt, hogy a dokument&aacute;ci&oacute; szerint az egyetlen adatt&iacute;pus a <em>16 bites el&#337;jel n&eacute;lk&uuml;li eg&eacute;sz</em>. Viszont a feladat eredm&eacute;nye <em>233168, </em>ami<em> nem &aacute;br&aacute;zolhat&oacute; 16 biten</em>. Viszont a program(ok) j&oacute; eredm&eacute;nyt ad(nak), ez&eacute;rt &eacute;n gyan&iacute;tom, hogy legal&aacute;bb 32 bites sz&aacute;mokkal dolgozik.</p>', '2016-01-05 11:27:13', '2016-01-05 12:14:22'),
(60, 'comsciblog', 'Java vs C++ - Advent of Code 10', 'hu', '<p><strong>B&aacute;r m&aacute;r r&eacute;gen elm&uacute;ltak az &uuml;nnepek, ma ism&eacute;t egy Advent of Code feladatr&oacute;l fogok &iacute;rni. A megval&oacute;s&iacute;t&aacute;shoz a Java &eacute;s a C++ programoz&aacute;si nyelvet egyar&aacute;nt haszn&aacute;lni fogom. Egy&uacute;ttal valamilyen szinten &ouml;ssze is hasonl&iacute;that&oacute; a k&eacute;t technol&oacute;gia hat&eacute;konys&aacute;ga. A feladat a <a title="Look and say sequence - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Look-and-say_sequence" target="_blank">Look-and-say</a> ("Mondd, amit l&aacute;tsz") j&aacute;t&eacute;k megval&oacute;s&iacute;t&aacute;sa, 50 cikluson kereszt&uuml;l, egy megadott kezdeti sorozatra. Vagyis tele lesz stringm&#369;veletekkel. Ebb&#337;l tal&aacute;n a Jav&aacute;ban j&aacute;rtasabbak m&aacute;r r&aacute; is j&ouml;hettek, hogy milyen hib&aacute;ba futottam bele a Java implement&aacute;ci&oacute; sor&aacute;n.<br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/cpp_vs_java.jpg" alt="C++ a Java ellen - az &uacute;j film hamarosan a mozikban." width="420" height="317" /></strong>C++ a Java ellen - az &uacute;j film hamarosan a mozikban. A k&eacute;p a <a title="Which language is better C++ or Java" href="http:&#47;&#47;groupinfo4u.com/language-better-c-java/" target="_blank">groupinfo4u.com</a> oldalr&oacute;l sz&aacute;rmazik. &Eacute;rdemes elolvasni a hozz&aacute; tartoz&oacute; bejegyz&eacute;st is azon az oldalon.<strong><br /></strong></p>\n<h3>Teh&aacute;t a feladat:</h3>\n<p>A mai napon a Mikul&aacute;s man&oacute;i (mivel m&aacute;r elm&uacute;ltak az &uuml;nnepek, &eacute;s semmi dolguk) a <a title="Look and Say sequence - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Look-and-say_sequence" target="_blank">Look-and-say</a> ("Mondd, amit l&aacute;tsz") j&aacute;t&eacute;kot j&aacute;tssz&aacute;k. Vagyis &uacute;gy &eacute;p&iacute;tenek fel sz&aacute;msorozatokat, hogy hangosan <em>felolvass&aacute;k a l&aacute;tott sz&aacute;msorozatot, &eacute;s a kimondott sz&aacute;mokat hozz&aacute;f&#369;zik</em> a sorozathoz. P&eacute;ld&aacute;ul 21122 felolvasva "egy kettes, k&eacute;t egyes &eacute;s k&eacute;t kettes", vagyis 122122. (1 2, 2 1, 2 2). Az ilyen sorozatok iterat&iacute;van gener&aacute;l&oacute;dnak, vagyis az el&#337;z&#337;leg megkapott &eacute;rt&eacute;ket haszn&aacute;lj&aacute;k a k&ouml;vetkez&#337; l&eacute;p&eacute;s inputjak&eacute;nt. Minden l&eacute;p&eacute;sben veszik az el&#337;z&#337; &eacute;rt&eacute;ket, &eacute;s kicser&eacute;lik az ism&eacute;tl&#337;d&#337; sz&aacute;msorozatokat (111) a sz&aacute;mjegyek sz&aacute;m&aacute;val (3), amit maga a sz&aacute;mjegy k&ouml;vet (1).</p>\n<p><span style="text-decoration: underline;">P&eacute;ld&aacute;ul:</span> az"1" kezdeti sorozatb&oacute;l "11" lesz ("egy egyes"), amit hozz&aacute;f&#369;z&uuml;nk a kezdeti sorozathoz, &iacute;gy az els&#337; l&eacute;p&eacute;s eredm&eacute;nye "111". Ebb&#337;l "31" lesz ("h&aacute;rom egyes"), amit hozz&aacute;f&#369;zve az el&#337;z&#337;h&ouml;z az eredm&eacute;ny "11131". Az &ouml;sszes t&ouml;bbi l&eacute;p&eacute;s &iacute;gy zajlik. Vagyis az "11131" kimondva "h&aacute;rom egyes, egy h&aacute;rmas &eacute;s egy egyes", vagyis "311311", &iacute;gy az 3. ciklus eredm&eacute;nye "11131"+"311311" = "11131311311", &eacute;s &iacute;gy tov&aacute;bb.</p>\n<p><span style="text-decoration: underline;">K&eacute;rd&eacute;s:</span> a megadott "1113122113" kezdeti sorozat eset&eacute;n h&aacute;ny sz&aacute;mjegy&#369; lesz az &ouml;tvenedik ilyen ciklus eredm&eacute;nye?</p>\n<p><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/santa_elves.gif" alt="A Mikul&aacute;s man&oacute;i szorgalmasan dolgoznak." width="550" height="219" /></p>\n<p>A feladat teh&aacute;t viszonylag egyszer&#369;en leprogramozhat&oacute;: vegy&uuml;k el&#337; a Java ford&iacute;t&oacute;nkat, vagy a kedvenc Java-fejleszt&eacute;sre alkalmas integr&aacute;lt feljeszt&#337;i eszk&ouml;z&uuml;nket (IDE), &eacute;s &iacute;rjuk meg a forr&aacute;sk&oacute;dot. Valami ilyesmi k&oacute;dot &iacute;rhatunk:</p>\n<pre><code>\npublic class LookAndSay\n{\n	public static void main(String args[])\n	{\n		String number = "1113122113";\n		int maxCycles = 50;\n		\n		for (int cycle=1; cycle&lt;=maxCycles; ++cycle) &#47;&#47;50 ciklus\n		{\n			String newNum = new String(); &#47;&#47;minden ciklusban uj, ures Stringet hoz letre, az uj szam tarolasara.\n			&#47;&#47;Vegignezi az adott ciklus \n			for (int i=0; i&lt;number.length(); /* direkt nincs ciklusvaltozo noveles!*/)\n			{\n				char symbol = number.charAt(i);\n				&#47;&#47;Megszamlalja, hany egymast koveto szimbolum van az i. karakterbol\n				int symbolCount = 0;\n				while (i&lt;number.length() &amp;&amp; number.charAt(i)==symbol) \n				{\n					++i; &#47;&#47;a ciklusvoltozot itt noveli, amikor az egymast koveto szimbolumokat vizsgalja!\n					++symbolCount;\n				}\n				newNum+=Integer.toString(symbolCount);\n				newNum+=symbol;\n			}\n			number = newNum; &#47;&#47;a jelenlegi szamunk legyen a kovetkezo szam (uj ciklus)\n			System.out.println(cycle+". number: "+number.length());\n		}\n	}\n}\n</code> </code></pre>\n<p>A forr&aacute;sk&oacute;dhoz nem tudok t&uacute;l sokat hozz&aacute;tenni: ugyanazt csin&aacute;lja, amit a man&oacute;k, mikor j&aacute;tssz&aacute;k ezt a j&aacute;t&eacute;kot. A k&uuml;ls&#337; <strong>for</strong> ciklus egy-egy j&aacute;t&eacute;kmenetet, j&aacute;t&eacute;kciklust jel&ouml;l. Azon bel&uuml;l minden k&ouml;rben v&eacute;gign&eacute;zik az adott sz&aacute;mot sz&aacute;mjegyenk&eacute;nt (bels&#337; <strong>for</strong>), &eacute;s am&iacute;g ugyanazt a sz&aacute;mjegyet l&aacute;tj&aacute;k, az ujjukon sz&aacute;molnak (<strong>while - symbolCount</strong>). Majd kimondj&aacute;k, amennyit sz&aacute;moltak, illetve amit. A v&eacute;g&eacute;n pedig az el&#337;z&#337; sz&aacute;msorozat v&eacute;g&eacute;re &iacute;rj&aacute;k a kimondott sz&aacute;msorozatot.<br /><br />Ezek ut&aacute;n a gondos programoz&oacute;nak nincs m&aacute;s dolga, mint lefuttatni, &eacute;s <em>v&aacute;rni, v&aacute;rni, v&aacute;rni</em>. &Eacute;s m&eacute;g tov&aacute;bb v&aacute;rni... Majd &uacute;gy 3 &oacute;ra v&aacute;rakoz&aacute;s ut&aacute;n <em>kil&#337;ni a folyamatot</em>, &eacute;s hiretelen felindul&aacute;sb&oacute;l C++-ban is meg&iacute;rni ugyanezt:</p>\n<pre><code>\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\nusing namespace std;\n\nstring to_string(int number)\n{\n stringstream ss;\n ss&lt;&lt;number;\n return ss.str();\n}\n\nint main(int argc, char ** argv)\n{\n    string number = "1113122113";\n     cout&lt;&lt;number&lt;&lt;endl;\n     int maxCycles = 50, cycle = 1, i=0;\n\n     for (cycle=1; cycle&lt;=maxCycles; ++cycle)\n     {\n         string newNum = "";\n         for (i=0; i&lt;number.size(); )\n         {\n             char symbol = number[i];\n            int symbolCount = 0;\n           while (i&lt;number.size() &amp;&amp; number[i]==symbol)\n           {\n              ++i;\n              ++symbolCount;\n            }\n\n          newNum += to_string(symbolCount);\n          newNum += symbol;\n     }\n     number = newNum; &#47;&#47;new number to current\n     cout&lt;&lt;cycle&lt;&lt;". number length: "&lt;&lt;number.size()&lt;&lt;endl;\n   }\n  return 0;\n}\n</code></pre>\n<p>Az algoritmus teh&aacute;t ugyanaz, mind&ouml;ssze a programoz&aacute;si nyelv m&aacute;s. F&eacute;lve lefuttatjuk, majd csod&aacute;k csod&aacute;j&aacute;ra nagyj&aacute;b&oacute;l 18 m&aacute;sodperc ut&aacute;n megkapjuk a helyes eredm&eacute;nyt! <em>De h&aacute;t mi lehet a baja a Java programnak</em>? Ugyanazon az elven m&#369;k&ouml;dik, mint a C++, &eacute;s kevesebb ciklus eset&eacute;n ugyanolyan j&oacute; v&aacute;laszt ad. Ennyivel rosszabb a hat&eacute;konys&aacute;ga a Jav&aacute;nak?</p>\n<p>Az &ouml;rd&ouml;g a r&eacute;szletekben rejlik: a Java Stringek ugyanis <em>megv&aacute;ltoztathatatlanok</em>. Amikor a programoz&oacute; <span style="text-decoration: underline;">hozz&aacute;f&#369;zne</span> egy <strong>s1</strong> Stringhez egy m&aacute;sikat (<strong>s2</strong>), a Java l&eacute;trehoz egy harmadik ("l&aacute;thatatlan <strong>s3</strong>") Stringet, aminek &eacute;rt&eacute;k&uuml;l adja<strong> s1+s2</strong> &ouml;sszef&#369;z&ouml;tt &eacute;rt&eacute;k&eacute;t, majd ezt &eacute;rt&eacute;k&uuml;l adja <strong>s1</strong>-nek. Ha ezt sokszor v&eacute;grehajtjuk, az sok adatmozgat&aacute;ssal j&aacute;r, ami miatt nem lesz t&uacute;l hat&eacute;kony a programunk.</p>\n<p>Szerencs&eacute;re erre a probl&eacute;m&aacute;ra van megold&aacute;s: a Java <a title="Java StringBuilder bemutat&aacute;sa" href="http:&#47;&#47;www.webotlet.hu/?p=937" target="_blank">StringBuilder</a> oszt&aacute;lya, amit pont a Stringm&#369;veletek hat&eacute;konys&aacute;g&aacute;nak optimaliz&aacute;l&aacute;sra fejlesztettek ki. Az el&#337;z&#337; Java program k&ouml;nnyed&eacute;n &aacute;t&iacute;rhat&oacute; StringBuilderek seg&iacute;ts&eacute;g&eacute;vel. Annyi a dolgunk, hogy a number &eacute;s newNum v&aacute;ltoz&oacute;k a <a title="StringBuilder Java documentation" href="https:&#47;&#47;docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.htm" target="_blank">StringBuilder</a> p&eacute;ld&aacute;nyai legyenek, &eacute;s<em> &ouml;sszef&#369;z&eacute;s (+) m&#369;velet helyett</em> haszn&aacute;ljuk a StringBuilder <strong>append</strong> met&oacute;dus&aacute;t. Az m&oacute;dos&iacute;tott forr&aacute;sk&oacute;d:</p>\n<pre><code>\nfor (int cycle=1; cycle&lt;=maxCycles; ++cycle)\n{\n	StringBuilder newNum = new StringBuilder();\n	for (int i=0; i&lt;number.length(); )\n	{\n		char symbol = number.charAt(i);\n		int symbolCount = 0;\n		while (i&lt;number.length() &amp;&amp; number.charAt(i)==symbol) \n		{\n			++i;\n			++symbolCount;\n		}\n		newNum.append(Integer.toString(symbolCount));\n		newNum.append(symbol);\n	}\n	number = newNum; &#47;&#47;new number to current\n	System.out.println(cycle+". number: "+number.length());\n}\n</code></pre>\n<p>A Java JAVul&aacute;sa meglehet&#337;sen szembet&#369;n&#337;: a t&ouml;bb &oacute;r&aacute;s fut&aacute;sid&#337; 1-2 m&aacute;sodperce cs&ouml;kkent. Vagyis megsp&oacute;roltunk a fut&aacute;sid&#337; legJAV&Aacute;t! A tanuls&aacute;g teh&aacute;t: sok Stringm&#369;velet eset&eacute;n JAVAsolt haszn&aacute;lni a StringBuildert (&eacute;s nem csak a JAVAsasszonyok szerint).</p>\n<p><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/biri_nene_javasasszony.jpg" alt="Biri n&eacute;ne a Javasasszony a L&uacute;das Matyi c&iacute;m&#369; rajzfilmb&#337;l" width="400" height="303" /><sub>Biri n&eacute;ne a JAVAsasszony. Akinek esetleg kimaradt a gyerekkor&aacute;b&oacute;l a L&uacute;das Matyi c&iacute;m&#369; remek magyar rajzfilm, annak <a title="R&eacute;szlet a L&uacute;das Matyi c&iacute;m&#369; rajzfilmb&#337;l" href="http:&#47;&#47;video.xfree.hu/?n=hoparduc|0819285328f375e25fc14a4be02a3123" target="_blank">egy kis seg&iacute;ts&eacute;g</a>.</sub></p>\n<h3>Akkor most a Java gy&#337;z&ouml;tt?</h3>\n<p>Ha a 2. &eacute;s a 3. forr&aacute;sk&oacute;d&uacute; program fut&aacute;sidej&eacute;t hasonl&iacute;tjuk &ouml;ssze, akkor igen. Viszont a <em>C++ program is hat&eacute;konyabb&aacute; tehet&#337;</em>, b&aacute;r nem lesz ennyire szembet&#369;n&#337; a v&aacute;ltoz&aacute;s (50 ciklus eset&eacute;ben). <em>Kik&uuml;sz&ouml;b&ouml;lhet&#337;ek</em> ugyanis a <strong>to_string</strong> f&uuml;ggv&eacute;nyh&iacute;v&aacute;sok, &eacute;s a <em>string &ouml;sszef&#369;z&eacute;sek</em> is. Mind&ouml;ssze annyit kell tenni, hogy a newNum &eacute;rt&eacute;k&eacute;t string helyett stringstreamben t&aacute;roljuk. &Iacute;gy a kimeneti streamre ir&aacute;ny&iacute;t&aacute;ssal lefaraghatjuk a r&eacute;gi C++ programunk h&aacute;tr&aacute;ny&aacute;t az &uacute;j Java programmal szemben, &eacute;s szint&eacute;n 1-2 m&aacute;sodpercen bel&uuml;l kapunk eredm&eacute;nyt. A jav&iacute;tott C++ forr&aacute;sk&oacute;d r&eacute;szlet pedig:</p>\n<pre><code>\nostringstream newNum;\nfor (i=0; i&lt;number.size(); )\n{\n    char symbol = number[i];\n    int symbolCount = 0;\n    while (i&lt;number.size() &amp;&amp; number[i]==symbol)\n    {\n        ++i;\n        ++symbolCount;\n    }\n\n    newNum &lt;&lt; symbolCount;\n    newNum &lt;&lt; symbol;\n}\nnumber = newNum.str(); &#47;&#47;new number to current\nnewNum.str(""); &#47;&#47;clear stream\ncout&lt;&lt;cycle&lt;&lt;". number length: "&lt;&lt;number.size()&lt;&lt;endl;\n</code></pre>\n<p>Vagyis 50 ciklusra nem tudtunk egy&eacute;rtelm&#369; gy&#337;ztest hirdetni. A programok kipr&oacute;b&aacute;lhat&oacute;k t&ouml;bb ciklusra is, azonban figyelni kell arra, hogy a string oszt&aacute;lyok is v&eacute;gesek (b&aacute;r igen nagy m&eacute;ret&#369;ek) mindk&eacute;t nyelv eset&eacute;ben. De ha megegyez&uuml;nk egy <span style="text-decoration: underline;"><strong>d&ouml;ntetlenben</strong></span>, azzal szerintem mindenki el&eacute;gedett lesz! :)</p>\n<p><sub>A konkr&eacute;t fut&aacute;sid&#337;k persze mindig a haszn&aacute;lt sz&aacute;m&iacute;t&oacute;g&eacute;pt&#337;l f&uuml;ggnek. &Eacute;n egy 4 &eacute;ves laptop 2 GHz k&ouml;r&uuml;li &oacute;rajel&#369;, 64 bites Intel Core i3 processzor&aacute;n futattam a programokat, 4 GB RAM mem&oacute;ri&aacute;val.</sub></p>', '2016-01-23 11:47:29', '2016-01-23 12:52:53'),
(62, 'comsciblog', 'Some basic information about this site', 'en', '<p>Welcome everyone in this site! It is my personal blog. The posts usually contains short writings about programming, algorithms, and sometimes mathematics. And I mostly write in Hungarian, in my native language. &nbsp;That is why this part is quite empty. If you want to read my posts, you need to change language to Hungarian with the <a title="Change language to Hungarian" href="http:&#47;&#47;comsciblog.esy.es/hu">language picker</a>&nbsp;in the top left side of the page. The blog also have a Facebook page, but it&apos;s written in Hungarian, too. I prefer my native language.<br /><br /><a title="Change language to Hungarian" href="http:&#47;&#47;comsciblog.esy.es/hu"><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/eng_hun_flag.png" alt="Mixture of the flag of Hungary and Great Britain." width="800" height="392" /></a>&nbsp;<br />If you really want to read a post from this blog, just <span style="text-decoration: line-through;">use the Google translate</span>&nbsp;write a comment to this blog, or the<a href="https:&#47;&#47;www.facebook.com/comsciblog" target="_blank"> Facebook page</a>.&nbsp;</p>', '2016-02-17 12:27:01', '2016-02-17 12:45:41');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(63, 'comsciblog', 'Elemi adatszerkezetek 1. - A verem (stack)', 'hu', '<p><strong>M&aacute;t&oacute;l&nbsp;egy &uacute;jabb t&eacute;mak&ouml;rbe is &nbsp;belekezdek, &eacute;s rem&eacute;lhet&#337;leg folytatni is fogom. A bejegyz&eacute;sben a verem adatszerkezetr&#337;l lesz sz&oacute;, ahogy az a c&iacute;mb&#337;l kider&uuml;lt. A megval&oacute;s&iacute;t&aacute;s nyelve a C &eacute;s a C++ lesz. A programom a verem adatszerkezetet, &eacute;s a rajta v&eacute;gzett k&eacute;t f&#337; m&#369;veletet mutatja be, hagyom&aacute;nyos imperat&iacute;v &eacute;s objektumorient&aacute;lt st&iacute;lusban is. Ezen k&iacute;v&uuml;l kit&eacute;rek a C(++) programok mem&oacute;riakezel&eacute;s&eacute;re, &eacute;s a sablonok (template) haszn&aacute;lat&aacute;ra is.<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/stack_image.png" alt="A verem adatszerkezet m&#369;k&ouml;d&eacute;s&eacute;nek sematikus &aacute;br&aacute;ja." width="500" height="359" /><br /></strong><sub>A verem adatszerkezet m&#369;k&ouml;d&eacute;s&eacute;nek sematikus &aacute;br&aacute;ja. Az eredeti k&eacute;p&eacute;rt, &eacute;s tov&aacute;bbi inform&aacute;ci&oacute;&eacute;rt keresse fel a <a title="Verem (adatszerkezet) - Wikip&eacute;dia sz&oacute;cikk" href="https:&#47;&#47;hu.wikipedia.org/wiki/Verem_(adatszerkezet)" target="_blank">Wikip&eacute;dia megfelel&#337; sz&oacute;cikk&eacute;t</a>.</sub><strong><br /></strong></p>\r\n<p>A verem (stack) az egyik legegyszer&#369;bb adatszerkezetek egyike. Azonos t&iacute;pus&uacute; adatok t&aacute;rol&aacute;s&aacute;ra alkalmas <strong>LIFO</strong> (last in first out) adatszerkezet: vagyis<em> amelyik adat a legk&eacute;s&#337;bb ker&uuml;lt bele a verembe, azt vehetj&uuml;k ki bel&#337;le legel&#337;sz&ouml;r</em>. K&eacute;t alapvet&#337; m&#369;velettel rendelkezik:</p>\r\n<ul>\r\n<li><strong>push(elem)</strong> &ndash; egy elem berak&aacute;sa a verem tetej&eacute;re</li>\r\n<li><strong>pop()</strong> - legfels&#337; elem kiv&eacute;tele a veremb&#337;l.</li>\r\n</ul>\r\n<p>A verem teh&aacute;t nem m&aacute;s, mint egy <em>mem&oacute;riater&uuml;let</em> &eacute;s egy<em> verem mutat&oacute;</em> (stack pointer), amely a verem<em> legfels&#337; elem&eacute;re mutat</em>. Ez az adatszerkezet felhaszn&aacute;lhat&oacute; k&uuml;l&ouml;nb&ouml;z&#337; visszal&eacute;p&eacute;sen (backtrack) alapul&oacute; algoritmusokhoz, de hardveres szinten is megtal&aacute;lhat&oacute;: a mem&oacute;ri&aacute;nak van egy stack szegmensnek nevezett r&eacute;sze, illetve egy stack pointer nev&#369; regiszter, amelyek lehet&#337;v&eacute; teszik a szubrutinok h&iacute;v&aacute;s&aacute;t, &eacute;s emiatt tudunk rekurz&iacute;v programokat &iacute;rni.</p>\r\n<p><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/factorial_stack.png" alt="A rekurz&iacute;van meg&iacute;rt faktori&aacute;lis program C k&oacute;dja, illetve a stack mem&oacute;ria sematikus &aacute;br&aacute;ja a lefut&aacute;sa sor&aacute;n." width="600" height="222" /><sub>A rekurz&iacute;van meg&iacute;rt faktori&aacute;lis program C forr&aacute;sk&oacute;dja (jobb oldalt), illetve a stack mem&oacute;ria sematikus &aacute;br&aacute;ja a fact(4) lefut&aacute;sa sor&aacute;n. Legel&#337;sz&ouml;r ker&uuml;l bele a fact(4) f&uuml;ggv&eacute;nyh&iacute;v&aacute;s, utolj&aacute;sra a fact(1). Viszont a fact(1) t&eacute;r vissza el&#337;sz&ouml;r (1-gyel), majd ut&aacute;na a bel&#337;le sz&aacute;molt fact(2), azt&aacute;n a fact(2)-b&#337;l kisz&aacute;m&iacute;tott fact(3), m&iacute;g v&eacute;g&uuml;l a hasonl&oacute;an sz&aacute;molt fact(4).</sub></p>\r\n<p>A megval&oacute;s&iacute;t&aacute;s&aacute;hoz sz&uuml;ks&eacute;g van teh&aacute;t egy megadott m&eacute;ret&#369; t&ouml;mbre, illetve egy veremmutat&oacute;ra, vagyis egy eg&eacute;sz sz&aacute;mra, ami a verem legfels&#337; elem&eacute;nek index&eacute;t tartalmazza. &Uuml;res verem eset&eacute;n legyen ez -1.&nbsp; A <strong>push</strong> m&#369;velet sor&aacute;n el&#337;sz&ouml;r c&eacute;lszer&#369; ellen&#337;rizni, hogy f&eacute;r-e m&eacute;g a verembe. Ha igen, megn&ouml;velj&uuml;k a <strong>top</strong> mutat&oacute;t ("ki&aacute;ssuk a vermet"), &eacute;s a <strong>top</strong> helyre beletessz&uuml;k a k&iacute;v&aacute;nt elemet. A <strong>pop</strong> m&#369;velet eset&eacute;n pedig&nbsp; azt c&eacute;lszer&#369; megvizsg&aacute;lni, hogy &uuml;res-e. Ha nem &uuml;res, visszat&eacute;r&uuml;nk a legfels&#337; (<strong>top</strong>) elemmel, &eacute;s cs&ouml;kkentj&uuml;k eggyel a top mutat&oacute; &eacute;rt&eacute;k&eacute;t.</p>\r\n<pre><code>#include &lt;stdio.h&gt; \r\n#include &lt;stdlib.h&gt;\r\n#define MAX 100\r\n\r\nint stack[MAX];\r\nint top = -1;\r\n\r\nvoid push(int elem)\r\n{\r\n	if (top==MAX-1)\r\n	{\r\n		printf("Stack is full\\n");\r\n		return;\r\n	}\r\n	++top;\r\n	stack[top] = elem;\r\n}\r\n\r\nvoid print()\r\n{\r\n	int i;\r\n	for (i=0; i&lt;=top; ++i)\r\n		printf("%d ", stack[i]);\r\n	printf("\\n");\r\n}\r\n\r\nint pop()\r\n{\r\n	if (top==-1)\r\n	{\r\n		printf("Stack is empty!\\n");\r\n		return -1;\r\n	}\r\n	return stack[top--];\r\n	\r\n}\r\n\r\n/* Kiprobalas: tetszoleges lehet... */\r\nint main (int argc, char ** argv)\r\n{\r\n	push(10); push(100); push(121); push(12);\r\n	print();\r\n	int elem = pop();\r\n	printf("The element: %d\\n", elem);\r\n	print();\r\n	pop(); print();\r\n	pop(); print();\r\n	pop(); print();\r\n	pop(); print();\r\n	return 0;\r\n}\r\n\r\n</code></pre>\r\n<p>Ugyanezt persze C++, vagy egy&eacute;b objektumorient&aacute;lt nyelven egy oszt&aacute;lyk&eacute;nt is megval&oacute;s&iacute;thatjuk: az adattagok a t&ouml;mb, illetve a top mutat&oacute;, a met&oacute;dusok pedig a<strong> push()</strong>, a <strong>pop()</strong>, &eacute;s a ki&iacute;rat&aacute;shoz haszn&aacute;lt <strong>print()</strong>. &Iacute;gy az oszt&aacute;ly p&eacute;ld&aacute;nyos&iacute;t&aacute;s&aacute;val kapunk egy megadott m&eacute;ret&#369; <strong>Stack</strong> objektumot, amit fel tudunk haszn&aacute;lni, am&iacute;g engedi a m&eacute;rete.</p>\r\n<h3>Felmer&uuml;lhet a k&eacute;rd&eacute;s, hogy legfeljebb mennyi elemre lesz sz&uuml;ks&eacute;g&uuml;nk, vagyis mekkora legyen a verem maxim&aacute;lis m&eacute;rete?</h3>\r\n<p>Semmik&eacute;pp se legyen t&uacute;l kicsi, mert akkor sok adat eset&eacute;n nem haszn&aacute;lhat&oacute;. Ha pedig t&uacute;l nagy, feleslegesen foglal sok extra mem&oacute;ri&aacute;t. Ez&eacute;rt c&eacute;lszer&#369; a t&ouml;mb&ouml;t dinamikusan foglalni. C/C++ nyelv eset&eacute;n ugyanis t&ouml;bbf&eacute;lek&eacute;pp foglalhatunk mem&oacute;ri&aacute;t egy t&ouml;mbnek:</p>\r\n<ul>\r\n<li><span style="text-decoration: underline;"><strong>statikus t&ouml;mb</strong></span> &ndash; a mem&oacute;riafoglal&aacute;s ford&iacute;t&aacute;si id&#337;ben (el&#337;re) t&ouml;rt&eacute;nik. A lefoglalt ter&uuml;let a program lefut&aacute;s&aacute;ig nem szabadulhat fel. P&eacute;lda: <strong>int tomb[100];</strong></li>\r\n<li><span style="text-decoration: underline;"><strong>dinamikus t&ouml;mb</strong></span> -a mem&oacute;riafoglal&aacute;s fut&aacute;sid&#337;ben t&ouml;rt&eacute;nik. A program fut&aacute;sa sor&aacute;n foglalhatunk le, illetve szabad&iacute;thatunk fel mem&oacute;riater&uuml;letet.\r\n<ol>\r\n<li>C nyelv eset&eacute;n a <em>dinamikus mem&oacute;riafoglal&aacute;s</em> a <strong>malloc</strong> f&uuml;ggv&eacute;ny seg&iacute;ts&eacute;g&eacute;vel: <br /> <strong>int * tomb = (int *) malloc(100*sizeof(int));</strong>&nbsp;A malloc param&eacute;tere a foglaland&oacute; mem&oacute;riater&uuml;let byteban. Egy integer &aacute;ltal&aacute;ban 4 byte (de architekt&uacute;raf&uuml;gg&#337;!!), ezt adja vissza a <strong>sizeof(int)</strong> f&uuml;ggv&eacute;nyh&iacute;v&aacute;s.<br /><em>&Uacute;jrafoglal&aacute;s:</em> <strong>int * tomb = (int *) realloc(tomb, 200*sizeof(int));</strong> &Uacute;jrafoglalja a t&ouml;mb&ouml;t. A r&eacute;gi mem&oacute;riatartalom megmarad. T&ouml;mb b&ouml;v&iacute;t&eacute;s&eacute;re alkalmas.<br /><em>Felszabad&iacute;t&aacute;s:</em> <strong>free(tomb);</strong> Felszabad&iacute;tja a <strong>tomb</strong> nev&#369; pointert, &eacute;rt&eacute;ke NULL lesz.</li>\r\n<li>C++ nyelv eset&eacute;n a felsoroltakon k&iacute;v&uuml;l m&eacute;g <em>lefoglalhatunk</em> mem&oacute;riater&uuml;letet <strong>new</strong> oper&aacute;tor seg&iacute;ts&eacute;g&eacute;vel:<strong> int * tomb = new int[100];</strong><br />Ekkor a t&ouml;mb <em>felszabad&iacute;t&aacute;sa</em>:<strong> delete[] tomb;</strong> <br /><strong style="color: red;">Fontos, hogy ne kever&uuml;k &#337;ket: malloc haszn&aacute;lat&aacute;val lefoglalt mem&oacute;riater&uuml;let eset&eacute;n mindenk&eacute;pp free, &eacute;s new haszn&aacute;lata eset&eacute;n mindenk&eacute;pp delete!</strong></li>\r\n</ol>\r\n</li>\r\n</ul>\r\n<p>Ennyi bevezet&#337; ut&aacute;n meg&iacute;rhatjuk a dinamikus m&eacute;ret&#369; <strong>Stack</strong> objektumot. Nyilv&aacute;nval&oacute;an &iacute;gy is kell lennie egy maxim&aacute;lis m&eacute;retnek, amin&eacute;l nagyobbat semmik&eacute;pp sem engedhet&uuml;nk (pl.: a g&eacute;p&uuml;nk RAM m&eacute;rete). Ezen k&iacute;v&uuml;l meg kell hat&aacute;rozni egy kezd&#337; m&eacute;retet, valamint a n&ouml;vel&eacute;s m&eacute;rt&eacute;k&eacute;t. A C++ oszt&aacute;ly teh&aacute;t:</p>\r\n<pre><code>class Stack \r\n{\r\n	int * stack;\r\n	const int maxSize;\r\n	int size, top;\r\n	\r\n	public: \r\n	\r\n	Stack() : maxSize(100000)\r\n	{\r\n		size = 5, top = -1;\r\n		stack = (int *) malloc(size*sizeof(int));\r\n	}\r\n	\r\n	void push(int elem)\r\n	{\r\n		if (top == size-1 &amp;&amp; size &lt; maxSize)\r\n		{\r\n			cout&lt;&lt;"Increasing buffer"&lt;&lt;endl;\r\n			size+=5;\r\n			stack = (int *) realloc(stack, size*sizeof(int));\r\n		}\r\n		\r\n		++top;\r\n		stack[top] = elem;\r\n	}\r\n	\r\n	void print()\r\n	{\r\n		for (int i=0; i&lt;=top; ++i)\r\n			cout&lt;&lt;stack[i]&lt;&lt;", ";\r\n		cout&lt;&lt;endl;\r\n	}\r\n	\r\n	int pop()\r\n	{\r\n		if (top==-1)\r\n		{\r\n			cout&lt;&lt;"Stack is empty."&lt;&lt;endl;\r\n			return -1;\r\n		}\r\n		return stack[top--];\r\n	}\r\n	\r\n	bool isEmpty()\r\n	{\r\n		return (top==-1);\r\n	}\r\n	\r\n	~Stack()\r\n	{\r\n		free(stack);\r\n	}\r\n};\r\n</code></pre>\r\n<p>A kezdeti mem&oacute;riafoglal&aacute;st a <em>konstruktorban </em>v&eacute;gzem. Mivel a <strong>maxSize</strong> konstans, ez&eacute;rt kezd&#337;&eacute;rt&eacute;kez&eacute;s&eacute;hez a konstruktor taginicializ&aacute;l&oacute; list&aacute;j&aacute;ban h&iacute;vom meg az <strong>int</strong> t&iacute;pus konstruktor&aacute;t: vagyis m&eacute;g az objektum l&eacute;trej&ouml;tte el&#337;tt megkapja az &eacute;rt&eacute;ket.<br />A mem&oacute;ria &uacute;jrafoglal&aacute;sa akkor t&ouml;rt&eacute;nik, amikor m&aacute;r<em> betelt a veremnek sz&aacute;nt mem&oacute;riapuffer</em>: vagyis a <strong>push</strong> f&uuml;ggv&eacute;nyh&iacute;v&aacute;s sor&aacute;n ellen&#337;rz&ouml;m, hogy van-e m&eacute;g hely: ha nincs,<em> &uacute;jrafoglalom a t&ouml;mb&ouml;t</em>, megn&ouml;velt m&eacute;rettel.<br />A mem&oacute;ria felszabad&iacute;t&aacute;sa pedig a<strong> ~Stack()</strong> jel&ouml;l&eacute;s&#369; <em>destruktorban</em> t&ouml;rt&eacute;nik: az az objektum megsz&#369;n&eacute;se ("hal&aacute;la") el&#337;tt legutolj&aacute;ra lefut&oacute; f&uuml;ggv&eacute;ny.</p>\r\n<p>&nbsp;Miut&aacute;n meg&iacute;rtuk az oszt&aacute;lyt, m&aacute;r csak a p&eacute;ld&aacute;nyos&iacute;t&aacute;s maradt. Ez is t&ouml;rt&eacute;nhet <em>statikusan</em> (<strong>stack s;</strong>) illetve <em>dinamikusan</em> (<strong>stack * s = new Stack();</strong>). Fontos, hogy statikus esetben <em><strong>s</strong> maga az objektum</em>: a tagf&uuml;ggv&eacute;nyek el&eacute;r&eacute;se ez eseben: <strong>s.push(42); s.pop();</strong> Dinamikus esetben viszont<em><strong> s</strong> csak egy mutat&oacute; (pointer) az objektumra</em>. Ekkor a tagf&uuml;ggv&eacute;nyek haszn&aacute;lata:<strong> s-&gt;push(42); s-&gt;pop();</strong> Dinamikus esetben <strong>s</strong> b&aacute;rmikor felszabad&iacute;that&oacute; (<strong>delete s;</strong>), m&iacute;g statikus esetben nem.</p>\r\n<h3>Egy verem ezek szerint csak eg&eacute;sz sz&aacute;mokat tartalmazhat?</h3>\r\n<p>&nbsp;Term&eacute;szetesen nem. Tetsz&#337;leges objektumot tartalmazhat: erre val&oacute; a sablonok (template) haszn&aacute;lata. Sablon l&eacute;trehoz&aacute;s&aacute;ra a template<strong>&lt;class T&gt;</strong> sor szolg&aacute;l: ekkor <strong>T</strong>-vel jel&ouml;l&uuml;nk egy tetsz&#337;leges oszt&aacute;lyt. Ezek ut&aacute;n m&aacute;r csak le kell cser&eacute;ln&uuml;nk a <strong>stack</strong> t&ouml;mb t&iacute;pus&aacute;t <strong>T</strong>-re. Sajnos azonban a <strong>malloc</strong> &eacute;s a <strong>realloc</strong> nem m&#369;k&ouml;dik megfelel&#337;en nem primit&iacute;v adatok (pl.: <strong>string</strong> objektum) eset&eacute;n &ndash; nekem legal&aacute;bbis sehogy sem akart &ouml;sszej&ouml;nni &ndash; ez&eacute;rt &aacute;t kell &iacute;rni a mem&oacute;riafoglal&aacute;st <strong>new</strong> oper&aacute;toros, a felszabad&iacute;t&aacute;st pedig a <strong>delete</strong> oper&aacute;toros alakra. Az &uacute;jrafoglal&aacute;s eset&eacute;n l&eacute;trehoztam egy &uacute;j, ideiglenes (<strong>tmp</strong>) mutat&oacute;t, aminek a b&#337;v&iacute;tett mem&oacute;riam&eacute;retet foglaltam. Majd egyes&eacute;vel (<strong>for</strong> ciklussal) &aacute;tm&aacute;soltam a <strong>stack</strong> t&ouml;mb elemeit a nagyobb <strong>tmp</strong> t&ouml;mbbe, majd a <strong>stack</strong> mutat&oacute;nak &eacute;rt&eacute;k&uuml;l adtam <strong>tmp</strong> mutat&oacute;t. &Iacute;gy el&eacute;rtem, hogy <strong>stack</strong> pufferm&eacute;rete megn&#337;j&ouml;n, ugyanakkor az &eacute;rt&eacute;kek ne v&aacute;ltozzanak.&nbsp; Most m&aacute;r felszabad&iacute;that&oacute; a <strong>tmp</strong> t&ouml;mb. A sablonos&iacute;tott C++ oszt&aacute;ly:</p>\r\n<pre><code>template &lt;class T&gt;\r\nclass Stack \r\n{\r\n	T * stack;\r\n	const int maxSize;\r\n	int size, top;\r\n	\r\n	public: \r\n	\r\n	Stack() : maxSize(100000)\r\n	{\r\n		size = 500, top = -1;\r\n		stack = new T[size];\r\n	}\r\n	\r\n	void push(T elem)\r\n	{\r\n		if (top == size-1 &amp;&amp; size &lt; maxSize)\r\n		{\r\n			int n = 500;\r\n			cout&lt;&lt;"Increasing buffer"&lt;&lt;size+n&lt;&lt;endl;\r\n			T * tmp = new T[size+n];\r\n			for (int i=0; i&lt;size; ++i)\r\n				tmp[i] = stack[i];\r\n			stack = tmp;\r\n			delete[] tmp;\r\n			size+=n;\r\n		}\r\n		++top;\r\n		stack[top] = elem;\r\n	}\r\n	\r\n	void print()\r\n	{\r\n		for (int i=0; i&lt;=top; ++i)\r\n			cout&lt;&lt;stack[i]&lt;&lt;", ";\r\n		cout&lt;&lt;endl;\r\n	}\r\n	\r\n	T pop()\r\n	{\r\n		if (top==-1)\r\n		{\r\n			cout&lt;&lt;"Stack is empty."&lt;&lt;endl;\r\n			return T();\r\n		}\r\n		return stack[top--];\r\n	}\r\n	\r\n	bool isEmpty()\r\n	{\r\n		return (top==-1);\r\n	}\r\n	\r\n	~Stack()\r\n	{\r\n		delete[] stack;\r\n	}\r\n};\r\n\r\n/* Pelda a hasznalatara: Stack&lt;string&gt; tipussal */\r\nint main()\r\n{	\r\n	Stack * s1 = new Stack();\r\n	\r\n	s1-&gt;push("alma");\r\n	s1-&gt;push("szilva");\r\n	s1-&gt;push("barack");\r\n	s1-&gt;push("eper");\r\n		\r\n	s1-&gt;print();\r\n	string elem = s1-&gt;pop();\r\n	elem = s1-&gt;pop();\r\n	elem = s1-&gt;pop();\r\n	cout&lt;&lt;"The element: "&lt;&lt;elem&lt;&lt;endl;\r\n	s1-&gt;print();\r\n	\r\n	for (int i=0; i&lt;5; ++i)\r\n		s1-&gt;pop();\r\n}\r\n</code></pre>\r\n<p>A bejegyz&eacute;sben teh&aacute;t l&eacute;trehoztam egy sablonos&iacute;tott <strong>Stack</strong> oszt&aacute;lyt, amit (elvileg) tetsz&#337;leges LIFO m&#369;veletre haszn&aacute;lhatunk. De egy&eacute;bk&eacute;nt C++ nyelv standard k&ouml;nyvt&aacute;rai k&ouml;z&ouml;tt is megtal&aacute;lhat&oacute; a <a title="stack template C++ reference" href="http:&#47;&#47;www.cplusplus.com/reference/stack/stack/" target="_blank">verem implement&aacute;ci&oacute;ja</a>. De az&eacute;rt rem&eacute;lhet&#337;leg tanuls&aacute;gos volt. Ha m&aacute;st nem is, annyit mindenk&eacute;pp &eacute;rdemes megjegyezni, hogy <em>"aki m&aacute;snak vermet &aacute;s, az<span style="text-decoration: line-through;"> s&iacute;r&aacute;s&oacute; vagy k&ouml;zmunk&aacute;s</span> a stack pointer."</em></p>', '2016-02-28 11:25:48', '2016-02-28 01:19:27'),
(64, 'comsciblog', 'Elemi adatszerkezetek 2. - Sor (queue)', 'hu', '<p><strong>A sor (queue) adatszerkezet a veremhez (stack) hasonl&oacute;an szint&eacute;n egy egyszer&#369;, egy dimenzi&oacute;s adatszerezettel megval&oacute;s&iacute;that&oacute; <a title="Abstract Data Type - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Abstract_data_type" target="_blank">absztrakt adatt&iacute;pus</a>. M&#369;k&ouml;d&eacute;se azonban pont ellent&eacute;tes a verem&eacute;vel. A verem eset&eacute;n amit el&#337;sz&ouml;r vett&uuml;nk ki, azt tudtuk utolj&aacute;ra kivenni (LIFO &ndash; last in first out), ak&aacute;rcsak egy m&eacute;ly h&aacute;tizs&aacute;k eset&eacute;n. A sorn&aacute;l pedig amelyik el&#337;sz&ouml;r ker&uuml;lt be (amelyik ember legel&#337;bb &aacute;llt be a sorba) azt ker&uuml;lhet ki legel&#337;sz&ouml;r a sorb&oacute;l (&eacute;rkez&eacute;si sorrendben: mint p&eacute;ld&aacute;ul egy orvosi rendel&#337;ben).<br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/queue.png" alt="A k&eacute;pen a sor absztrakt adatt&iacute;pus sematikus &aacute;br&aacute;ja l&aacute;that&oacute;." width="405" height="265" /></strong><sub>A k&eacute;pen a sor (queue) sematikus &aacute;br&aacute;ja l&aacute;that&oacute;. A k&eacute;p a <a title="Queue (Abstract data type) - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Queue_(abstract_data_type)" target="_blank">Wikip&eacute;dir&oacute;l</a>&nbsp;sz&aacute;rmazik.</sub><strong><br /></strong></p>\r\n<p>A sorhoz is k&eacute;t m&#369;velet tartozik:</p>\r\n<ul>\r\n<li><strong>put</strong> (<em>enqueue</em>) &ndash; elem bev&eacute;tele a sorba</li>\r\n<li><strong>get</strong> (<em>dequeue</em>) &ndash; elem kiv&eacute;tele a sorb&oacute;l.</li>\r\n</ul>\r\n<p>A sor elemeit &ndash; a veremhez hasonl&oacute;an &ndash; szint&eacute;n t&aacute;rolhatjuk egy meghat&aacute;rozott m&eacute;ret&#369; egy dimenzi&oacute;s t&ouml;mbben. Viszont ebben az esetben k&eacute;t mutat&oacute;ra van sz&uuml;ks&eacute;g: a sor elej&eacute;t (<strong>front</strong>) illetve a v&eacute;g&eacute;t (<strong>rear</strong>) jelz&#337; mutat&oacute;ra. Ez k&eacute;t eg&eacute;sz sz&aacute;m, ami a mutatott elem t&ouml;mbbeli index&eacute;t tartalmazza. A <strong>front</strong> mutat&oacute; kezdetben (&uuml;res sor eset&eacute;n) a t&ouml;mb elej&eacute;re mutat, a <strong>rear</strong> pedig az utols&oacute; elem&eacute;re. Ha &uacute;j elemet tesz&uuml;nk a sor v&eacute;g&eacute;re, akkor a <strong>rear</strong> mutat&oacute;t n&ouml;velj&uuml;k, ha pedig kivessz&uuml;k az els&#337; elemet, a <strong>front</strong> mutat&oacute;t n&ouml;velj&uuml;k.</p>\r\n<p>A mutat&oacute;k n&ouml;vel&eacute;se a sort reprezent&aacute;l&oacute; t&ouml;mb m&eacute;rete ($N$) szerinti marad&eacute;koszt&aacute;lyban ($\\mathbb{Z}_N$) t&ouml;rt&eacute;nik. Vagyis minden n&ouml;vel&eacute;s est&eacute;n venn&uuml;nk kell az $N$-nel vett oszt&aacute;si marad&eacute;kot. Teh&aacute;t p&eacute;ld&aacute;ul <strong>front</strong> mutat&oacute; kezdetben 0, a rear pedig $N-1$ (C t&iacute;pus&uacute; nyelvek eset&eacute;n), majd az els&#337; n&ouml;vel&eacute;s ut&aacute;n <strong>rear</strong> mutat&oacute; $(N+1)%N$ &eacute;rt&eacute;ket fog felvenni, ami nulla. &nbsp;Vagyis az els&#337; elem a t&ouml;mb 0. hely&eacute;re ker&uuml;l. A t&ouml;mb m&eacute;ret&eacute;t pedig a <strong>front-rear+1</strong> &ouml;sszef&uuml;gg&eacute;ssel kaphatn&aacute;nk meg: mivel azonban a m&#369;velet a v&eacute;ges ($\\mathbb{Z}_N$)-ben t&ouml;rt&eacute;nik, ez&eacute;rt venn&uuml;nk kell N-vel vett oszt&aacute;si marad&eacute;kot. Ezen k&iacute;v&uuml;l m&eacute;g meg kellene &ouml;sszeget megn&ouml;velni $N$-nel, &iacute;gy abban az esetben sem kapunk negat&iacute;v sz&aacute;mot, ha <strong>rear &gt; front+1</strong>. Vagyis a sor m&eacute;ret&eacute;t a <strong>(front-rear+1 + N)%N</strong> &ouml;sszef&uuml;gg&eacute;s adja meg. Vagyis a sor m&eacute;rete a<strong> front+1</strong> &eacute;s <strong>rear</strong> <em>k&uuml;l&ouml;nbs&eacute;g&eacute;nek</em> (t&aacute;vols&aacute;g&aacute;nak)<em> legkisebb nemnegat&iacute;v marad&eacute;ka</em> modulo $N$.</p>\r\n<p><img class="img-responsive" class="img-responsive" src="http:&#47;&#47;comsciblog.esy.es/img/queue_anim.gif" alt="A FIFO sor m&#369;k&ouml;d&eacute;se egy p&eacute;ld&aacute;n kereszt&uuml;l." width="600" height="222" /><br /><sub>A FIFO sor t&ouml;mb&ouml;s implement&aacute;ci&oacute;j&aacute;nak m&#369;k&ouml;d&eacute;se egy p&eacute;ld&aacute;n kereszt&uuml;l. Balra a t&ouml;mb&ouml;s implement&aacute;ci&oacute;, jobbra pedig a sor logikai &aacute;llapota l&aacute;that&oacute;. Ezen a p&eacute;ld&aacute;n a t&ouml;mb m&eacute;rete 5, teh&aacute;t a sor maxim&aacute;lis m&eacute;rete 4.</sub></p>\r\n<p>A sor megval&oacute;s&iacute;t&aacute;sa C nyelven:</p>\r\n<pre><code>#include &lt;stdio.h&gt;\r\n#define SIZE 6\r\n\r\nint queue[SIZE];\r\nint front=0, rear=SIZE-1;\r\n\r\nint queue_size()\r\n{\r\n	return (rear-front+1 +SIZE) % SIZE;\r\n}\r\n\r\nvoid queue_put(int elem)\r\n{\r\n	if (queue_size()==SIZE-1) \r\n	{\r\n		printf("Queue is full\\n");\r\n		return;\r\n	}\r\n	rear=(rear+1)%SIZE;\r\n	queue[rear] = elem;\r\n}\r\n\r\nint queue_get()\r\n{\r\n	int back_value;\r\n	if (queue_size()==0)\r\n	{\r\n		printf("Queue is empty\\n");\r\n		return -1;\r\n	}\r\n	back_value = queue[front];\r\n	queue[front] = 0;\r\n	front=(front+1)%SIZE;\r\n	return back_value;\r\n}\r\n\r\nvoid queue_print()\r\n{\r\n	if (queue_size()==0)\r\n	{\r\n		printf("Queue is empty\\n");\r\n		return;\r\n	}\r\n	\r\n	int i;\r\n	for(i=front; i!=rear; i=(i+1)%SIZE)\r\n	{\r\n		printf("%d, ", queue[i]);\r\n	}\r\n	printf("%d\\n", queue[i]);\r\n}\r\n\r\nvoid queue_test_print()\r\n{\r\n	int i;\r\n	for (i=0; i&lt;SIZE; ++i)\r\n		printf("%d ", queue[i]);\r\n	printf("\\n");\r\n}<br /><br />/* A main f&uuml;ggv&eacute;ny tartalma tetsz&#337;leges lehet. */\r\n</code><code>int main(int argc, char ** argv)\r\n{\r\n	int i, j, elem;\r\n	for (i=1; i&lt;=SIZE+3; ++i)\r\n	{\r\n		queue_put(i);\r\n		queue_print();\r\n	}\r\n		\r\n	for (i=0; i&lt;3; ++i)\r\n	{\r\n		int elem = queue_get();\r\n		printf("The given element: %d\\n", elem);\r\n		queue_print();\r\n	}\r\n		\r\n	for (i=1; i&lt;=4; ++i)\r\n	{\r\n		queue_put(i);\r\n		queue_test_print();\r\n		queue_print();\r\n	}\r\n		\r\n	getchar();\r\n	return 0;\r\n}<br /></code></pre>\r\n<p>A programban a queue_print f&uuml;ggv&eacute;ny a sor adatszerkezet&uuml;nk &aacute;llapot&aacute;t adja vissza, m&iacute;g a queue_test_print egyszer&#369;en ki&iacute;rja a teljes t&ouml;mb&ouml;t, aminek seg&iacute;ts&eacute;g&eacute;vel implement&aacute;ltuk az adatszerkezetet. Hibajav&iacute;t&aacute;sra (debugging) j&oacute; lehet.</p>\r\n<p>Term&eacute;szetesen k&ouml;nnyed&eacute;n k&eacute;sz&iacute;thet&uuml;nk a sorb&oacute;l C++ oszt&aacute;lyt is: mind&ouml;ssze annyit kell tenni, hogy a t&ouml;mb&ouml;t, illetve mutat&oacute;kat priv&aacute;t adattagokk&aacute;, a meg&iacute;rt f&uuml;ggv&eacute;nyekb&#337;l pedig publikus tagf&uuml;ggv&eacute;nyeket (met&oacute;dusokat) k&eacute;sz&iacute;teni. Ezt sablonos&iacute;tani sem t&uacute;l bonyolult, mind&ouml;ssze a t&ouml;mb elemeit le kell cser&eacute;ln&uuml;nk egy T sablonra (hasonl&oacute;an az el&#337;z&#337; bejegyz&eacute;sben le&iacute;rtakhoz). A C++ oszt&aacute;ly teh&aacute;t:</p>\r\n<pre><code>template &lt;class T&gt;\r\nclass Queue\r\n{\r\n	const int SIZE;\r\n	int front, rear;\r\n	T * queue;\r\n	\r\n	public: \r\n	\r\n	Queue() : SIZE(500)\r\n	{\r\n		front = 0;\r\n		rear = SIZE-1;\r\n		queue = new T [SIZE];\r\n	}\r\n	\r\n	Queue(int custum_size): SIZE(custum_size+1)\r\n	{\r\n		front = 0;\r\n		rear = SIZE-1;\r\n		queue = new T [SIZE];\r\n	}\r\n	\r\n	int size()\r\n	{\r\n		return (rear-front+1 +SIZE) % SIZE;\r\n	}\r\n	\r\n	int max_size()\r\n	{\r\n		return SIZE-1;\r\n	}\r\n	\r\n	void put(T elem)\r\n	{\r\n		if (this-&gt;size() == this-&gt;max_size()) \r\n		{\r\n			cout&lt;&lt;"Queue is full"&lt;&lt;endl;\r\n			return;\r\n		}\r\n		rear=(rear+1)%SIZE;\r\n		queue[rear] = elem;\r\n	}\r\n	\r\n	T get()\r\n	{\r\n		T back_value;\r\n		if (this-&gt;size()==0)\r\n		{\r\n			cout&lt;&lt;"Queue is empty"&lt;&lt;endl;\r\n			return T();\r\n		}\r\n		back_value = queue[front];\r\n		queue[front] = T();\r\n		front=(front+1)%SIZE;\r\n		return back_value;\r\n	}\r\n	\r\n	void print()\r\n	{\r\n		if (this-&gt;size()==0)\r\n		{\r\n			cout&lt;&lt;"Queue is empty"&lt;&lt;endl;\r\n			return;\r\n		}\r\n		\r\n		int i;\r\n		for(i=front; i!=rear; i=(i+1)%SIZE)\r\n		{\r\n			cout&lt;&lt;queue[i]&lt;&lt;" ";\r\n		}\r\n		cout&lt;&lt;queue[i]&lt;&lt;endl;\r\n	}\r\n		\r\n	void test_print()\r\n	{\r\n		for (int i=0; i&lt;SIZE; ++i)\r\n			cout&lt;&lt;queue[i]&lt;&lt;" ";\r\n		cout&lt;&lt;endl;\r\n	}\r\n	\r\n	~Queue()\r\n	{\r\n		delete[] queue;\r\n	}\r\n};\r\n</code></pre>\r\n<h3><span style="text-decoration: underline;">Megjegyz&eacute;s</span></h3>\r\n<p>Ebben az esetben nem annyira egyszer&#369; dolog a mem&oacute;ria dinamikus n&ouml;velget&eacute;se, mint a <strong>Stack</strong> oszt&aacute;ly eset&eacute;n volt. Ugyanis itt a m&eacute;ret fontos szerepet j&aacute;tszik a mutat&oacute;k n&ouml;vel&eacute;s&eacute;ben. Ez&eacute;rt itt az alap&eacute;rtelmezett konstruktor mell&eacute; felvettem egy param&eacute;teres konstruktort is, aminek seg&iacute;ts&eacute;g&eacute;vel a Queue objektum l&eacute;trej&ouml;ttekor meghat&aacute;rozhatjuk a sor m&eacute;ret&eacute;t. Ez viszont ut&oacute;lag nem m&eacute;retezhet&#337; &aacute;t.<br />A sor adatt&iacute;pus megval&oacute;s&iacute;t&aacute;s&aacute;ra egy m&aacute;sik lehet&#337;s&eacute;g lehet a l&aacute;ncolt list&aacute;k alkalmaz&aacute;sa. Erre lehets&eacute;ges, hogy a k&ouml;vetkez&#337; bejegyz&eacute;sben fogok kit&eacute;rni. Addig is itt egy nagyszer&#369; szeml&eacute;ltet&eacute;se a t&ouml;mb&ouml;s implement&aacute;ci&oacute;nak a <a title="Az oldalon tov&aacute;bbi algoritmus vizualiz&aacute;ci&oacute;k tal&aacute;lhat&oacute;k." href="https:&#47;&#47;www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank">San Francisco-i egyetem</a> Computer Science tansz&eacute;k&eacute;r&#337;l:<br /><br /><iframe src="http:&#47;&#47;www.cs.usfca.edu/~galles/JavascriptVisual/QueueArray.html" width="1000" height="500"></iframe></p>', '2016-03-06 03:49:08', '2016-03-06 04:44:24'),
(65, 'comsciblog', 'Elemi adatszerkezetek 3. - (Egyszeresen) láncolt listák', 'hu', '<p><strong>A mai bejegyz&eacute;semben a l&aacute;ncolt list&aacute;kr&oacute;l lesz sz&oacute;. A l&aacute;ncolt lista egy gyakran haszn&aacute;lt, viszonylag egyszer&#369; adatszerkezet. Bizonyos csom&oacute;pontok l&aacute;ncszer&#369; &ouml;sszekapcsol&aacute;sak&eacute;nt k&eacute;pzelhet&#337; el: az adato(ka)t tartalmaz&oacute; csom&oacute;pontok a l&aacute;ncszemek, amelyek mutat&oacute;k seg&iacute;ts&eacute;g&eacute;vel vannak &ouml;sszekapcsolva. Ez a sturkt&uacute;ra egy k&ouml;nnyed&eacute;n m&oacute;dos&iacute;that&oacute; adatszerkezetet eredm&eacute;nyez: egyszer&#369;en f&#369;zet&uuml;nk hozz&aacute;, illetve t&aacute;vol&iacute;thatunk el elemet a lista b&aacute;rmely pontj&aacute;r&oacute;l. Ugyanakkor a megszokott t&ouml;mb&ouml;kh&ouml;z k&eacute;pest soros el&eacute;r&eacute;s&#369;, vagyis bizonyos cs&uacute;cspontok adatainak el&eacute;r&eacute;si ideje j&oacute;val hosszabb lehet, mint a t&ouml;mb eset&eacute;ben.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/linked-list.png" alt="A k&eacute;pen l&aacute;ncolt list&aacute;k &aacute;br&aacute;zol&aacute;sa l&aacute;that&oacute;." width="486" height="276" /></strong><sub>A k&eacute;pen l&aacute;ncolt list&aacute;k &aacute;br&aacute;zol&aacute;sa l&aacute;that&oacute;. A fels&#337; &aacute;bra egy egyszer&#369;, egyszeresen l&aacute;ncolt lista, az als&oacute; pedig egy k&ouml;rk&ouml;r&ouml;s egyszeresen l&aacute;ncolt lista. A k&eacute;p forr&aacute;sa: <a title="&Eacute;rdemes lehet elolvasni! (angol nyelv&#369;)" href="http:&#47;&#47;www.comscigate.com/cs/IntroSedgewick/40adt/43link/index.html" target="_blank">http:&#47;&#47;www.comscigate.com/</a></sub><strong><br /></strong></p>\n<p>A l&aacute;ncol&aacute;s m&oacute;dja szerint megk&uuml;l&ouml;nb&ouml;ztethet&uuml;nk <em>egyszeresen</em>, illetve <em>k&eacute;tszeresen l&aacute;ncolt</em> list&aacute;t. Az egyszeres l&aacute;ncol&aacute;s eset&eacute;n egy csom&oacute;pontnak csak a lista k&ouml;vetkez&#337; tagj&aacute;hoz van mutat&oacute;ja. Ezzel szemben a k&eacute;tszeresen l&aacute;ncolt lista eset&eacute;ben minden csom&oacute;pontnak van mutat&oacute;ja az &#337;t megel&#337;z&#337; csom&oacute;pontra &eacute;s az &#337;t k&ouml;vet&#337; csom&oacute;ponthoz is.&nbsp;</p>\n<p>Ezen a l&aacute;ncolt lista lehet <em>line&aacute;risan &ouml;sszekapcsolt</em>, vagy <em>k&ouml;rk&ouml;r&ouml;sen &ouml;sszekapcsolt</em>. K&ouml;rk&ouml;r&ouml;s l&aacute;ncolt lista eset&eacute;n a lista utols&oacute; tagja hozz&aacute; van kapcsolva a lista els&#337; tagj&aacute;hoz, m&iacute;g line&aacute;ris esetben az utols&oacute; tag "k&ouml;vetkez&#337;" mutat&oacute;ja nem mutat sehov&aacute; (<strong>NULL</strong> pointer).</p>\n<p>&nbsp;<img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/types_of_linked_lists.png" alt="L&aacute;ncolt list&aacute;k k&uuml;l&ouml;nf&eacute;le t&iacute;pusainak &aacute;br&aacute;zol&aacute;sa." width="350" height="440" /><br />L&aacute;ncolt list&aacute;k k&uuml;l&ouml;nf&eacute;le t&iacute;pusainak &aacute;br&aacute;zol&aacute;sa. Az &aacute;bra a <a href="http:&#47;&#47;sp-productions.org/c++%20tutorial3.html" target="_blank">sp-productions.org</a> weboldalr&oacute;l sz&aacute;rmazik.</p>\n<p>A l&aacute;ncolt list&aacute;k seg&iacute;ts&eacute;g&eacute;vel - a t&ouml;mb adatszerkezethez hasonl&oacute;an - megval&oacute;s&iacute;thatunk <em>rendezetlen</em> vagy <em>rendezett</em> list&aacute;kat, <em>FIFO sorokat</em>, vagy &eacute;pp<em> LIFO vermet</em> is. FIFO sor eset&eacute;n p&eacute;ld&aacute;ul egy&aacute;ltal&aacute;n nem kell foglalkoznunk <a title="FIFO sor t&ouml;mb&ouml;s implement&aacute;ci&oacute;ja " href="http:&#47;&#47;comsciblog.esy.es/article/64/Elemi+adatszerkezetek+2.+-+Sor+%28queue%29" target="_blank">az el&#337;z&#337; bejegyz&eacute;sben</a> bemutatott marad&eacute;ksz&aacute;m&iacute;t&aacute;sokkal, egyszer&#369;en a nyilv&aacute;ntartjuk az elej&eacute;re &eacute;s a v&eacute;g&eacute;re mutat&oacute; pointereket, &eacute;s besz&uacute;r&aacute;s elej&eacute;n az els&#337; (<strong>head</strong>) elem el&eacute; sz&uacute;runk egy &uacute;j csom&oacute;pontot, t&ouml;rl&eacute;s eset&eacute;n pedig a v&eacute;g&eacute;r&#337;l (<strong>tail</strong>) vesz&uuml;nk le egy csom&oacute;pontot. A <a title="Algoritmusok bemutat&aacute;sai" href="https:&#47;&#47;www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank">San Francisco-i egyetem oldal&aacute;n</a> tal&aacute;lhat&oacute; egy j&oacute; kis interakt&iacute;v vizualiz&aacute;ci&oacute; a FIFO sor l&aacute;ncolt list&aacute;s implement&aacute;ci&oacute;j&aacute;r&oacute;l:<br /><br /><iframe src="https:&#47;&#47;www.cs.usfca.edu/~galles/visualization/QueueLL.html" width="1000" height="500"> </iframe></p>\n<h3><span style="text-decoration: underline;">A l&aacute;ncolt list&aacute;k el&#337;nyei a t&ouml;mb&ouml;kkel szemben:</span></h3>\n<ul>\n<li>&nbsp;Dinamikusabban tudunk &uacute;j elemet hozz&aacute;adni, illetve t&ouml;r&ouml;lni b&aacute;rmelyik r&eacute;sz&eacute;r&#337;l. Nem kell a teljes mem&oacute;ri&aacute;t &uacute;jrafoglalni.</li>\n<li>A lefoglalt mem&oacute;riater&uuml;letnek nem kell &ouml;sszef&uuml;gg&#337;nek lennie.</li>\n<li>K&ouml;nnyen megval&oacute;s&iacute;that&oacute; vele p&eacute;ld&aacute;ul a FIFO sor (l&aacute;st feljebb)</li>\n</ul>\n<h3><span style="text-decoration: underline;">H&aacute;tr&aacute;nyai a t&ouml;mbbel szemben:</span></h3>\n<ul>\n<li>Nem v&eacute;letlen el&eacute;r&eacute;s&#369; ( a t&ouml;mbbel ellent&eacute;tben), az elemekhez val&oacute; hozz&aacute;f&eacute;r&eacute;s line&aacute;ris idej&#369;: ugyanis egy csom&oacute;pont el&eacute;r&eacute;s&eacute;hez v&eacute;gig kell menni az &ouml;sszes &#337;t megel&#337;z&#337; elemen.</li>\n<li>Valamivel t&ouml;bb mem&oacute;ri&aacute;t ig&eacute;nyel, mint egy azonos m&eacute;ret&#369; t&ouml;mb: ugyanis a mutat&oacute;k extra mem&oacute;riaig&eacute;nyt jelentenek (m&eacute;g ha elhanyagolhat&oacute; is, nagyobb objektumok eset&eacute;n).</li>\n<li>Bizonyos m&#369;veleteket nehezebb rajta megval&oacute;s&iacute;tani: ilyenek p&eacute;ld&aacute;ul bizonyos rendez&#337; algoritmusok, amelyekn&eacute;l nagyon nagy seg&iacute;ts&eacute;g tud lenni a t&ouml;mb v&eacute;letlen el&eacute;r&eacute;se. Ez&eacute;rt c&eacute;lszer&#369; lehet a list&aacute;t csom&oacute;pontjait eleve rendezve besz&uacute;rni, ha sz&uuml;ks&eacute;g&uuml;nk van r&aacute;.</li>\n</ul>\n<p>Az egyszeresen l&aacute;ncolt lista eset&eacute;n egy csom&oacute;pontot C++ nyelven egy egyszer&#369; strukt&uacute;rak&eacute;nt megval&oacute;s&iacute;thatunk. (Term&eacute;szetesen ha m&aacute;r C++, adhatunk hozz&aacute; konstruktorokat, vagy egy&eacute;b f&uuml;ggv&eacute;nyeket is)</p>\n<pre><code>struct Node \n{\n     int value;\n     Node * next;\n}\n</code></pre>\n<p><em>K&eacute;tszeresen l&aacute;ncolt lista</em> eset&eacute;n m&eacute;g sz&uuml;ks&eacute;ges lehet egy <strong>* prev</strong> mutat&oacute; is, amivel az el&#337;z&#337;t jelezz&uuml;k. Ekkor ugyan valamivel t&ouml;bb figyelmet kell ford&iacute;tani a mutat&oacute;k helyes be&aacute;ll&iacute;t&aacute;s&aacute;ra (&eacute;s m&eacute;g t&ouml;bb mem&oacute;ri&aacute;t is ig&eacute;nyel), de megk&ouml;nny&iacute;theti a dolgunk, hogy <em>k&eacute;t ir&aacute;nyba tudunk haladni</em> a list&aacute;n. A tov&aacute;bbiakban viszont az egyszeresen l&aacute;ncolt list&aacute;r&oacute;l lesz sz&oacute;.</p>\n<p>Az egyszeresen l&aacute;ncolt list&aacute;hoz pedig k&eacute;sz&iacute;thet&uuml;nk egy oszt&aacute;lyt, ami a fontosabb m&#369;veleteit tartalmazza:</p>\n<ul>\n<li><span style="text-decoration: underline;">Besz&uacute;r&aacute;s (<strong>insert</strong>):</span> Eld&ouml;nthetj&uuml;k, hogy sorrendben sz&uacute;runk be, vagy egyszer&#369;en mindig az elej&eacute;re. Ha sorrendben, akkor meg kell keresn&uuml;nk a hely&eacute;t, ami $n$ elem&#369; lista eset&eacute;n legfeljebb $n$ m&#369;velet, vagyis $\\mathcal{O}(n)$. Az elej&eacute;re besz&uacute;r&aacute;s viszont konsans m&#369;veletig&eacute;ny&#369; b&aacute;rmilyen hossz&uacute; list&aacute;ra, vagyis $\\mathcal{O}(1)$.</li>\n<li><span style="text-decoration: underline;">T&ouml;rl&eacute;s (<strong>delNode</strong>):</span> Ez is t&ouml;rt&eacute;nhet t&ouml;bbf&eacute;lek&eacute;ppen: t&ouml;r&ouml;lhet&uuml;nk egyszer&#369;en az elej&eacute;r&#337;l (mint egy FIFO sor), vagy egy megadott index&#369; elemet megkeresve. Ha keresn&uuml;nk kell, az line&aacute;ris $\\mathcal{O}(n)$ m&#369;veletig&eacute;ny&#369;, az els&#337; elem let&ouml;rl&eacute;se viszont konstans $\\mathcal{O}(1)$&nbsp;m&#369;veletet ig&eacute;nyel.</li>\n<li>Ezeken k&iacute;v&uuml;l m&eacute;g megval&oacute;s&iacute;that&oacute; a <span style="text-decoration: underline;">keres&eacute;s(<strong>search</strong>)</span>, amikor az a k&eacute;rd&eacute;s, hogy benne van-e, illetve hol tal&aacute;lhat&oacute; a list&aacute;ban egy elem. Vagy &eacute;ppen a ford&iacute;tottja, hogy az adott indexen melyik elem tal&aacute;lhat&oacute;: hasonl&oacute;an az egyszer&#369; t&ouml;mb&ouml;k <strong>[</strong><span style="text-decoration: underline;"><strong> ]</strong> oper&aacute;tor&aacute;hoz</span>.</li>\n</ul>\n<p>A lista oszt&aacute;lynak teh&aacute;t mindenk&eacute;pp tartalmaznia kell <em>a lista fej&eacute;re</em> r&aacute;mutat&oacute; mutat&oacute;t (<strong>head</strong>), illetve opcion&aacute;lisan tartalmazhatja a lista m&eacute;ret&eacute;t is.</p>\n<pre><code>class LinkedList\n{\n     Node * head;\n     int size;\n\n     void insert(int elem);\n     void delNode(int index);\n     int get_size();\n     void print();\n     int search (int elem);\n     int &amp; operator[] (int index);\n}\n</code></pre>\n<h3><span style="text-decoration: underline;">Rendezett besz&uacute;r&aacute;s:</span></h3>\n<p>Ha meg akarjuk keresni a besz&uacute;r&aacute;s hely&eacute;t, akkor egy ciklussal <em>v&eacute;gig kell menn&uuml;nk</em> az &ouml;sszes <strong>Node * node</strong> elem r&aacute;k&ouml;vetkez&#337;j&eacute;n (<strong>node-&gt;next</strong>), am&iacute;g nincs meg a besz&uacute;r&aacute;s helye, vagyis<em> am&iacute;g a vizsg&aacute;lt elem &eacute;rt&eacute;ke kisebb, mint a besz&uacute;rand&oacute; kulcs</em> (<strong>elem</strong>). Ha ez teljes&uuml;l, ments&uuml;k el a r&aacute;k&ouml;vetkez&#337;t egy &uacute;j csom&oacute;pontk&eacute;nt (<strong>nextNode</strong>). Majd hozzunk l&eacute;tre egy &uacute;j csom&oacute;pontot: ugyanis lesz a jelenlegi elem (<strong>node</strong>) r&aacute;k&ouml;vetkez&#337;je, az &#337; r&aacute;k&ouml;vetkez&#337;je pedig az elmentett r&aacute;k&ouml;vetkez&#337;. A v&eacute;g&eacute;n persze n&ouml;velni kell a m&eacute;retet (<strong>size</strong>).</p>\n<pre><code>Node * node = head;\n&#47;&#47;Amig van rakovetkezo, es kisebb mint az elem (beszurasi hely megkeresese)\nwhile (node-&gt;next &amp;&amp; node-&gt;next-&gt;value &lt; elem)\n{\n     node = node-&gt;next;\n}\n\nNode * nextNode = node-&gt;next; &#47;&#47;rakovetkezo elmentese\nnode-&gt;next = new Node(elem, nextNode); &#47;&#47;beszuras az uj helyre\n++size; &#47;&#47;meret noveles -&gt; "extra" funkcio\n</code></pre>\n<p>A m&oacute;dszer kezdet&eacute;n viszont ellen&#337;rizni kell. hogy <em>nem els&#337; besz&uacute;r&aacute;s-e</em>: ha az, le kell foglalnunk az els&#337; elemet (<strong>head</strong>), &eacute;s n&ouml;velni (vagy egyre &aacute;ll&iacute;tani) <strong>size</strong> &eacute;rt&eacute;k&eacute;t. Tov&aacute;bb&aacute; ez nem veszi figyelembe azt az esetet sem, amikor <em>a legels&#337; helyre ker&uuml;lne az elem</em>, mivel a ciklus a node-&gt;next &eacute;rt&eacute;keit vizsg&aacute;lja. Ez&eacute;rt ezt az esetet&nbsp;is k&uuml;l&ouml;n kell vizsg&aacute;lni.</p>\n<pre><code>void insert(int elem)\n{\n     &#47;&#47;Ha ures a lista\n     if (head==NULL)\n     {\n         head = new Node(elem);\n         ++size;\n         return;\n     }\n\n     &#47;&#47;Ha az elem a beszrando legkisebb\n     if (elem &lt; head-&gt;value)\n     {\n         Node * nextNode = head;\n         head = new Node(elem, nextNode);\n         ++size;\n         return;\n     }\n\n     Node * node = head;\n     &#47;&#47;Amig van rakovetkezo, es kisebb mint az elem (beszurasi hely megkeresese)\n    while (node-&gt;next &amp;&amp; node-&gt;next-&gt;value &lt; elem)\n    {\n         node = node-&gt;next;\n    }\n\n    Node * nextNode = node-&gt;next; &#47;&#47;rakovetkezo elmentese\n    node-&gt;next = new Node(elem, nextNode); &#47;&#47;beszuras az uj helyre\n    ++size; &#47;&#47;meret noveles -&gt; "extra" funkcio\n}\n</code></pre>\n<h3><span style="text-decoration: underline;">T&ouml;rl&eacute;s index alapj&aacute;n</span></h3>\n<p>A t&ouml;rl&eacute;s m&#369;veletet &uacute;gy k&eacute;sz&iacute;tettem el, hogy a <em>bemen&#337; param&eacute;ter adja meg azt az indexet</em>, amelyiket ki szeretn&eacute;nk t&ouml;r&ouml;lni a list&aacute;b&oacute;l. Itt egy egyszer&#369; sz&aacute;ml&aacute;l&oacute;s <strong>for</strong> ciklus seg&iacute;ts&eacute;g&eacute;vel <em>l&eacute;pkedek a megadott index&#369; cs&uacute;cs el&#337;dj&eacute;ig</em> (<strong>prevNode</strong>) a list&aacute;n - persze figyeve, hogy v&eacute;ge-e a list&aacute;nak (a <strong>NULL</strong> pointer kellemetlen...) - Ha megtal&aacute;ltuk a t&ouml;rlend&#337; cs&uacute;cs el&#337;dj&eacute;t (<strong>prevNode</strong>), akkor hozz&aacute;l&aacute;ncoljuk a <strong>prevNode</strong> szomsz&eacute;djak&eacute;nt ez eddigi "m&aacute;sodik szomsz&eacute;dj&aacute;t" (nextNode), &eacute;s t&ouml;r&ouml;lj&uuml;k a t&ouml;rlend&#337; "els&#337; szomsz&eacute;dot" (<strong>delNode</strong>). A v&eacute;g&eacute;n pedig cs&ouml;kkentj&uuml;k a lista m&eacute;ret&eacute;t.</p>\n<pre><code>&#47;&#47;Torlendo csucs elodjenek megkeresese\nNode * prevNode = head;\nfor (int k=0; prevNode-&gt;next &amp;&amp; k&lt;index-1; ++k)\n{\n     prevNode = prevNode-&gt;next;\n}\nNode * nextNode = prevNode-&gt;next-&gt;next;\nNode * delNode = prevNode-&gt;next;\ncout&lt;&lt;"Node to delete: "&lt;value&lt;&lt;endl;\ndelete delNode;\nprevNode-&gt;next = nextNode;\n--size;\n</code></pre>\n<p>Persze itt is figyelni kell az<em> &uuml;res list&aacute;ra</em>, az<em> utols&oacute; elem t&ouml;rl&eacute;s&eacute;re</em>, illetve hogy a megadott <em>index megfelel&#337; tartom&aacute;nyba esik-e</em> (0 &eacute;s <strong>size</strong>-1 k&ouml;z&eacute;).</p>\n<h3><span style="text-decoration: underline;">Egy&eacute;b tagf&uuml;ggv&eacute;nyek:</span></h3>\n<p>A ki&iacute;rat&aacute;st (<strong>print</strong>) szerintem t&uacute;lmagyar&aacute;zni: <em>v&eacute;gig kell menni</em> az &ouml;sszes cs&uacute;cson, &eacute;s <em>ki&iacute;rni</em> a kulcs&eacute;rt&eacute;ket (<strong>value</strong>).</p>\n<pre><code>Node * node = head;\ndo\n{\n     cout&lt;value&lt;&lt;", ";\n     node = node-&gt;next;\n}\nwhile (node!=NULL);\n</code></pre>\n<p>A keres&eacute;s (<strong>search</strong>) elve is hasonl&oacute;: v&eacute;gigmenni a list&aacute;n, <em>am&iacute;g van r&aacute;k&ouml;vetkez&#337; &eacute;s az kisebb, mint az</em> <strong>elem</strong>. Ha van pontos tal&aacute;lat, akkor visszaadhatjuk a ciklus indexet, vagyis hogy h&aacute;nyszor futott le. Egy&eacute;bk&eacute;nt nincs meg a keresett elem.<br />Az index <strong>[] oper&aacute;torn&aacute;l</strong> pedig pontosan <em>a megadott sz&aacute;m&uacute; l&eacute;p&eacute;st</em> tesz&uuml;nk a list&aacute;n, &eacute;s visszaadjuk a megadott helyen l&eacute;v&#337; csom&oacute;pont &eacute;rt&eacute;k&eacute;t. Persze itt is c&eacute;lszer&#369; ellen&#337;rizni, hogy a megadott <strong>index</strong> <em>j&oacute; tartom&aacute;nyba esik-e</em>, a szegment&aacute;l&aacute;si hiba elker&uuml;l&eacute;se &eacute;rdek&eacute;ben.</p>\n<p>A teljes k&oacute;d megtal&aacute;lhat&oacute; a <a title="A program teljes forr&aacute;sk&oacute;dja" href="https:&#47;&#47;github.com/strahlistvan/algorithms/blob/master/linked_list.cpp" target="_blank">GitHubon</a>, a<a title="Egy&eacute;b algoritmus &eacute;s adatszerkezet implement&aacute;ci&oacute;im" href="https:&#47;&#47;github.com/strahlistvan/algorithms" target="_blank"> t&aacute;rsaival egy&uuml;tt</a>.</p>', '2016-03-25 04:23:10', '2016-03-25 05:06:47');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(67, 'comsciblog', 'Elemi adatszerkezetek 4. - Bináris keres&#337;fa vs láncolt lista', 'hu', '<p style="text-align: left;"><strong>Ma a bin&aacute;ris keres&#337;f&aacute;kr&oacute;l fogok &iacute;rni. A <a title="Elemi adatszerkezetek 3. - (Egyszeresen) l&aacute;ncolt list&aacute;k" href="http:&#47;&#47;comsciblog.esy.es/article/65/Elemi+adatszerkezetek+3.+-+%28Egyszeresen%29+l%C3%A1ncolt+list%C3%A1k" target="_blank">lista adatszerkezeteknek</a> (pl.: l&aacute;ncolt lista) sok el&#337;ny&uuml;k van, viszont h&aacute;tr&aacute;nya, hogy ha egy megadott adatot szeretn&eacute;nk benne megkeresni, v&eacute;gig kell j&aacute;rni a list&aacute;t, am&iacute;g meg nem tal&aacute;ljuk a megadott elemet. Vagyis legrosszabb esetben (ha a lista legv&eacute;g&eacute;n van a keresett elem) v&eacute;gig kell j&aacute;rni a teljes list&aacute;t, m&iacute;g &aacute;tlagos esetben k&ouml;r&uuml;lbel&uuml;l a lista fel&eacute;t, vagyis a keres&eacute;s line&aacute;ris. Ez&eacute;rt lehet hasznos a bin&aacute;ris keres&#337;fa adatszerkezet, ahol &aacute;tlagos esetben a fa magass&aacute;g&aacute;val ar&aacute;nyos a keres&eacute;s l&eacute;p&eacute;seinek sz&aacute;ma. Ez pedig logaritmikus.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/binary_search_tree.png" alt="Bin&aacute;ris keres&#337;fa" width="200" height="167" /></strong>P&eacute;lda bin&aacute;ris keres&#337;f&aacute;ra (<a title="Binary Search Tree - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Binary_search_tree" target="_blank">Wikip&eacute;dia</a>).</p>\n<h2>Mi is az a bin&aacute;ris keres&#337;fa? (Mi f&aacute;n terem?)</h2>\n<p>A bin&aacute;ris keres&#337;fa egy (nem felt&eacute;tlen teljes) <em>bin&aacute;ris fa</em>. Ez azt jelenti, van pontosan <em>egy gy&ouml;k&eacute;r</em> cs&uacute;csa, &eacute;s <em>minden cs&uacute;cs&aacute;nak legfeljebb k&eacute;t lesz&aacute;rmazottja</em> lehet. A fa tulajdons&aacute;gb&oacute;l kifoly&oacute;lag a gy&ouml;k&eacute;rb&#337;l minden elemhez pontosan egy &uacute;ton lehet eljutni. A bin&aacute;ris keres&#337;fa a l&aacute;ncolt list&aacute;hoz cs&uacute;csok &ouml;sszef&#369;z&eacute;s&eacute;b&#337;l &aacute;ll. A cs&uacute;csokhoz ebben az esetben is tartozik egy-egy &eacute;rt&eacute;k, valamint mutat&oacute; a sz&uuml;l&#337; cs&uacute;csra, valamint a bal &eacute;s jobb gyerek cs&uacute;csra.</p>\n<pre><code>struct TreeNode\n{\n int value;\n TreeNode * parent;\n TreeNode * leftChild, * rightChild;\n}\n</code></pre>\n<p>A bin&aacute;ris keres&#337;fa tulajdons&aacute;ga, hogy minden sz&uuml;l&#337; &eacute;rt&eacute;ke nagyobb, mint a bal gyerek&eacute;, &eacute;s kisebb, mint a jobb gyerek&eacute;. Ez fogja biztos&iacute;tani, hogy keres&eacute;s eset&eacute;n minden cs&uacute;csban tudjuk, hogy merre induljunk el a f&aacute;ban. Ha a keresett &eacute;rt&eacute;k kisebb, mint a cs&uacute;cs, balra indulunk, ha nagyobb, akkor jobbra (Ha pedig ugyanakkora, akkor megtal&aacute;ltuk.)&nbsp;<img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/binary_search_tree_search.gif" alt="Keres&eacute;s bin&aacute;ris keres&#337;f&aacute;ban" width="450" height="378" />Logaritmikus keres&eacute;s bin&aacute;ris keres&#337;f&aacute;ban (illetve rendezett t&ouml;mbben). A nagyszer&#369; k&eacute;pet k&ouml;sz&ouml;n&ouml;m a <a title="5 Gifs to Understand Binary Search Trees" href="https:&#47;&#47;blog.penjee.com/5-gifs-to-understand-binary-search-tree/">penjee.com</a> blogj&aacute;nak.</p>\n<p>A keres&#337;fa C++ nyelv&#369; implement&aacute;l&aacute;s&aacute;ra k&eacute;sz&iacute;thet&uuml;nk egy oszt&aacute;lyt, aminek egyetlen tulajdons&aacute;ga a gy&ouml;k&eacute;rre mutat&oacute; pointer (<strong>TreeNode * root</strong>). Az oszt&aacute;ly teh&aacute;t a k&ouml;vetkez&#337;k&eacute;ppen n&eacute;z ki:</p>\n<pre><code>class BinTree \n{\n	TreeNode * root;\n	\n	public: \n	\n	BinTree() \n	{\n	 root = NULL;\n	}\n	\n	BinTree(int value)\n	{\n	 root = new TreeNode(value);\n	}\n}\n</code></pre>\n<p>A tov&aacute;bbiakban a oszt&aacute;ly legfontosabb met&oacute;dusait mutatom be egyes&eacute;vel.</p>\n<h3>Keres&eacute;s</h3>\n<p>Az adatszerkezeten t&ouml;rt&eacute;n&#337; keres&eacute;s egyszer&#369;en megoldhat&oacute; rekurzi&oacute; seg&iacute;ts&eacute;g&eacute;vel:</p>\n<pre><code>int searchRec(int key, TreeNode * node)\n{\n static int foundValue = -1;\n if (node==NULL)\n return foundValue;\n	\n if (node-&gt;value == key)\n {\n	foundValue = key;\n	return foundValue;\n }\n	 \n if (node-&gt;value &lt; key)\n    searchRec(key, node-&gt;leftChild);\n else\n    searchRec(key, node-&gt;rightChild);\n}\n</code></pre>\n<p>A fenti f&uuml;ggv&eacute;ny a gy&ouml;k&eacute;rre megh&iacute;vva visszaadja a keresett &eacute;rt&eacute;ket, ha megtal&aacute;lhat&oacute; a f&aacute;ban. Ha nem, -1-gyel t&eacute;r vissza. A keres&eacute;s azonban megoldhat&oacute; hat&eacute;konyabban is, kik&uuml;sz&ouml;b&ouml;lve a rekurz&iacute;v h&iacute;v&aacute;sokat. A keres&eacute;s iterat&iacute;v v&aacute;ltozata:</p>\n<pre><code> \nint search(int key)\n{\n	TreeNode * node = this-&gt;root;\n	while (node!=NULL &amp;&amp; node-&gt;value!=key)\n	{\n	 if (key &lt; node-&gt;value)\n	    node = node-&gt;leftChild;\n	 else\n	    node = node-&gt;rightChild;\n	}\n	\n	if (node==NULL)\n	 return -1;\n	if (node-&gt;value == key)\n	 return node-&gt;value;\n}\n</code></pre>\n<p>Az adatszerkezet nagy el&#337;nye a keres&eacute;s hat&eacute;konys&aacute;ga. M&iacute;g egy l&aacute;ncolt lista eset&eacute;n &aacute;tlagosan $\\mathcal{O}(n)$ l&eacute;p&eacute;s alatt tal&aacute;ljuk meg a keresett elemet, addig a bin&aacute;ris keres&#337;fa keres&eacute;s&eacute;nek hat&eacute;konys&aacute;ga $\\mathcal{O}(log\\,n)$, ugyanis egy $n$ cs&uacute;cs&uacute; teljes bin&aacute;ris fa eset&eacute;n $log_2(n)$ l&eacute;p&eacute;ssel b&aacute;rmely cs&uacute;cshoz eljuthatunk.</p>\n<h3>Besz&uacute;r&aacute;s</h3>\n<p>A bin&aacute;ris keres&#337;f&aacute;ba t&ouml;rt&eacute;n&#337; besz&uacute;r&aacute;shoz el&#337;sz&ouml;r is <em>meg kell hat&aacute;rozni a besz&uacute;r&aacute;s hely&eacute;t</em>. Ez gyakorlatilag egy keres&eacute;si feladat: gy&ouml;k&eacute;rt&#337;l indulva hol jobbra, hol balra l&eacute;pve megkeresi a besz&uacute;r&aacute;si helyet. A besz&uacute;rand&oacute; hely a fa egyik levele, aminek &uacute;j bal vagy jobb lesz&aacute;rmazottjak&eacute;nt sz&uacute;rjuk be az &uacute;j cs&uacute;csot.<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/binary_search_tree_insert.gif" alt="Bin&aacute;ris keres&#337;f&aacute;ba besz&uacute;r&aacute;s" width="400" height="255" />Bin&aacute;ris keres&#337;fa &eacute;p&iacute;t&eacute;se elemenk&eacute;nti besz&uacute;r&aacute;ssal. A k&eacute;p forr&aacute;sa szint&eacute;n a&nbsp;<a title="5 Gifs to Understand Binary Search Trees" href="https:&#47;&#47;blog.penjee.com/5-gifs-to-understand-binary-search-tree/">penjee.com</a>.<br />Aki esetleg ki szeretn&eacute; pr&oacute;b&aacute;lni a bin&aacute;ris f&aacute;ba besz&uacute;r&aacute;st, annak aj&aacute;nlom ezt az interakt&iacute;v vizualiz&aacute;ci&oacute;t: <a href="https:&#47;&#47;www.cs.usfca.edu/~galles/visualization/BST.html" target="_blank">Binary Search Tree visualization</a><br /><br /></p>\n<pre><code>int insert(int key)\n{\n	&#47;&#47;Find the insert place\n	TreeNode * node = this-&gt;root;\n	TreeNode * parentNode = NULL;\n	while (node!=NULL)\n	{\n	   parentNode = node;	\n	   if (key &lt; node-&gt;value)\n		node = node-&gt;leftChild;\n	   else\n		node = node-&gt;rightChild;\n	 }\n		\n	&#47;&#47;Insert to node to the good place\n	TreeNode * insertNode = new TreeNode(key);\n	insertNode-&amp;gt,parent = parentNode; \n		\n	if (parentNode == NULL)\n		this-&gt;root = insertNode;\n	else if (key &lt; parentNode-&gt;value)\n		parentNode-&gt;leftChild = insertNode;\n	else\n		parentNode-&gt;rightChild = insertNode;\n}\n</code> </code></pre>\n<p>A keres&eacute;shez hasonl&oacute;an a besz&uacute;r&aacute;s is &aacute;tlagosan $\\mathcal{O}(log\\,n)$ fut&aacute;sidej&#369;. A legrosszabb besz&uacute;r&aacute;si eset, amikor a cs&uacute;csokat sorrendben sz&uacute;rjuk be. Ekkor ugyanis mindig ugyanabba az ir&aacute;nyba l&eacute;p, vagyis minden cs&uacute;csnak kiz&aacute;r&oacute;lag csak a bal (vagy csak a jobb) mutat&oacute;j&aacute;t haszn&aacute;lja fel. Teh&aacute;t l&aacute;ncolt list&aacute;v&aacute; amortiz&aacute;l&oacute;dik a fa, ahol a keres&eacute;si id&#337; line&aacute;ris.<br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/amort_search_tree.gif" alt="A legrosszabb eset, amikor a f&aacute;ba sorban sz&uacute;runk be." width="400" height="220" /><br />A legrosszabb eset, amikor a f&aacute;ba sorban sz&uacute;runk be: <a href="http:&#47;&#47;www.brpreiss.com/books/opus4/html/page305.html" target="_blank">brpreiss.com</a></p>\n<h3>Fa ki&iacute;rat&aacute;sa</h3>\n<p>Ha m&aacute;r van egy adatszerkezet&uuml;nk, k&iacute;v&aacute;ncsiak lehet&uuml;nk a tartalm&aacute;ra. A ki&iacute;rat&aacute;s legegyszer&#369;bb m&oacute;dja az egyszer&#369; rekurz&iacute;v fabej&aacute;r&aacute;s. P&eacute;ld&aacute;ul ha a fa elemeit sorba rendezve szeretn&eacute;nk l&aacute;tni, ahhoz <a title="BME InfoC oldala" href="https:&#47;&#47;infoc.eet.bme.hu/ea12/#7" target="_blank">inorder bej&aacute;r&aacute;ssal</a> kell ki&iacute;ratnunk a fa kulcsait (Vagyis k&eacute;t r&eacute;szf&aacute;ra t&ouml;rt&eacute;n&#337; f&uuml;ggv&eacute;nyh&iacute;v&aacute;s k&ouml;z&ouml;tt).</p>\n<pre><code>void printLikeListRec(TreeNode * node)\n{\n	if (node == NULL)\n	 return;\n		\n	printLikeListRec(node-&gt;leftChild);\n	cout&lt;&lt;node-&gt;value&lt;&lt;", ";\n	printLikeListRec(node-&gt;rightChild);\n}\n</code></pre>\n<p>Ha azonban szeretn&eacute;nk l&aacute;tni a fa szerkezet&eacute;t is, azt jel&ouml;lhetj&uuml;k p&eacute;ld&aacute;ul beh&uacute;z&aacute;sokkal. Ekkor a preorder bej&aacute;r&aacute;st kell haszn&aacute;lni, vagyis el&#337;sz&ouml;r ki&iacute;rni a cs&uacute;csot, majd tov&aacute;bbl&eacute;pni a megfelel&#337; ir&aacute;nyba:</p>\n<pre><code>void printRec(TreeNode * node, int level)\n{\n    if (node==NULL)\n	return;\n		\n     cout&lt;&lt;level&lt;&lt;&rdquo;. level: &rdquo;;\n     for (int i=0; i&lt;level; ++i)\n	cout&lt;&lt;"--";\n     cout&lt;&lt;"- ("&lt;&lt;node-&gt;value&lt;&lt;")"&lt;&lt;endl;</code><code>	\n      <br />     printRec(node-&gt;leftChild, level+1);\n     printRec(node-&gt;rightChild, level+1);\n}\n</code></pre>\n<h3>A bin&aacute;ris fa &eacute;s a l&aacute;ncolt lista keres&eacute;si hat&eacute;konys&aacute;g&aacute;nak &ouml;sszehasonl&iacute;t&aacute;sa</h3>\n<p>Ha m&aacute;r ennyit besz&eacute;ltem a hat&eacute;kony keres&eacute;sr&#337;l, <em>c&eacute;lszer&#369; lehet letesztelni</em>, hogy mennyivel jobb a keres&#337;fa &aacute;ltal &iacute;g&eacute;rt logaritmikus keres&eacute;s a line&aacute;ris, list&aacute;ban t&ouml;rt&eacute;n&#337; keres&eacute;ssel szemben. A meg&iacute;rt adatszerkezeteket ugyanazzal a 100 000 v&eacute;letlen sz&aacute;mmal t&ouml;lt&ouml;ttem fel. Mindig ugyanazokat a sz&aacute;mokat haszn&aacute;ltam, az <strong>srand(0)</strong> seed &aacute;ltal visszaadott 100 000 hossz&uacute;s&aacute;g&uacute; pszeudov&eacute;letlen sz&aacute;msorozatot (0 &eacute;s <strong>RAND_MAX</strong>, azaz kb. 2 milli&aacute;rd k&ouml;z&ouml;tt).</p>\n<p>Egy-egy keres&eacute;sen azonban nem l&aacute;tszik a sebess&eacute;gbeli k&uuml;l&ouml;nbs&eacute;g, ez&eacute;rt k&uuml;l&ouml;nb&ouml;z&#337; mennyis&eacute;g&#369; v&eacute;letlen sorozatokat gener&aacute;ltam, mindig ugyanazzal a seeddel ( <strong>srand(42)</strong> ) A kapott eredm&eacute;nyeket az al&aacute;bbi t&aacute;bl&aacute;zat tartalmazza. Az els&#337; oszlopban a keres&eacute;sek sz&aacute;ma olvashat&oacute;.</p>\n<p>A k&ouml;vetkez&#337; k&eacute;t oszlopban az olvashat&oacute;, hogy a mennyi ideig tartott ennek a sok keres&eacute;snek a lefut&aacute;sa a list&aacute;n, illetve a keres&#337;f&aacute;n. A negyedik oszlop adatait pedig ink&aacute;bb csak ellen&#337;rz&eacute;sre haszn&aacute;ltam. Ez mutatja ugyanis, hogy mennyi tal&aacute;lat volt a sok keres&eacute;sb&#337;l. (Ha ez a sz&aacute;m k&uuml;l&ouml;nb&ouml;z&ouml;tt volna a k&eacute;t algoritmus futtat&aacute;sa eset&eacute;n, akkor valamelyik val&oacute;sz&iacute;n&#369;leg hib&aacute;s.)</p>\n<table width="454" cellspacing="0" cellpadding="6">\n<thead>\n<tr bgcolor="#ffffff">\n<th width="124">\n<p class="western"><strong>Count of searching</strong></p>\n</th>\n<th width="76">\n<p class="western"><strong>List time [s]</strong></p>\n</th>\n<th width="80">\n<p class="western"><strong>Tree time [s]</strong></p>\n</th>\n<th width="124">\n<p class="western"><strong>Founded Elements</strong></p>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr bgcolor="#ffffff">\n<td width="124">\n<p class="western">1000</p>\n</td>\n<td width="76">\n<p class="western">0.53</p>\n</td>\n<td width="80">\n<p class="western">0</p>\n</td>\n<td width="124">\n<p class="western">0</p>\n</td>\n</tr>\n<tr bgcolor="#f8f8f8">\n<td width="124">\n<p class="western">10000</p>\n</td>\n<td width="76">\n<p class="western">5.19</p>\n</td>\n<td width="80">\n<p class="western">0.00</p>\n</td>\n<td width="124">\n<p class="western">0</p>\n</td>\n</tr>\n<tr bgcolor="#ffffff">\n<td width="124">\n<p class="western">100000</p>\n</td>\n<td width="76">\n<p class="western">54.3</p>\n</td>\n<td width="80">\n<p class="western">0.04</p>\n</td>\n<td width="124">\n<p class="western">3</p>\n</td>\n</tr>\n<tr bgcolor="#f8f8f8">\n<td width="124">\n<p class="western">200000</p>\n</td>\n<td width="76">\n<p class="western">105.23</p>\n</td>\n<td width="80">\n<p class="western">0.09</p>\n</td>\n<td width="124">\n<p class="western">9</p>\n</td>\n</tr>\n<tr bgcolor="#ffffff">\n<td width="124">\n<p class="western">500000</p>\n</td>\n<td width="76">\n<p class="western">264.33</p>\n</td>\n<td width="80">\n<p class="western">0.22</p>\n</td>\n<td width="124">\n<p class="western">25</p>\n</td>\n</tr>\n<tr bgcolor="#f8f8f8">\n<td width="124">\n<p class="western">1000000</p>\n</td>\n<td width="76">\n<p class="western">542.79</p>\n</td>\n<td width="80">\n<p class="western">0.41</p>\n</td>\n<td width="124">\n<p class="western">47</p>\n</td>\n</tr>\n<tr bgcolor="#ffffff">\n<td width="124">\n<p class="western">10M</p>\n</td>\n<td width="76">\n<p class="western">-</p>\n</td>\n<td width="80">\n<p class="western">3.78</p>\n</td>\n<td width="124">\n<p class="western">410</p>\n</td>\n</tr>\n<tr bgcolor="#f8f8f8">\n<td width="124">\n<p class="western">20M</p>\n</td>\n<td width="76">\n<p class="western">-</p>\n</td>\n<td width="80">\n<p class="western">7.53</p>\n</td>\n<td width="124">\n<p class="western">852</p>\n</td>\n</tr>\n<tr bgcolor="#ffffff">\n<td width="124">\n<p class="western">40M</p>\n</td>\n<td width="76">\n<p class="western">-</p>\n</td>\n<td width="80">\n<p class="western">14.96</p>\n</td>\n<td width="124">\n<p class="western">1735</p>\n</td>\n</tr>\n<tr bgcolor="#f8f8f8">\n<td width="124">\n<p class="western">80M</p>\n</td>\n<td width="76">\n<p class="western">-</p>\n</td>\n<td width="80">\n<p class="western">30.31</p>\n</td>\n<td width="124">\n<p class="western">3586</p>\n</td>\n</tr>\n<tr bgcolor="#ffffff">\n<td width="124">\n<p class="western">160M</p>\n</td>\n<td width="76">\n<p class="western">-</p>\n</td>\n<td width="80">\n<p class="western">63.33</p>\n</td>\n<td width="124">\n<p class="western">7389</p>\n</td>\n</tr>\n</tbody>\n</table>\n<p>A m&eacute;r&eacute;sek sor&aacute;n j&oacute;l l&aacute;tszik, hogy a l&aacute;ncolt list&aacute;ban t&ouml;rt&eacute;n&#337; keres&eacute;s j&oacute;val lassabb, mint a keres&#337;f&aacute;ban t&ouml;rt&eacute;n&#337; keres&eacute;s. A 6. sorban 1000000 keres&eacute;ssel is v&eacute;gzett a bin&aacute;ris keres&eacute;s egy m&aacute;sodpercen bel&uuml;l, m&iacute;g a list&aacute;ban t&ouml;rt&eacute;n&#337; keres&eacute;s 542 m&aacute;sodpercig, vagyis t&ouml;bb, mint 9 percig futott.</p>\n<p>Szint&eacute;n j&oacute;l megfigyelhet&#337; a keres&eacute;s line&aacute;ris tulajdons&aacute;ga: amikor t&iacute;zszeres&eacute;re n&ouml;veltem a keres&eacute;sek sz&aacute;m&aacute;t (feladat m&eacute;ret&eacute;t), akkor a fut&aacute;sid&#337; is k&ouml;zel t&iacute;zszeres&eacute;re n&#337;tt, p&eacute;ld&aacute;ul 2. &eacute;s 3. oszlop k&ouml;z&ouml;tt. Amikor a feladat dupl&aacute;j&aacute;ra n&#337;tt, akkor nagyj&aacute;b&oacute;l dupl&aacute;z&oacute;dott a fut&aacute;sid&#337; is.</p>\n<p>Viszont sajnos a bin&aacute;ris keres&eacute;sn&eacute;l is ink&aacute;bb line&aacute;ris &ouml;sszef&uuml;gg&eacute;s j&ouml;tt ki, mint logaritmikus. Ugyanis ha p&eacute;ld&aacute;ul a 10 milli&oacute; &eacute;s a 160 milli&oacute; k&ouml;z&ouml;tti fut&aacute;sid&#337;t n&eacute;zz&uuml;k, a k&uuml;l&ouml;nbs&eacute;g 16-szoros. Ha val&oacute;ban logaritmikus lenne, akkor a feladat m&eacute;ret&eacute;nek 16-szoros n&ouml;vel&eacute;s&eacute;vel a fut&aacute;si id&#337;nek mind&ouml;ssze $log_2(16) = 4$-szeresnek szabadna lennie. Val&oacute;sz&iacute;n&#369;leg az&eacute;rt van, mert nem kiegyenl&iacute;tett a fa, hanem bizonyos &aacute;gai sokkal hosszabbak, mintha kiegyenl&iacute;tett lenne. De az&eacute;rt semmi ok a p&aacute;nikra, a fa &iacute;gy is v&eacute;gzett 160 milli&oacute; keres&eacute;ssel alig t&ouml;bb, mint egy perc alatt. Ez a l&aacute;ncolt list&aacute;nak (t&ouml;k&eacute;letes line&aacute;ris n&ouml;veked&eacute;ssel sz&aacute;molva) $542,79 \\cdot 160 = 83966,4$ m&aacute;sodpercbe, vagyis t&ouml;bb, mint 23 &oacute;r&aacute;ba telne.<br /><br />A program teljes forr&aacute;sk&oacute;dja megtal&aacute;lhat&oacute; a <a title="List vs Tree repository" href="https:&#47;&#47;github.com/strahlistvan/algorithms/tree/master/List_vs_Tree">GitHubon</a>.</p>', '2016-06-10 03:55:05', '2016-06-10 04:57:26'),
(68, 'comsciblog', 'Notepad++ bemutató', 'hu', '<p><strong>A k&ouml;vetkez&#337; bejegyz&eacute;sben az (egyik) kedvenc sz&ouml;vegszerkeszt&#337;mr&#337;l, a Notepad++-r&oacute;l fogok egy r&ouml;vid bemutat&oacute;, &aacute;ttekint&#337; le&iacute;r&aacute;st adni. B&aacute;r j&oacute;val kevesebb funkci&oacute;ja van egy hagyom&aacute;nyos IDE-hez k&eacute;pest, de b&#337;v&iacute;thet&#337; &eacute;s testre szabhat&oacute;. Viszonylag kis t&aacute;rhely- &eacute;s mem&oacute;ria- &eacute;s g&eacute;pig&eacute;ny&#369;, ugyanakkor nekem k&eacute;nyelmesebb, mint egy parancssoros szerkeszt&#337; (pl.: vim, mcedit &eacute;s t&aacute;rsai) &eacute;s bizonyos feladatok eset&eacute;n k&ouml;nnyebb haszn&aacute;lni, mint egy profi integr&aacute;lt fejleszt&#337;k&ouml;rnyezetet (nem olyan k&ouml;nny&#369; "elt&eacute;vedni" a sok funkci&oacute; k&ouml;z&ouml;tt). Ingyenes &eacute;s ny&iacute;lt forr&aacute;sk&oacute;d&uacute;, viszont el&eacute;gg&eacute; Windows-f&uuml;gg&#337;, Linux felhaszh&aacute;l&oacute;knak sz&uuml;ks&eacute;g&uuml;k lehet Wine-ra a haszn&aacute;lat&aacute;hoz.<br /></strong><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad01.png" alt="Notepad++ &uacute;j, &uuml;res lap" width="500" height="266" /></p>\r\n<ol>\r\n<li>T&ouml;lts&uuml;k le (p&eacute;ld&aacute;ul a <a title="Notepad++ let&ouml;lt&eacute;se" href="https:&#47;&#47;notepad-plus-plus.org/download/v6.9.2.html" target="_blank">Notepad++ hivatalos oldal&aacute;r&oacute;l</a>) &eacute;s telep&iacute;ts&uuml;k fel a Notepad++ programot, vagy haszn&aacute;lhatjuk ak&aacute;r Portable verzi&oacute;t is. N&eacute;h&aacute;ny MB az eg&eacute;sz. A p&eacute;ld&aacute;k sor&aacute;n &eacute;n a 6.1.7. Portable verzi&oacute;j&aacute;t haszn&aacute;lom. El&#337;fordulhat, hogy kicsit m&aacute;sk&eacute;pp n&eacute;znek ki a men&uuml;k az &uacute;jabb/r&eacute;gebbi verzi&oacute;kban.<br /><br /></li>\r\n<li style="text-align: left;">&Uacute;j lapot k&eacute;rve (szok&aacute;sos m&oacute;don, <strong>File</strong> men&uuml; seg&iacute;ts&eacute;g&eacute;vel) m&aacute;r g&eacute;pelhet&uuml;nk is. &Uuml;gyelj&uuml;nk a megfelel&#337; karakterk&oacute;dol&aacute;sra. A leggyakoribb karakterk&oacute;dol&aacute;s az UTF-8, de haszn&aacute;lhatjuk tetsz&#337;leges orsz&aacute;g ASCII k&oacute;dt&aacute;bl&aacute;j&aacute;t is. Ez az <strong>Encoding (K&oacute;dol&aacute;s)</strong> men&uuml;ben &aacute;ll&iacute;that&oacute; be.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad02_encoding.png" alt="" width="500" height="288" /><sub>A k&eacute;t leggyakoribb k&oacute;dol&aacute;s, illetve &aacute;t&aacute;ll&iacute;t&aacute;sa Notepad++-ban. Bal oldalon <a title="UTF-8 Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/UTF-8" target="_blank">UTF-8</a> k&oacute;dol&aacute;s&uacute; sz&ouml;veg van <a title="ASCII Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a>&nbsp;sz&ouml;vegk&eacute;nt (rosszul) k&oacute;dolva, jobb oldalon pont ford&iacute;tva.</sub><br /><br /></li>\r\n<li>Programoz&aacute;shoz, k&oacute;dok &iacute;r&aacute;s&aacute;hoz&nbsp;c&eacute;lszer&#369; haszn&aacute;lni a Notepad++ szintaxiskiemel&#337; eszk&ouml;z&eacute;t. Ez a<strong> Language (Nyelv)</strong> men&uuml;ben &aacute;ll&iacute;that&oacute; be, de ha a megfelel&#337; kiterjeszt&eacute;ssel mentj&uuml;k a sz&ouml;vegf&aacute;jt, a szerkeszt&#337; automatikusan be&aacute;ll&iacute;tja a szerinte legmegfelel&#337;bb kiemel&eacute;st.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad03_syntax.png" alt="Notepad++ szintaxis kiemel&eacute;s" width="500" height="264" /></li>\r\n<li>A Notepad++ sok&nbsp;nyelven haszn&aacute;lhat&oacute;. Nyelv kiv&aacute;laszt&aacute;sa<strong>&nbsp;Settings/Preferences</strong> men&uuml;ben&nbsp;lehets&eacute;ges. (<strong>Be&aacute;ll&iacute;t&aacute;sok/Programbe&aacute;ll&iacute;t&aacute;sok</strong>) Az el&#337;re ugr&oacute; ablakon a <strong>General (&Aacute;ltal&aacute;nos)</strong> f&uuml;l&ouml;n kiv&aacute;laszthat&oacute;, hogy milyen nyelven szeretn&eacute;nk haszn&aacute;lni a programot. A tov&aacute;bbiakban <em>magyarul</em> fogom haszn&aacute;lni.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad04_lang.png" alt="Nyelv v&aacute;laszt&aacute;s Notepad++-ban" width="500" height="264" /><br /><br /></li>\r\n<li>Ugyanebben az ablakban (<strong>Be&aacute;ll&iacute;t&aacute;sok/Programbe&aacute;ll&iacute;t&aacute;sok</strong>), a&nbsp;&nbsp;<strong>Biztons&aacute;gi m&aacute;solat/Kieg&eacute;sz&iacute;t&eacute;s </strong>f&uuml;l&ouml;n&nbsp;be&aacute;ll&iacute;that&oacute;, hogy biztons&aacute;gi m&aacute;solatot k&eacute;sz&iacute;tsen a szerkesztett f&aacute;jlokr&oacute;l, &iacute;gy ha v&eacute;letlen let&ouml;r&ouml;ln&eacute;nk a f&aacute;jlt, a biztons&aacute;gi m&aacute;solatok k&ouml;z&ouml;tt ott lesz a f&aacute;jlunk a megadott mapp&aacute;ban <strong>.bak</strong> kiterjeszt&eacute;ssel. Haszn&aacute;lja mindenki &iacute;zl&eacute;se szerint.<br /> Az alatta l&eacute;v&#337; <strong>&apos;Automatikus kieg&eacute;sz&iacute;t&eacute;s&apos;</strong> panel viszont nagy seg&iacute;ts&eacute;g lehet k&oacute;dol&aacute;s k&ouml;zben. K&eacute;tf&eacute;le kieg&eacute;sz&iacute;t&eacute;s lehets&eacute;ges: nyelv- &eacute;s sz&ouml;vegf&uuml;gg&#337;. Amennyiben f&#337;k&eacute;nt k&oacute;dol&aacute;sra haszn&aacute;ljuk a szerkeszt&#337;t, c&eacute;lszer&#369; a nyelvf&uuml;gg&#337; opci&oacute;t v&aacute;lasztani, m&iacute;g hossz&uacute; sz&ouml;vegek eset&eacute;n a sz&ouml;vegf&uuml;gg&#337;t. (Az &uacute;jabb vezi&oacute;kban a kett&#337; kombin&aacute;lhat&oacute; is, illetve be&aacute;ll&iacute;that&oacute;, hogy automatikusan z&aacute;rja le az id&eacute;z&#337; &eacute;s z&aacute;r&oacute;jeleket is.)<br /><br /></li>\r\n<li>Lehet&#337;s&eacute;g&uuml;nk van be&aacute;ll&iacute;tani k&uuml;l&ouml;nb&ouml;z&#337; sz&iacute;nez&eacute;si st&iacute;lusokat Notepad++-ben. Ezt a <strong>Be&aacute;ll&iacute;t&aacute;sok/St&iacute;lus be&aacute;ll&iacute;t&aacute;sai</strong> men&uuml;ben &eacute;rhetj&uuml;k el. Term&eacute;szetesen saj&aacute;t st&iacute;lust is k&eacute;sz&iacute;thet&uuml;nk, vagy testre szabhatjuk a m&aacute;r megl&eacute;v&#337;ket, ha egyik sem felelne meg az ig&eacute;nyeinknek.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad06_stilus.png" alt="K&eacute;tf&eacute;le Notepad++ st&iacute;lus" width="550" height="238" /><br />\r\n<h3>B&#337;v&iacute;tm&eacute;nyek hozz&aacute;ad&aacute;sa</h3>\r\nA Notepad++ igazi ereje a <em>b&#337;v&iacute;tm&eacute;nyekben</em> rejlik. A <strong>B&#337;v&iacute;tm&eacute;nyek</strong> men&uuml;ben a <strong>Plugin Manager</strong> seg&iacute;ts&eacute;g&eacute;vel lehet&#337;s&eacute;gek sz&eacute;les sk&aacute;l&aacute;ja t&aacute;rul el&eacute;nk, hogy felokos&iacute;tsuk (kedvenc) szerkeszt&#337;nket. A<strong> B&#337;v&iacute;tm&eacute;nyek/Plugin Manager/Show Plugin Manager</strong> kattint&aacute;s ut&aacute;n a felugr&oacute; ablakban kiv&aacute;laszthatjuk a v&aacute;lasztott b&#337;v&iacute;tm&eacute;nyt, &eacute;s az <strong>Install</strong> gomb megnyom&aacute;s&aacute;val telep&iacute;thetj&uuml;k. (Az &eacute;letbe l&eacute;p&eacute;shez a szerkeszt&#337; &uacute;jraind&iacute;t&aacute;sa sz&uuml;ks&eacute;ges lehet)<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad07_plugin.png" alt="B&#337;v&iacute;tm&eacute;ny hozz&aacute;ad&aacute;sa a Notepad++hoz." width="500" height="266" /><sub>B&#337;v&iacute;tm&eacute;ny hozz&aacute;ad&aacute;sa a Notepad++ sz&ouml;vegszerkeszt&#337;hoz a Plugin Manager seg&iacute;ts&eacute;g&eacute;vel.</sub></li>\r\n</ol>\r\n<ul>\r\n<li>&nbsp;<span style="text-decoration: underline;">Explorer:</span> F&aacute;jl tall&oacute;z&oacute; b&#337;v&iacute;tm&eacute;ny. A seg&iacute;t&eacute;s&eacute;g&eacute;vel egy ablakban l&aacute;thatjuk a munkak&ouml;nyvt&aacute;runk f&aacute;jljait &eacute;s mapp&aacute;it &eacute;s az &eacute;ppen szerkesztett sz&ouml;veget. &Iacute;gy nem kell mindig ugr&aacute;lni a t&aacute;lc&aacute;n, ami sok esetben k&eacute;nyelmesebb&eacute; teheti a munk&aacute;t. A bekapcsolni a<strong> B&#337;v&iacute;tm&eacute;nyek/Explorer/Exporer&hellip;</strong> men&uuml;ben lehet, vagy a Notepad++ b&#337;v&iacute;tm&eacute;nyeknek fenntartott eszk&ouml;zt&aacute;r&aacute;n l&eacute;v&#337; megfelel&#337; ikonra kattintva.<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad08_explorer.png" alt="Notepad++ Explorer b&#337;v&iacute;tm&eacute;ny" width="500" height="265" /></li>\r\n<li><span style="text-decoration: underline;"><strong>DSpellCheck:</strong></span> Ahogy a neve is mutatja, <em>helyes&iacute;r&aacute;s-ellen&#337;rz&#337;</em> b&#337;v&iacute;tm&eacute;ny (spell checker). A haszn&aacute;lat&aacute;hoz a telep&iacute;t&eacute;s&eacute;n k&iacute;v&uuml;l le kell t&ouml;lteni a megfelel&#337; nyelv sz&oacute;t&aacute;r&aacute;t. A telep&iacute;t&eacute;s ut&aacute;n gy&#337;z&#337;dj&uuml;nk meg, hogy a <strong>B&#337;v&iacute;tm&eacute;nyek/DSpellCheck/Spell Check Document Automatically</strong> be van-e pip&aacute;lva (Alt+A), tov&aacute;bb&aacute;, hogy a megfelel&#337; nyelv van-e be&aacute;ll&iacute;tva (<strong>Change Current Language</strong>, vagy Alt+D).<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad09_spellcheck.png" alt="Notepad++ spell checker" width="500" height="266" /><br /><br /></li>\r\n<li><span style="text-decoration: underline;"><strong>NppFTP:</strong></span> FTP kapcsol&oacute;d&aacute;st tesz lehet&#337;v&eacute;, &eacute;s ezzel (FTP) t&aacute;rhely&uuml;nk el&eacute;r&eacute;s&eacute;t teszi lehet&#337;v&eacute; a sz&ouml;vegszerkeszt&#337;n bel&uuml;l. A haszn&aacute;lat&aacute;hoz el&#337;sz&ouml;r el kell k&eacute;sz&iacute;teni egy (vagy t&ouml;bb) profilt (fogasker&eacute;k ikon), ami a kapcsol&oacute;d&aacute;s adatait tartalmazza (hoszt, felhaszn&aacute;l&oacute;n&eacute;v, jelsz&oacute;, port stb&hellip;). Ha ez megvan, a k&eacute;k sz&iacute;n&#369; <strong>Kapcsol&oacute;d&aacute;s</strong> gombra kattintva, &eacute;s a megfelel&#337; profilt kiv&aacute;lasztva kapcsol&oacute;dhatunk a t&aacute;rhely&uuml;nkh&ouml;z. Ezut&aacute;n szabadon b&ouml;ng&eacute;szhet&uuml;nk a t&aacute;rhely &aacute;llom&aacute;nyai k&ouml;z&ouml;tt, &aacute;llom&aacute;nyokat t&ouml;lthet&uuml;nk fel, illetve le. K&eacute;nyelmes lehet az <strong>Explorer</strong> b&#337;v&iacute;tm&eacute;nnyel egy&uuml;tt haszn&aacute;lni.<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad10_ftp.png" alt="Notepad++ FTP" width="500" height="266" /><br /><br />A Notepad++ tov&aacute;bbi kellemes funkci&oacute;i k&ouml;z&eacute; tartozik a<strong>&nbsp;Futtat&aacute;s</strong>&nbsp;men&uuml;. Itt k&uuml;l&ouml;nb&ouml;z&#337; men&uuml;pontokhoz, illetve gyorsbillenty&#369;kh&ouml;z rendelhet&uuml;nk parancsokat, <em>k&uuml;ls&#337; programokat futtathatunk</em>. El&#337;fordulhat, hogy a telep&iacute;t&eacute;skor m&aacute;r elk&eacute;sz&iacute;tettek nek&uuml;nk n&eacute;h&aacute;ny futtat&oacute; parancsot. P&eacute;ld&aacute;ul (kliens oldali) webfejleszt&eacute;s sor&aacute;n hasznos lehet a <strong>Launch in Firefox/IE/Chrome/Safari</strong>&nbsp;el&#337;re hozz&aacute;adott men&uuml;, illetve gyorsbillenty&#369;.&nbsp;<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad11_run_firefox.png" alt="Notepad++ Run in Firefox" width="500" height="265" /><br />Lehet&#337;s&eacute;g van saj&aacute;t parancsokat is megadni: &iacute;gy be&aacute;ll&iacute;thatjuk p&eacute;ld&aacute;ul a Java vagy C ford&iacute;t&oacute;nkat gyorsbillenty&#369;k&eacute;nt. (A futtat&aacute;shoz haszn&aacute;hat&oacute; k&ouml;rnyezeti v&aacute;ltoz&oacute;kr&oacute;l a <a title="Notepad++ External Programs" href="http:&#47;&#47;docs.notepad-plus-plus.org/index.php/External_Programs" target="_blank">Notepad++ wikin</a> lehet olvasni.) &nbsp;P&eacute;ld&aacute;ul:</li>\r\n</ul>\r\n<pre><code> g++ "$(FULL_CURRENT_PATH)" -O3 -o "$(CURRENT_DIRECTORY)/$(NAME_PART).exe"</code></pre>\r\n<h3><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad12_compile.png" alt="Notepad++ C program ford&iacute;t&aacute;sa" width="500" height="266" /><br />Kit&eacute;r&#337;</h3>\r\n<p>A programok &uacute;tvonalait vagy <em>teljes el&eacute;r&eacute;si &uacute;ttal egy&uuml;tt</em> adjuk meg, vagy el&#337;tte <em>adjuk hozz&aacute;</em> az adott program<em> el&eacute;r&eacute;si &uacute;tj&aacute;t</em> a Windows <strong>PATH</strong> k&ouml;rnyezeti v&aacute;ltoz&oacute;j&aacute;hoz. A k&ouml;rnyezeti v&aacute;ltoz&oacute;kat Windows 7 alatt p&eacute;ld&aacute;ul a<strong> Sz&aacute;m&iacute;t&oacute;g&eacute;p (Saj&aacute;tg&eacute;p)</strong> gombra jobb kattint&aacute;s ut&aacute;n a <strong>Tulajdons&aacute;gok</strong> men&uuml;pontj&aacute;ban l&eacute;v&#337; ablak <strong>Speci&aacute;lis rendszerbe&aacute;ll&iacute;t&aacute;sok</strong>&nbsp;linkj&eacute;re kattintva &eacute;rhetj&uuml;k el. Ha mindent j&oacute;l csin&aacute;ltunk, felugrik egy ablak, aminek a <strong>Speci&aacute;lis</strong>&nbsp;f&uuml;l&ouml;n l&eacute;v&#337; <strong>K&ouml;rnyezeti v&aacute;ltoz&oacute;k</strong>&nbsp;gombj&aacute;n adjuk hozz&aacute; az el&eacute;r&eacute;si utat a <strong>PATH</strong> v&aacute;ltoz&oacute; v&eacute;g&eacute;re (; ut&aacute;n). <strong style="color: red;"><span style="text-decoration: underline;">FONTOS:</span> Ne t&ouml;r&ouml;lj&uuml;nk semmit a PATH v&aacute;ltoz&oacute;b&oacute;l, csak f&#369;zz&uuml;nk hozz&aacute;!<br /><br /></strong><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/path.png" alt="K&ouml;rnyezeti v&aacute;ltoz&oacute;k (PATH) el&eacute;r&eacute;se Windows 7-en" width="513" height="532" /><br /><br />A ford&iacute;t&aacute;s &eacute;s futtat&aacute;s k&eacute;nyelmesebb az <strong>NPPExec</strong> b&#337;v&iacute;tm&eacute;ny haszn&aacute;lata. A b&#337;v&iacute;tm&eacute;nyhez <em>saj&aacute;t dokkolhat&oacute; konzol</em> tartozik, &eacute;s a parancsszerkeszt&#337;je is k&eacute;nyelmesebb. A b&#337;v&iacute;tm&eacute;ny telep&iacute;t&eacute;se ut&aacute;n az <strong>F6</strong> gyorsbillenty&#369;vel el&#337;h&iacute;vhatjuk az ablakot, amiben megadhatjuk, illetve kiv&aacute;laszthatjuk a m&aacute;r elmentett parancsok k&ouml;z&uuml;l azt, amelyiket futtatni szeretn&eacute;nk.<br /><br /><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/notepad13_nppexec.png" alt="NppExec b&#337;v&iacute;tm&eacute;ny" width="500" height="266" /><br /><br />Az itt bemutatott dolgokn&aacute;l&nbsp;j&oacute;val t&ouml;bb is kihozhat&oacute; a j&oacute; &ouml;reg Notepad++-b&oacute;l, &eacute;n csak p&aacute;r apr&oacute; dolgot emeltem ki. Tov&aacute;bbi le&iacute;r&aacute;sok tal&aacute;lhat&oacute;k p&eacute;ld&aacute;ul a <a title="Notepad++ okos&iacute;t&oacute;" href="http:&#47;&#47;pcworld.hu/szoftver/notepad-okosito.html" target="_blank">PCWorld </a>oldal&aacute;n, a <a title="Notepad++ le&iacute;r&aacute;s" href="http:&#47;&#47;logout.hu/cikk/notepad/nyomtatobarat/teljes.html" target="_blank">logout.hu</a> egyik oldal&aacute;n, vagy a <a title="How to get more plus out of Notepad" href="http:&#47;&#47;lifehacker.com/5686272/how-to-get-more-plus-out-of-notepad%252B%252B" target="_blank">lifehacker.com</a>-on. Term&eacute;szetesen nem mondom, hogy ez a lehet&#337; legjobb eszk&ouml;z mindenre, ami kicsit is kapcsol&oacute;dik a programoz&aacute;shoz, illetve sz&ouml;vegek &iacute;r&aacute;s&aacute;hoz. Viszont egy j&oacute; seg&eacute;deszk&ouml;z lehet a kedvenc fejleszt&#337;i k&ouml;rnyezet&uuml;nk (Eclipse, NetBeans, CodeBlocks, vagy kinek mi) mell&eacute;.</p>', '2016-06-16 10:41:55', '2016-06-16 11:51:46'),
(69, 'comsciblog', 'Elemi adatszerkezetek 5. - A bináris kupac esete a rendezéssel', 'hu', '<p><strong>A mai bejegyz&eacute;sben a bin&aacute;ris kupac adatszerkezetr&#337;l fogok &iacute;rni. Bemutatom a bin&aacute;ris kupac &eacute;p&iacute;t&#337; algoritmust, valamint a besz&uacute;r&aacute;st &eacute;s a legnagyobb elem t&ouml;rl&eacute;s&eacute;t. Az adatszerkezet implement&aacute;l&aacute;s&aacute;hoz egy egyszer&#369; t&ouml;mb&ouml;t fogok haszn&aacute;lni. A megval&oacute;s&iacute;t&aacute;shoza C, illetve C++ programoz&aacute;si nyelveket haszn&aacute;lom.<br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/max_heap_example.jpg" alt="Bin&aacute;ris kupac (binary heap)" width="500" height="246" /><br /></strong></p>\r\n<h3>Mi is az a bin&aacute;ris kupac?</h3>\r\n<p>A bin&aacute;ris kupac egy majdnem teljes bin&aacute;ris fa, amire teljes&uuml;l az &uacute;gynevezett kupac tulajdons&aacute;g. Vagyis<strong> minden sz&uuml;l&#337; nagyobb vagy egyenl&#337; mindk&eacute;t gyerek&eacute;n&eacute;l</strong> (<em>maximum kupac</em> eset&eacute;n. Minimum kupac eset&eacute;n a sz&uuml;l&#337; &eacute;rt&eacute;ke kisebb egyenl&#337; a gyerekek &eacute;rt&eacute;k&eacute;n&eacute;l). <br />A kupac implement&aacute;lhat&oacute; ugyan <a title="Bin&aacute;ris keres&#337;fa vs l&aacute;ncolt lista" href="http:&#47;&#47;comsciblog.esy.es/article/67/Elemi+adatszerkezetek+4.+-+Bin%C3%A1ris+keres%C5%91fa+vs+l%C3%A1ncolt+lista" target="_blank">bin&aacute;ris fa</a> adatszerkezettel is (csom&oacute;pontok &eacute;s mutat&oacute;k seg&iacute;ts&eacute;g&eacute;vel), de k&ouml;nnyebb, ha egyszer&#369;en egy egyszer&#369; t&ouml;mbbel val&oacute;s&iacute;tjuk meg a kupac tulajdons&aacute;got. Vagyis adott $A[1,...,n]$ t&ouml;mbre teljes&uuml;l a kupac tulajdons&aacute;g, ha <br />\\[<br />A[i] \\geq A[2i] &nbsp;\\mbox{ &nbsp;&eacute;s &nbsp;} A[i] &gt;= A[2i +1]<br />\\]</p>\r\n<p>(Fontos, hogy a t&ouml;mb&uuml;nket ebben az esetben eggyel indexelj&uuml;k, ugyanis0 $0 = 2 \\cdot 0$)</p>\r\n<p>A kupac tulajdons&aacute;got egy &uacute;gynevezett "kupacol&oacute;" (<strong>heapify</strong>) elj&aacute;r&aacute;ssal &eacute;rhetj&uuml;k. Az elj&aacute;r&aacute;s bemenete a "kupacoland&oacute;" cs&uacute;cs mutat&oacute;ja, vagyis indexe a t&ouml;mbben. Legyen ez $i$-edik. Az elj&aacute;r&aacute;s sor&aacute;n megkeress&uuml;k i. &eacute;s a gyerekei ($2i$, $2i+1$) k&ouml;z&uuml;l a legnagyobb &eacute;rt&eacute;k&#369;t. Legyen a legnagyobb &eacute;rt&eacute;k&#369; cs&uacute;cs indexe $max$. Ha az egyik gyerek nagyobb a sz&uuml;l&#337;j&eacute;n&eacute;l, megcser&eacute;lj&uuml;k. Ekkor a megcser&eacute;lt cs&uacute;cs felveszi az eredeti sz&uuml;l&#337; &eacute;rt&eacute;k&eacute;t. Ez a cs&uacute;cs ($A[max]$) m&eacute;g s&eacute;rtheti a kupac tulajdons&aacute;got, ez&eacute;rt az elj&aacute;r&aacute;st rekurz&iacute;van megh&iacute;vhatjuk $A[max]$-ra is. Az elj&aacute;r&aacute;s fut&aacute;sideje $\\mathcal{O}(log\\, n)$, mivel egy $n$ cs&uacute;cs&uacute; kupac magass&aacute;ga legfeljebb $[log_2(n)]+1$, &eacute;s legfeljebb ennyiszer h&iacute;vjuk meg a kupacol&oacute; elj&aacute;r&aacute;st.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/heapify.gif" alt="Kupac &eacute;p&iacute;t&#337; elj&aacute;r&aacute;s (heapify)" width="500" height="353" /><br /><sub>Kupac &eacute;p&iacute;t&#337; elj&aacute;r&aacute;s. Az algoritmus a<strong> heapify(2)</strong>, vagyis a t&ouml;mb 2. elem&eacute;re h&iacute;vott kupacol&oacute; elj&aacute;r&aacute;st mutatja be.</sub></p>\r\n<p>Az elj&aacute;r&aacute;st megval&oacute;s&iacute;t&oacute; C nyelv&#369; k&oacute;dr&eacute;szlet:</p>\r\n<pre><code>int SIZE = 10;\r\nint heap[MAX_SIZE]={1, 3, 2, 1, 8, 5, 13, 21, 55, 34, 89}; &#47;&#47;the heap array\r\n\r\n/** Build heap to the element in the given place */\r\nvoid heapify(int place)\r\n{ \r\n	int tmp, max_index;\r\n &#47;&#47;if not leaf node\r\n	if (2*place&lt;=SIZE)\r\n	{\r\n &#47;&#47;if only have one child\r\n		if (2*place==SIZE) \r\n		{\r\n			if(heap[2*place] &gt; heap[place])\r\n			{\r\n				tmp = heap[place];\r\n				heap[place] = heap[2*place];\r\n				heap[2*place] = tmp;\r\n			}\r\n		}\r\n		else\r\n		{\r\n &#47;&#47;get the biggest index: parent node/left/right child\r\n			max_index=(heap[2*place+1] &gt; heap[2*place])? 2*place+1: 2*place;\r\n &#47;&#47;if not the parent is the biggest: swap+recursive call\r\n			if (heap[max_index] &gt; heap[place])\r\n			{\r\n				tmp = heap[place];\r\n				heap[place] = heap[max_index];\r\n				heap[max_index] = tmp;\r\n				heapify(max_index);\r\n			}\r\n		}\r\n	}\r\n}\r\n</code></pre>\r\n<p>Ahhoz, hogy a teljes bin&aacute;ris kupacot fel&eacute;p&iacute;ts&uuml;nk egy rendezetlen t&ouml;mbb&#337;l, nincs m&aacute;s dolgunk, mint minden elemre megh&iacute;vni az elj&aacute;r&aacute;st. $n$ elem eset&eacute;n ennek a fut&aacute;si ideje $\\mathcal{O}(n \\cdot log\\, n)$.</p>\r\n<pre><code>	for (i=SIZE; i&gt;=1; --i) \r\n		heapify(i);\r\n</code></pre>\r\n<p>A kupacot term&eacute;szetesen ki&iacute;rathatjuk egyszer&#369;en t&ouml;mbk&eacute;nt, vagy bin&aacute;ris fak&eacute;nt, rekurz&iacute;van, hogy jobban l&aacute;tsz&oacute;djon a szerkezete:</p>\r\n<pre><code>void print_rec(int place, int level)\r\n{\r\n	if (place &gt;= SIZE)\r\n		return;\r\n		\r\n	for (int i=0; i&lt;level; ++i)\r\n		printf("--");\r\n	printf("-&gt;%d\\n",heap[place]);\r\n		\r\n	print_rec(2*place, level+1);\r\n	print_rec(2*place+1, level+1);	\r\n}\r\n\r\n&#47;&#47;function to call it\r\nvoid print()\r\n{\r\n print_rec(1, 0);\r\n}\r\n</code></pre>\r\n<p><br /><strong>Kupacrendez&eacute;s</strong></p>\r\n<p>A bin&aacute;ris kupac adatszerkezet haszn&aacute;lhat&oacute; a t&ouml;mb rendez&eacute;s&eacute;re is. A rendez&eacute;s els&#337; l&eacute;p&eacute;sek&eacute;nt fel kell &eacute;p&iacute;ten&uuml;nk a kupacot. Ekkor biztos, hogy az els&#337; eleme, vagyis a gy&ouml;k&eacute;r a legnagyobb &eacute;rt&eacute;k&#369;. Vagyis a gy&ouml;keret kit&ouml;r&ouml;lve megkapjuk a t&ouml;mb legnagyobb elem&eacute;t. A t&ouml;rl&eacute;shez cser&eacute;lj&uuml;k fel a gy&ouml;keret a t&ouml;mb legkisebb elem&eacute;vel, majd cs&ouml;kkents&uuml;k a t&ouml;mb m&eacute;ret&eacute;t. &Iacute;rassuk ki/ments&uuml;k el/adjuk vissza a gy&ouml;k&eacute;r &eacute;rt&eacute;k&eacute;t, &eacute;s &aacute;ll&iacute;tsuk vissza a kupac tulajdons&aacute;got az &uacute;j gy&ouml;k&eacute;r "megkupacol&aacute;s&aacute;val" (<strong>heapify(1);</strong>). Egy ilyen m&#369;velettel megvan a legnagyobb elem. A marad&eacute;k kupacra ugyanezt megcsin&aacute;lva m&aacute;r megvan a k&eacute;t legnagyobb elem, cs&ouml;kken&#337; sorrendben... &eacute;s &iacute;gy tov&aacute;bb, am&iacute;g ki nem &uuml;r&uuml;l a kupac.</p>\r\n<pre><code>int max_del()\r\n{ \r\n	int max_value = heap[1];\r\n	heap[1]=heap[SIZE--];\r\n	heapify(1);\r\n	return max_value;\r\n}\r\n\r\nvoid print_sorted()\r\n{\r\n for (i=1; i&lt;=SIZE; ++i) \r\n	printf(" %d , ", max_del());\r\n}\r\n</code></pre>\r\n<p><br />Ez a rendez&eacute;s $\\mathcal{O}(n \\cdot log \\, n)$ fut&aacute;sidej&#369;: ugyanis kezdetben a build_heap elj&aacute;r&aacute;s $\\mathcal{O}(n \\cdot log \\, n)$ fut&aacute;sidej&#369;. Ezen k&iacute;v&uuml;l m&eacute;g ott van az $n$ darab maximum kiv&eacute;tel, ami egyenk&eacute;nt $\\mathcal{O}(log\\, n)$ l&eacute;p&eacute;st ig&eacute;nyel, mivel egy konstans idej&#369; cser&eacute;b&#337;l &eacute;s a <strong>heapify(1)</strong> elj&aacute;r&aacute;sb&oacute;l &aacute;ll.</p>\r\n<p><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/max_heap_delete.gif" alt="Gy&ouml;k&eacute;r t&ouml;rl&eacute;se a bin&aacute;ris kupacb&oacute;l" width="500" height="300" /><br /><sub>Gy&ouml;k&eacute;relem (legnagyobb) t&ouml;rl&eacute;se a bin&aacute;ris kupacb&oacute;l. Az anim&aacute;ci&oacute; forr&aacute;sa: <a title="Heap Data Structures" href="http:&#47;&#47;www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm" target="_blank">tutorialspoint.com</a>. Angol nyelv&#369;, de meg&eacute;ri elolvasni!</sub></p>\r\n<p>Amint l&aacute;that&oacute;, a kupac rendez&eacute;s maximum kupac eset&eacute;n cs&ouml;kken&#337; sorrendbe, a minimum kupac pedig n&ouml;vekv&#337; sorrendbe rendez. Viszont mindk&eacute;t esetben k&ouml;nnyen megoldhat&oacute; a ford&iacute;tottja: annyit kell tenni, hogy rendez&eacute;s ut&aacute;n meg kell cser&eacute;lni a rendezett t&ouml;mbben az els&#337; elemet az $n$-edik elemmel, a m&aacute;sodikat a $n-1$-edikkel, &eacute;s &iacute;gy tov&aacute;bb. Vagyis tov&aacute;bbi $[n/2]+1$ cser&eacute;vel cs&ouml;kken&#337; sorrendb&#337;l n&ouml;vekv&#337;t csin&aacute;lhatunk, vagy ford&iacute;tva.<br /><br />A<a title="Github binay_heap.c" href="https:&#47;&#47;github.com/strahlistvan/algorithms/blob/master/binary_heap.c" target="_blank"> teljes C program</a>, &eacute;s egy bin&aacute;ris kupac<a title="GitHub binary_heap.cpp" href="https:&#47;&#47;github.com/strahlistvan/algorithms/blob/master/binary_heap.cpp" target="_blank"> C++ oszt&aacute;ly</a> is megtal&aacute;lhat&oacute; a GitHubon. V&eacute;gezet&uuml;l pedig egy kis r&aacute;ad&aacute;s:<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/tree_heap_xkcd.png" alt="Binary tree with heap of presents" width="500" height="363" /><br />&nbsp; <a title="Bin&aacute;ris keres&#337;fa vs l&aacute;ncolt lista" href="http:&#47;&#47;comsciblog.esy.es/article/67/Elemi+adatszerkezetek+4.+-+Bin%C3%A1ris+keres%C5%91fa+vs+l%C3%A1ncolt+lista" target="_blank">(Bin&aacute;ris) kar&aacute;csonyfa</a>, alatta egy&nbsp;kupac aj&aacute;nd&eacute;kkal. &Oacute;vatosan az ilyen po&eacute;nokkal, k&uuml;l&ouml;nben nem h&iacute;vnak meg t&ouml;bbet kar&aacute;csonyra. Az eredeti k&eacute;p magyar&aacute;zattal egy&uuml;tt megtal&aacute;lhat&oacute; az <a title="Explain xkcd" href="http:&#47;&#47;www.explainxkcd.com/wiki/index.php/835:_Tree" target="_blank">xkcd.com</a> oldalon.</p>', '2016-06-30 03:02:34', '2016-06-30 04:03:47'),
(70, 'comsciblog', 'Infógrafika a programozás történetér&#337;l', 'hu', '<p><strong>Az <a title="Melyik programoz&aacute;si nyelvvel kezdjem? - inf&oacute;grafika" href="http:&#47;&#47;comsciblog.esy.es/article/38/Melyik+programoz%C3%A1si+nyelvvel+kezdjem%3F+-+inf%C3%B3grafika" target="_blank">el&#337;z&#337; inf&oacute;grafik&aacute;s bejegyz&eacute;shez</a> hasonl&oacute;an ma sem fogok t&uacute;l sokat &iacute;rni az oldalra. R&eacute;gebben tal&aacute;ltam egy &eacute;rdekes &eacute;s tetszet&#337;s &aacute;br&aacute;t a sz&aacute;m&iacute;t&aacute;stechnika t&ouml;rt&eacute;net&eacute;nek nagy alakjair&oacute;l, amit most leford&iacute;tottam magyarra. Az adatok a 2010-es &aacute;llapotot t&uuml;kr&ouml;zik (a legn&eacute;pszer&#369;bb programoz&aacute;si nyelvek r&eacute;szn&eacute;l), de a t&ouml;rt&eacute;nelmi t&eacute;nyek v&aacute;ltozatlanok.&nbsp;<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/aboutprogramming_hun.png" alt="&apos;A programoz&aacute;s vil&aacute;ga&apos; inf&oacute;grafika" width="500" height="1250" /><br /></strong><sub>A k&eacute;p teljes m&eacute;retben <a title="Teljes m&eacute;ret&#369; k&eacute;p" href="http:&#47;&#47;comsciblog.esy.es/img/aboutprogramming_hun.png" target="_blank">megtekinthet&#337; &eacute;s let&ouml;lthet&#337; ide kattintva</a></sub><strong><br /><br /></strong>A k&eacute;pet nem &eacute;n k&eacute;sz&iacute;tettem, csak magyarra ford&iacute;tottam. Az eredeti inf&oacute;grafika megtekinthet&#337; szerte az Interneten (p&eacute;ld&aacute;ul <a title="The World of Programming" href="http:&#47;&#47;visual.ly/the-world-of-programming" target="_blank">itt</a>). Aki pedig elolvasn&aacute; az eredeti inf&oacute;grafika k&eacute;sz&iacute;t&#337;j&eacute;nek a cikkj&eacute;t a tervez&eacute;s &eacute;s kivitelez&eacute;s menet&eacute;r&#337;l, az kattintson a <a title="Designing The &quot;World of Programming&quot; Infographic" href="https:&#47;&#47;www.smashingmagazine.com/2010/06/designing-the-world-of-programming-infographic/" target="_blank">smashmagazine.com megfelel&#337; cikkj&eacute;re</a>. &Eacute;n a ford&iacute;t&aacute;shoz a&nbsp;GIMP k&eacute;pszerkeszt&#337;t haszn&aacute;ltam. A seg&iacute;ts&eacute;g&eacute;vel az angol sz&ouml;vegeket kit&ouml;lt&ouml;ttem&nbsp;a h&aacute;tt&eacute;rsz&iacute;nnel (t&ouml;rl&eacute;s), majd a hely&eacute;re a megfelel&#337; magyar sz&ouml;veget g&eacute;peltem be, hasonl&oacute; bet&#369;sz&iacute;nnel &eacute;s st&iacute;lussal.</p>', '2016-07-12 11:04:02', '2016-07-12 11:08:09');
INSERT INTO `post` (`post_id`, `username`, `title`, `lang`, `text`, `created_at`, `updated_at`) VALUES
(71, 'comsciblog', 'Születésnap paradoxon - lesz olyan, aki osztozik a tortán?', 'hu', '<p><strong>A mai bejegyz&eacute;semben egy matematikai &eacute;rdekess&eacute;gr&#337;l fogok &iacute;rni, a sz&uuml;let&eacute;snap paradoxonr&oacute;l. A k&eacute;rd&eacute;s az, hogy h&aacute;ny embernek kell lennie egy szob&aacute;ban ahhoz, hogy nagyobb val&oacute;sz&iacute;n&#369;s&eacute;ge legyen annak, hogy valamely kett&#337;nek egy napon van sz&uuml;let&eacute;snapja, mint annak, hogy minden ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett. A feladatot nevezhetn&eacute;nk ink&aacute;bb "sz&uuml;let&eacute;snap probl&eacute;m&aacute;nak", mivel sz&oacute; szoros &eacute;rtelm&eacute;ben nem logikai paradoxon, csak sok ember sz&aacute;m&aacute;ra meglep&#337; lehet az eredm&eacute;ny. Nekem is az volt, amikor el&#337;sz&ouml;r tal&aacute;lkoztam vele.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/happy_birthday_paradox.png" alt="Sz&uuml;let&eacute;snap paradoxon illusztr&aacute;ci&oacute; - Scientific American" width="590" height="394" /></strong><br /><sub>Boldog sz&uuml;let&eacute;snapot neked, &eacute;s neked &eacute;s neked ... Az illusztr&aacute;ci&oacute; a <a title="Probability and the Birthday Paradox" href="http:&#47;&#47;www.scientificamerican.com/article/bring-science-home-probability-birthday-paradox/">Scientific American</a> honlapj&aacute;r&oacute;l sz&aacute;rmazik.</sub></p>\n<p>Miel&#337;tt megmondan&aacute;m az eredm&eacute;nyt, ismertetek&nbsp;egy egyszer&#369; levezet&eacute;st. Sz&uuml;ks&eacute;g lesz n&eacute;mi elemi val&oacute;sz&iacute;n&#369;s&eacute;gsz&aacute;m&iacute;t&aacute;sra, kombinatorik&aacute;ra, m&aacute;sodfok&uacute; egyenlet &eacute;s exponenci&aacute;lis egyenletek haszn&aacute;lat&aacute;ra. Vagyis el&#337;rel&aacute;that&oacute;lag egy &aacute;tlagos 10-11. oszt&aacute;lyos k&ouml;z&eacute;piskol&aacute;s m&aacute;r meg fogja &eacute;rteni.</p>\n<p>C&eacute;lszer&#369; annak a val&oacute;sz&iacute;n&#369;s&eacute;g&eacute;t kisz&aacute;molni, hogy $n$ ember k&ouml;z&uuml;l mindnek m&aacute;s napon van a sz&uuml;linapja.&nbsp;Ugyanis ennek pontosan komplementer esem&eacute;nye az, hogy valamely kett&#337;nek ugyanazon a napon van sz&uuml;linapja. Vagyis ha az egyik esem&eacute;ny val&oacute;sz&iacute;n&#369;s&eacute;ge $p$ &nbsp;$(0 \\leq p \\leq 1)$, akkor a m&aacute;sik esem&eacute;ny val&oacute;sz&iacute;n&#369;s&eacute;ge $1-p$.</p>\n<h2>Mi a val&oacute;sz&iacute;n&#369;s&eacute;ge annak, hogy 2 ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett?</h2>\n<p>Tegy&uuml;k fel, hogy ismerj&uuml;k az els&#337; (&Aacute;d&aacute;m) sz&uuml;let&eacute;si d&aacute;tum&aacute;t (pl: Jan 1., Aug 20., Dec 25., vagy b&aacute;rmi egy&eacute;b) Ekkor azt a val&oacute;sz&iacute;n&#369;s&eacute;get keress&uuml;k, hogy a m&aacute;sodik ember (B&eacute;la) nem ezen a napon sz&uuml;letett. Mivel a feladat sor&aacute;n azt felt&eacute;telezz&uuml;k, hogy minden ember egyenl&#337; es&eacute;llyel sz&uuml;lethetett b&aacute;rmelyik napon, &eacute;s a sz&ouml;k&#337;&eacute;vekt&#337;l is eltekint&uuml;nk, ez&eacute;rt a m&aacute;sodik ember (B&eacute;la) $\\frac{1}{365}$ val&oacute;sz&iacute;n&#369;s&eacute;ggel sz&uuml;letett ugyanazon a napon, mint az els&#337; (&Aacute;d&aacute;m). Vagyis $1 - \\frac{1}{365} = \\frac{364}{365}$ a val&oacute;sz&iacute;n&#369;s&eacute;ge, hogy a k&eacute;t ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett.</p>\n<h2>Mi a val&oacute;sz&iacute;n&#369;s&eacute;ge annak, hogy 3 ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett?</h2>\n<p>Ahhoz, hogy eld&ouml;nts&uuml;k, hogy 3 ember (<em>&Aacute;d&aacute;m, B&eacute;la, Csaba</em>) ugyanazon a napon sz&uuml;letett, felhaszn&aacute;lhatjuk az el&#337;z&#337; val&oacute;sz&iacute;n&#369;s&eacute;get. Ugyanis 3 ember pontosan 3 p&aacute;rt alkothat (3 db <strong>k&eacute;t elem&#369; r&eacute;szhalmazuk van</strong>): <em>{&Aacute;d&aacute;m,B&eacute;la}</em>, <em>{&Aacute;d&aacute;m,Csaba}</em> &eacute;s <em>{B&eacute;la,Csaba}</em>.<br />Mivel a sz&uuml;let&eacute;snapok egym&aacute;st&oacute;l f&uuml;ggetlenek, ez&eacute;rt p&eacute;ld&aacute;ul az, hogy &Aacute;d&aacute;m &eacute;s B&eacute;la egy napon sz&uuml;letett-e, nem befoly&aacute;solja annak a kimenetel&eacute;t, hogy &Aacute;d&aacute;m &eacute;s Csaba egy napon sz&uuml;letett-e. Teh&aacute;t a sz&uuml;let&eacute;snapok egyez&eacute;s&eacute;nek p&aacute;ronk&eacute;nti leellen&#337;rz&eacute;s&eacute;t tekinthetj&uuml;k 3 f&uuml;ggetlen k&iacute;s&eacute;rletnek. (Mintha h&aacute;romszor dobn&aacute;nk el egy <span style="text-decoration: underline;">szab&aacute;lyos 365 oldal&uacute; dob&oacute;kock&aacute;t</span> [val&oacute;sz&iacute;n&#369;leg geometriailag lehetetlen], amivel ha 1-est dobunk, vesz&iacute;t&uuml;nk, egy&eacute;bk&eacute;nt nyer&uuml;nk.) Mivel k&eacute;t ember k&ouml;z&uuml;l $ \\frac{364}{365}$ a val&oacute;sz&iacute;n&#369;s&eacute;ge, hogy egy napon sz&uuml;lettek, &eacute;s 3 emberb&#337;l 3 k&eacute;t f&#337;s p&aacute;rt alkothatunk, ez&eacute;rt a keresett val&oacute;sz&iacute;n&#369;s&eacute;g <br />\\[<br /> \\frac{364}{365}\\cdot\\frac{364}{365}\\cdot\\frac{364}{365} = \\left(\\frac{364}{365}\\right)^3<br />\\]</p>\n<h2>Mi a val&oacute;sz&iacute;n&#369;s&eacute;ge annak, hogy 4 ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett?</h2>\n<p>A megold&aacute;s menete ugyan&uacute;gy m&#369;k&ouml;dik, mint az el&#337;z&#337; esetben. Adott <em>&Aacute;d&aacute;m, B&eacute;la, Csaba</em> &eacute;s <em>D&eacute;nes</em>. &#336;k 6 p&aacute;rt (<strong>k&eacute;t elem&#369; r&eacute;szhalmazt</strong>) tudnak alkotni: <em>{&Aacute;d&aacute;m,B&eacute;la}</em>, <em>{&Aacute;d&aacute;m,Csaba}</em>, <em>{&Aacute;d&aacute;m,D&eacute;nes}</em>, <em>{B&eacute;la,Csaba}</em>, <em>{B&eacute;la,D&eacute;nes}</em>, <em>{Csaba,D&eacute;nes}</em>. Mivel a sz&uuml;let&eacute;snap-vizsg&aacute;latok p&aacute;ronk&eacute;nt f&uuml;ggetlenek, a keresett val&oacute;sz&iacute;n&#369;s&eacute;g:<br />\\[<br /> \\left(\\frac{364}{365}\\right)^6<br />\\]</p>\n<h2>Mi a helyzet $n$ emberrel?</h2>\n<p>&Aacute;ltal&aacute;nos esetben $n$ ember&uuml;nk van (&eacute;s nem ismerj&uuml;k $n$ &eacute;rt&eacute;k&eacute;t). $n$ elemnek $\\binom{n}{2} = \\frac{n(n-1)}{2}$ r&eacute;szhalmaza van (a <a title="Binomi&aacute;lis egy&uuml;tthat&oacute; - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Binomi%C3%A1lis_egy%C3%BCtthat%C3%B3" target="_blank">binomi&aacute;lis egy&uuml;tthat&oacute;r&oacute;l</a> &eacute;s a <a title="Kombin&aacute;ci&oacute; - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Kombin%C3%A1ci%C3%B3" target="_blank">kombin&aacute;ci&oacute;r&oacute;l </a>b&#337;vebben), teh&aacute;t ennyi p&aacute;rt k&eacute;pezhet&uuml;nk. Vagyis annak a val&oacute;sz&iacute;n&#369;s&eacute;ge, hogy $n$ emberb&#337;l egy sem ismeri egym&aacute;st:<br />\\[<br /> \\left(\\frac{364}{365}\\right)^{\\frac{n(n-1)}{2}}<br />\\]</p>\n<p>A k&eacute;rd&eacute;s &iacute;gy m&aacute;r &aacute;tfogalmazhat&oacute;: keress&uuml;k azt a legkisebb $n$ term&eacute;szetes sz&aacute;mot, amire ez a val&oacute;sz&iacute;n&#369;s&eacute;g kisebb, mint $\\frac{1}{2}$, vagyis az al&aacute;bbi <strong>egyenl&#337;tlens&eacute;get</strong> kell megoldani:<br />\\[<br /> \\left(\\frac{364}{365}\\right)^{\\frac{n(n-1)}{2}} &gt; \\frac{1}{2}<br />\\]</p>\n<p>Innent&#337;l m&aacute;r csak meg kell oldani $n$-re az egyenl&#337;tlens&eacute;get. Alak&iacute;tsuk &aacute;t egyenlett&eacute; ($&gt;$ helyett $=$), ugyanis a legkisebb olyan $n$-t keress&uuml;k, amelyre a bal oldal nagyobb, mint a jobb.</p>\n<p>Majd vegy&uuml;k mindk&eacute;t oldal $\\frac{364}{365}$-alap&uacute; logaritmus&aacute;t (<a title="&Aacute;tt&eacute;r&eacute;s m&aacute;s alap&uacute; logaritmusra" href="http:&#47;&#47;tudasbazis.sulinet.hu/hu/matematika/matematika/matematika-11-osztaly/a-logaritmus/atteres-mas-alapu-logaritmusra" target="_blank">Seg&iacute;ts&eacute;g a logaritmus alapj&aacute;nak &aacute;tv&aacute;lt&aacute;s&aacute;hoz</a>). <br />\\[<br /> \\frac{n(n-1)}{2} = log_{\\frac{364}{365}} \\frac{1}{2} \\approx 253<br />\\]<br />Innent&#337;l m&aacute;r csak egy m&aacute;sodfok&uacute; egyenletet kell megoldani (a <a href="http://tudasbazis.sulinet.hu/hu/matematika/matematika/matematika-10-osztaly/a-masodfoku-egyenlet-megoldokeplete/a-megoldokeplet-levezetese" target="_blank"> megold&oacute;k&eacute;plet </a> / <a href="https://en.wikipedia.org/wiki/Quadratic_formula"> kvadratikus formula </a> felhaszn&aacute;lat&aacute;val)<br />\\[<br /> \\frac{n(n-1)}{2} = 253 \\\\<br /> n(n-1) = 506 \\\\<br /> n^2 - n -506 = 0 \\\\<br /> n = \\frac{1+\\sqrt{1^2 + 4\\cdot506}}{2} \\approx 22,49<br />\\]</p>\n<p>Vagyis <span style="text-decoration: underline; color: red;"><strong>mind&ouml;ssze 23 ember</strong></span> eset&eacute;n m&aacute;r nagyobb a val&oacute;sz&iacute;n&#369;s&eacute;ge annak, hogy valamely kett&#337;nek egy napra esik a sz&uuml;let&eacute;snapja, mint hogy mindegyik k&uuml;l&ouml;n napon sz&uuml;letett.</p>\n<h3>Megjegyz&eacute;s</h3>\n<p>A fenti m&aacute;sodfok&uacute; egyenletnek van m&eacute;g egy megold&aacute;sa, viszont az negat&iacute;v, &iacute;gy nincs &eacute;rtelme enn&eacute;l a feladatn&aacute;l.</p>\n<p><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/birthday_paradox_chart.png" alt="Birthday paradox chart" width="1000" height="640" /><sub>A sz&uuml;let&eacute;snap "paradoxon" &aacute;br&aacute;zol&aacute;sa. V&iacute;zszintes tengelyen a csoport (emberek) l&eacute;tsz&aacute;ma, a f&uuml;gg&#337;legesen pedig a p&aacute;r val&oacute;sz&iacute;n&#369;s&eacute;ge (vagyis hogy van-e k&eacute;t ember, akinek egyszerre van sz&uuml;linapja.) A k&eacute;p forr&aacute;sa: <a title="Birthday Problem - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Birthday_problem" target="_blank">Wikipedia</a></sub></p>\n<h2>Ellen&#337;rz&eacute;s</h2>\n<p>Az eredm&eacute;ny leellen&#337;rizhet&#337;: ugyanis annak a val&oacute;sz&iacute;n&#369;s&eacute;ge, hogy<strong> k&eacute;t ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett</strong>, $\\frac{364}{365}$.<br />Ha h&aacute;rom ember&uuml;nk van, akkor annak az es&eacute;lye, hogy<strong> mindh&aacute;rom m&aacute;s napon</strong> sz&uuml;letett: $\\frac{364}{365} \\cdot \\frac{363}{365}$. Ugyanis mivel az els&#337; k&eacute;t ember k&uuml;l&ouml;nb&ouml;z&#337; napon sz&uuml;letett, &iacute;gy a harmadik csak ezen a k&eacute;t napon k&iacute;v&uuml;l sz&uuml;lethetett, aminek $\\frac{363}{365}$ az es&eacute;lye. <br />$n$ ember eset&eacute;n pedig ez a val&oacute;sz&iacute;n&#369;s&eacute;g (hasonl&oacute; elv alapj&aacute;n)<br />\\[<br />p = \\frac{364}{365} \\cdot \\frac{363}{365} \\cdots \\frac{365-n+1}{365}<br />\\]<br />Ezt a val&oacute;sz&iacute;n&#369;s&eacute;g egyre cs&ouml;kken, ahogy $n$ n&#337;. Kisz&aacute;molhatjuk az &eacute;rt&eacute;k&eacute;t k&uuml;l&ouml;nb&ouml;z&#337; $n$-ekre (a <strong>LIMIT</strong> makr&oacute; &eacute;rt&eacute;ke szabadon v&aacute;ltoztathat&oacute;):</p>\n<pre><code>#include &lt;stdio.h&gt;\n#define LIMIT 0.5\n\nint main(int argc, char ** argv)\n{\n	double prod = 1.0;\n	int n = 2;\n	while (prod &gt; LIMIT)\n	{\n		prod *= (double)(365.0 - n +1.0)/365.0;\n		printf("Annak a valoszinusege, hogy %d emberbol mind mas napon szuletett: %1.4f\\n", n, prod);\n		++n;\n	}\n	return 0;\n}\n</code></pre>\n<p>A program kimenete is igazolja, hogy $n = 23$ eset&eacute;n m&aacute;r annak a val&oacute;sz&iacute;n&#369;s&eacute;ge, hogy mindenki m&aacute;s napon sz&uuml;letett, kisebb, mint $50%$, m&iacute;g $n=40$ ember eset&eacute;n m&aacute;r csak alig $10%$. Teh&aacute;t egy 40-50 f&#337;s t&aacute;rsas&aacute;gban (iskolai &eacute;vfolyam, munkahely, <a title="Az blog Facebook oldala" href="https:&#47;&#47;www.facebook.com/comsciblog" target="_blank">Facebook</a>&nbsp;ismer&#337;s&ouml;k) m&aacute;r nagyon val&oacute;sz&iacute;n&#369;, hogy lesz olyan nap, amikor legal&aacute;bb 2 embernek kell boldog sz&uuml;let&eacute;snapot k&iacute;v&aacute;nni.</p>\n<h3>Megjegyz&eacute;s</h3>\n<p>A feladat nem &ouml;sszekeverend&#337; azzal, amikor azt k&eacute;rdezz&uuml;k, hogy mikor val&oacute;sz&iacute;n&#369;bb az, hogy egy adott embernek (Istv&aacute;n) van-e egy tetsz&#337;leges m&aacute;sik emberrel egy napon a sz&uuml;let&eacute;snapja $n$ ember eset&eacute;n! [Vagyis mekkora val&oacute;sz&iacute;n&#369;s&eacute;ggel kell majd osztoznom a tort&aacute;n?]. Erre a v&aacute;lasz $n$ ember eset&eacute;n a <br />\\[<br />\\left( \\frac{364}{365} \\right) ^n &gt; \\frac{1}{2}<br />\\]<br />egyenlet megold&aacute;sa, ami $n = 253$. Vagyis 253 ember eset&eacute;n m&aacute;r val&oacute;sz&iacute;n&#369;bb, hogy osztoznom kell a sz&uuml;let&eacute;snapon. Ahhoz pedig, hogy 90%-ig biztos legyek, hogy egy&uuml;tt kell valakivel tartanom a sz&uuml;let&eacute;snapom, m&aacute;r $n=840$ ismer&#337;sre van sz&uuml;ks&eacute;gem.<br />A m&aacute;sik eredm&eacute;ny csak azt mondta meg, hogy $23$ ember eset&eacute;n m&aacute;r val&oacute;sz&iacute;n&#369;bb ($40$ eset&eacute;n pedig majdnem biztos), hogy valaki valamikor osztozni fog a sz&uuml;linapon a t&aacute;rsas&aacute;gb&oacute;l, de kor&aacute;ntsem mondta, hogy &eacute;n leszek az.</p>\n<h3>&nbsp;Tov&aacute;bbi inform&aacute;c&oacute;k</h3>\n<ul>\n<li><a title="Sz&uuml;let&eacute;snap-paradoxon - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Sz%C3%BClet%C3%A9snap-paradoxon" target="_blank">Sz&uuml;let&eacute;snap-paradoxon</a> - Wikip&eacute;dia</li>\n<li><a title="Birthday problem - Wikipedia" href="https:&#47;&#47;en.wikipedia.org/wiki/Birthday_problem" target="_blank">Birthday problem</a> - Wikipedia</li>\n<li><a title="Better explained" href="https:&#47;&#47;betterexplained.com/articles/understanding-the-birthday-paradox/" target="_blank">Understanding the Birthday paradox</a> - szimul&aacute;ci&oacute;val<br /><a title="Scientific American" href="http:&#47;&#47;www.scientificamerican.com/article/bring-science-home-probability-birthday-paradox/" target="_blank">Scientific American</a> - a bor&iacute;t&oacute;k&eacute;p is t&#337;l&uuml;k sz&aacute;rmazik</li>\n<li><a title="Bill Nye the Science Guy demonstration" href="https:&#47;&#47;www.youtube.com/watch?v=RhPdzXc0QPA" target="_blank">Bill Nye</a>&nbsp;az utca ember&eacute;n tesztelte a sz&uuml;let&eacute;snap probl&eacute;m&aacute;t</li>\n<li> <a href="https://moly.hu/konyvek/tony-crilly-matematika" target="_blank"> Tony Crilly: Matematika - 50 fogalom, amit ismerni kell </a> </li>\n</ul>', '2016-08-26 08:54:46', '2016-08-26 09:55:07'),
(72, 'comsciblog', 'Gráfok, gráf algoritmusok 1. - Számítógépes ábrázolás', 'hu', '<p><strong>A mai bejegyz&eacute;semben a gr&aacute;fokr&oacute;l, illetve azok sz&aacute;m&iacute;t&oacute;g&eacute;pes reprezent&aacute;ci&oacute;r&oacute;l fogok &iacute;rni. Rem&eacute;lhet&#337;leg lesz folytat&aacute;sa is, amiben n&eacute;h&aacute;ny alapvet&#337; gr&aacute;falgoritmust fogok ismertetni. Ehhez most n&eacute;h&aacute;ny p&eacute;ld&aacute;n kereszt&uuml;l bemutatom, hogy mi is a gr&aacute;f. Ezen k&iacute;v&uuml;l &iacute;rok n&eacute;h&aacute;ny sort arr&oacute;l, hogy hogyan lehet a sz&aacute;m&iacute;t&oacute;g&eacute;pes feldolgoz&aacute;sra alkalmas alakra hozni egy tetsz&#337;leges h&aacute;l&oacute;zatot, vagyis gr&aacute;fot.<br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/facebook_graph.png" alt="Facebook social network graph visualization" width="600" height="299" /><br /></strong><sub>A j&oacute;l ismert Facebook k&ouml;z&ouml;ss&eacute;gi odal kapcsolati h&aacute;l&oacute;zat&aacute;t &aacute;br&aacute;zol&oacute; gr&aacute;f. A gr&aacute;f cs&uacute;csai a Facebook felhaszn&aacute;l&oacute;i, az &eacute;lek pedig a k&ouml;zt&uuml;k l&eacute;v&#337; kapcsolat. B&aacute;r a k&eacute;p gy&ouml;ny&ouml;r&#369;, a p&eacute;ld&aacute;im sor&aacute;n enn&eacute;l az&eacute;rt kisebb gr&aacute;fokat haszn&aacute;lok. [A k&eacute;p forr&aacute;sa: <a title="Facebook&apos;s Social Network Graph" href="https:&#47;&#47;www.r-bloggers.com/facebooks-social-network-graph/" target="_blank">r-bloggers.com</a>. &Eacute;rdemes elolvasni a cikket is.]</sub></p>\n<h3>Mi is az a gr&aacute;f?</h3>\n<p>A <a title="Gr&aacute;f - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Gr%C3%A1f" target="_blank">gr&aacute;f</a> tulajdonk&eacute;ppen tetsz&#337;leges adatok &eacute;s a k&ouml;z&ouml;tt&uuml;k l&eacute;v&#337; kapcsolataik matematikai modellez&eacute;s&eacute;hez ad eszk&ouml;zt.&nbsp;P&eacute;ld&aacute;ul ha egy &uacute;th&aacute;l&oacute;zatot szeretn&eacute;nk modellezni, a gr&aacute;f cs&uacute;csainak megfeleltethetj&uuml;k a v&aacute;rosokat. Ekkor a gr&aacute;f&nbsp;egy &eacute;le lehet az &uacute;t a k&eacute;t v&aacute;ros k&ouml;z&ouml;tt. Egy hasonl&oacute; probl&eacute;ma megold&aacute;sa vez&eacute;relte a XVIII. sz&aacute;zad egyik legismertebb matematikus&aacute;t,&nbsp;Leonhard Euler sv&aacute;jci sz&aacute;rmaz&aacute;s&uacute; matematikust. A t&ouml;rt&eacute;net szerint egy poroszorsz&aacute;gi v&aacute;ros, <a title="K&ouml;nigsbergi hidak probl&eacute;m&aacute;ja - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/K%C3%B6nigsbergi_hidak_probl%C3%A9m%C3%A1ja" target="_blank">K&ouml;nigsberg</a> lakosai felk&eacute;rt&eacute;k Eulert, hogy seg&iacute;tsenek nekik megtervezni egy k&ouml;rmenetet, amelyben v&eacute;gigmennek a v&aacute;roson, bele&eacute;rtve a v&aacute;rost &aacute;tszel&#337; Pr&eacute;gel foly&oacute;n l&eacute;v&#337; szigetet is.&nbsp;A kik&ouml;t&eacute;s az volt, hogy a v&aacute;ros mind a h&eacute;t h&iacute;dj&aacute;n pontosan egyszer menjenek v&eacute;gig.</p>\n<p><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/konigsberg_bridges_graph.gif" alt="K&ouml;nigsbergi hidak modellez&eacute;se gr&aacute;fokkal" width="400" height="320" /><br /><sub>K&ouml;nigsberg h&iacute;djainak modellez&eacute;se gr&aacute;fokkal. A n&eacute;gy f&ouml;ldter&uuml;let (2 part + 2 sziget) mindegyik&eacute;t egy-egy cs&uacute;csk&eacute;nt &aacute;br&aacute;zoljuk, az &#337;ket &ouml;sszek&ouml;t&#337; h&eacute;t h&iacute;d pedig a gr&aacute;f &eacute;lei.<br />(Az mozg&oacute;k&eacute;p alapj&aacute;ul szolg&aacute;l&oacute; k&eacute;pek forr&aacute;sa a&nbsp;<a title="K&ouml;nigsbergi hidak probl&eacute;m&aacute;ja" href="https:&#47;&#47;hu.wikipedia.org/wiki/K%C3%B6nigsbergi_hidak_probl%C3%A9m%C3%A1ja" target="_blank">Wikip&eacute;dia</a>. Term&eacute;szetesen a mozg&oacute;k&eacute;p is teljesen szabadon felhaszn&aacute;lhat&oacute;, mindenf&eacute;le korl&aacute;toz&aacute;s n&eacute;lk&uuml;l. $\\rightarrow$<a title="Creative Commons Licence" href="https:&#47;&#47;creativecommons.org/licenses/by-sa/3.0/deed.hu" target="_blank"> CC-BY-SA 3.0</a>, csak hogy "jog&aacute;szkodjunk" egy kicsit :)&nbsp;</sub></p>\n<p><br />Euler a bizony&iacute;t&aacute;s&aacute;ban a v&iacute;z &aacute;ltal elv&aacute;lasztott ter&uuml;leteket vette a gr&aacute;f cs&uacute;csainak, az &#337;ket &ouml;sszek&ouml;t&#337; hidakat pedig a gr&aacute;f &eacute;leinek. &nbsp;&Iacute;gy m&aacute;r csak egy olyan utat kellett tal&aacute;lnia, ami minden &eacute;len pontosan egyszer megy &aacute;t. Euler pedig bebizony&iacute;totta, hogy pontosan akkor&nbsp;van ilyen &uacute;t, ha minden cs&uacute;cs foka (vagyis a bemen&#337; &eacute;leinek sz&aacute;ma) p&aacute;ros.&nbsp;De a gr&aacute;fokkal a t&eacute;rk&eacute;peken k&iacute;v&uuml;l haszn&aacute;lhat&oacute; sz&aacute;mos egy&eacute;b val&oacute;s feladat modellez&eacute;s&eacute;re. P&eacute;ld&aacute;ul ha egy nagyobb rendezv&eacute;nyen l&eacute;trej&ouml;v&#337; &nbsp;t&aacute;rsadalmi kapcsolatokat szeretn&eacute;nk modellezni, akkor cs&uacute;csok lehetnek a r&eacute;sztvev&#337; emberek, az &eacute;lek pedig az emberek k&ouml;z&ouml;tti ismerets&eacute;gek/bar&aacute;ts&aacute;gok.&nbsp;Ekkor k&uuml;l&ouml;nb&ouml;z&#337; k&eacute;rd&eacute;seket tehet&uuml;nk fel: p&eacute;ld&aacute;ul megkereshetj&uuml;k a legkevesebb "k&eacute;zfog&aacute;st" k&eacute;t adott ember k&ouml;z&ouml;tt, vagyis hogy h&aacute;ny embernek kell bemutatkoznia $A$ embernek, hogy megismerkedjen $B$ emberrel. Vagy megk&eacute;rdezhet&#337;, hogy keress&uuml;k meg az olyan t&aacute;rsas&aacute;gokat (klikkeket), ahol mindenki ismer mindenkit.</p>\n<p>A gr&aacute;fokkal val&oacute; modellez&eacute;s el&#337;nye, hogy sz&aacute;m&iacute;t&oacute;g&eacute;ppel k&ouml;nnyen feldolgozhat&oacute;. Sz&aacute;mos algoritmus l&eacute;tezik a gr&aacute;felm&eacute;let k&uuml;l&ouml;nb&ouml;z&#337; probl&eacute;m&aacute;ira. &nbsp;A k&ouml;vetkez&#337; r&eacute;szben bemutatok n&eacute;h&aacute;ny &aacute;br&aacute;zol&aacute;si m&oacute;dot, aminek seg&iacute;ts&eacute;g&eacute;vel modellezhet&#337;, feldolgozhat&oacute; &eacute;s t&aacute;rolhat&oacute; egy gr&aacute;f a sz&aacute;m&iacute;t&oacute;g&eacute;pen.</p>\n<h3>Gr&aacute;fok &aacute;br&aacute;zol&aacute;si m&oacute;djai</h3>\n<p>A gr&aacute;fok egyik legismertebb &aacute;br&aacute;zol&aacute;si m&oacute;dja, hogy az egyes cs&uacute;csokat apr&oacute; (sz&aacute;mozott/c&iacute;mk&eacute;zett) k&ouml;r&ouml;kkel, m&iacute;g az &eacute;leket, vagyis az egyes cs&uacute;csok k&ouml;z&ouml;tti kapcsolatot a cs&uacute;csok k&ouml;z&ouml;tti szakaszokkal jel&ouml;lj&uuml;k. Ez az emberi l&eacute;nyek sz&aacute;m&aacute;ra egyszer&#369;en &eacute;rtelmezhet&#337;, &eacute;s meglehet&#337;sen l&aacute;tv&aacute;nyos, &aacute;m a sz&aacute;m&iacute;t&oacute;g&eacute;pes feldolgoz&aacute;sra kev&eacute;ss&eacute; alkalmas megjelen&iacute;t&eacute;si forma.</p>\n<p><em><span style="text-decoration: underline;">P&eacute;lda:</span> Azt a feladatot kapjuk, hogy keress&uuml;k meg a legr&ouml;videbb utat a Magrathea &eacute;s Mordor k&ouml;z&ouml;tt. Magrathea &eacute;s Mordor k&ouml;z&ouml;tt vezet k&ouml;zvetlen gyorsforgalmi &uacute;t, ami azonban 15000 bakugr&aacute;s hossz&uacute;. A Magrathe&aacute;r&oacute;l azonban eljuthatunk a Roxfortba is, egy mind&ouml;ssze 2420 bakugr&aacute;s hossz&uacute; &uacute;ton, valamint a Tatuinra is, 12500 bakugr&aacute;s hossz&uacute; &uacute;ton. Roxfortb&oacute;l a Tatuinra 10010 bakugr&aacute;s hossz&uacute; &uacute;ton juthatunk el. Van azonban egy ker&uuml;l&#337; &uacute;t is Roxfort &eacute;s Tatuin k&ouml;z&ouml;tt, ami csak 42 bakugr&aacute;s hossz&uacute;. Mordor &eacute;s a Tatuin k&ouml;z&ouml;tt szint&eacute;n k&eacute;t &uacute;t vezet: az egyik 9900, a m&aacute;sik 6000 bakugr&aacute;s hossz&uacute;. Minden &uacute;t k&eacute;tir&aacute;ny&uacute;.</em></p>\n<p><em><span style="text-decoration: underline;">Megold&aacute;s:</span> C&eacute;lszer&#369; el&#337;sz&ouml;r a feladatb&oacute;l egy gr&aacute;fot alkotni. Els&#337; l&eacute;p&eacute;sk&eacute;nt felvessz&uuml;k a n&eacute;gy helyis&eacute;get a gr&aacute;f n&eacute;gy cs&uacute;csak&eacute;nt. A gr&aacute;f &eacute;lei pedig az egyes helyis&eacute;gek k&ouml;z&ouml;tt vezet&#337; utak.&nbsp; Ahhoz azonban, hogy a t&aacute;vols&aacute;gokat is tudjuk kezelni, s&uacute;lyozott gr&aacute;fot kell szerkeszteni, vagyis minden &eacute;lhez hozz&aacute; kell rendelni egy sz&aacute;mot, ami jelen esetben az adott &uacute;tvonal t&aacute;vols&aacute;ga (bakugr&aacute;sban, term&eacute;szetesen). Az elk&eacute;sz&uuml;lt gr&aacute;fok &aacute;br&aacute;zol&aacute;s&aacute;ban k&ouml;nnyen leolvashat&oacute;, hogy b&aacute;r hi&aacute;ba van k&ouml;zvetlen &uacute;t Magrathea &eacute;s Mordor k&ouml;z&ouml;tt, sokkal r&ouml;videbb, ha el&#337;sz&ouml;r a r&ouml;videbb &uacute;ton ($6000$ bakugr&aacute;s) megy&uuml;nk Mordob&oacute;l a Tatuinra, majd onnan tov&aacute;bb a r&ouml;videbb &uacute;ton a Roxfortba (mind&ouml;ssze $42$ bakugr&aacute;s,<span style="text-decoration: line-through;"> tal&aacute;n hopp-porral utaztunk?</span>). Onnan pedig m&eacute;g $2420$ bakugr&aacute;s a Magrathea, vagyis &ouml;sszesen $6000+42+2420 = 8462$ bakugr&aacute;s megt&eacute;tel&eacute;vel m&aacute;r Mordorban is vagyunk.</em> <br /><br /><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/site_graph_uw_w.png" alt="S&uacute;lyozatlan &eacute;s s&uacute;lyozott gr&aacute;f" width="414" height="162" />\n<sub>A feladathoz tartoz&oacute; s&uacute;lyozatlan (bal oldali), illetve s&uacute;lyozott gr&aacute;f. A K&ouml;nigsbergi hidak gr&aacute;fj&aacute;val val&oacute; hasonl&oacute;s&aacute;g esetleges hasonl&oacute;s&aacute;g&nbsp;a v&eacute;letlen m&#369;ve, (<span style="text-decoration: line-through;">&eacute;s semmik&eacute;pp nem a szerz&#337; lustas&aacute;g&aacute;nak tudhat&oacute; be</span>).</sub></p>\n<p>A h&aacute;rom legelterjedtebb sz&aacute;m&iacute;t&oacute;g&eacute;pes gr&aacute;f-reprezent&aacute;ci&oacute; a <strong>szomsz&eacute;ds&aacute;gi m&aacute;trix</strong>, a <strong>illeszked&eacute;si m&aacute;trix</strong>, illetve az <strong>&eacute;llista</strong>.&nbsp;</p>\n<p>A<strong> <a title="Szomsz&eacute;ds&aacute;gi m&aacute;trix - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Szomsz%C3%A9ds%C3%A1gi_m%C3%A1trix" target="_blank">szomsz&eacute;ds&aacute;gi m&aacute;trix</a></strong>&nbsp;tulajdonk&eacute;ppen egy $n \\times&nbsp;n$ -es t&aacute;bl&aacute;zat, ahol $n$ jelenti a gr&aacute;f cs&uacute;csainak sz&aacute;m&aacute;t. Minden sorba &eacute;s minden oszlopba felvesz&uuml;nk egyszer minden cs&uacute;csot. A t&aacute;bl&aacute;zat $i$-edik sor&aacute;ban l&eacute;v&#337; $j$-edik cella &eacute;rt&eacute;ke $1$, ha az $i$-edik &eacute;s a $j$-edik cs&uacute;cs k&ouml;z&ouml;tt van &eacute;l a gr&aacute;fban, egy&eacute;bk&eacute;nt $0$. T&ouml;bbsz&ouml;r&ouml;s &eacute;lek eset&eacute;n pedig $1$ helyett haszn&aacute;lhatjuk a cs&uacute;csok k&ouml;zt fut&oacute; &eacute;lek sz&aacute;m&aacute;t. Ha a gr&aacute;funk <em>s&uacute;lyozott</em>, akkor ahelyett, hogy az &eacute;l hely&eacute;re egyest &iacute;rn&aacute;nk, &iacute;rhatjuk az &eacute;l s&uacute;ly&aacute;t. Vagyis a gr&aacute;f tulajdonk&eacute;ppen egy <em>k&eacute;t dimenzi&oacute;s t&ouml;mb</em>, &eacute;s ha vagyunk k&iacute;v&aacute;ncsiak, hogy van-e (illetve ha van, milyen s&uacute;ly&uacute;) &eacute;l $i$ &eacute;s $j$ cs&uacute;cs k&ouml;z&ouml;tt, csak kiolvassuk a m&aacute;trix/t&aacute;bl&aacute;zat/t&ouml;mb megfelel&#337; elem&eacute;t.</p>\n<p><em><span style="text-decoration: underline;">P&eacute;lda:</span> A fenti s&uacute;lyozatlan gr&aacute;fhoz tartoz&oacute; szomsz&eacute;ds&aacute;gi m&aacute;trix:</em></p>\n<p><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/site_adj_matrix_uw02.png" alt="S&uacute;lyozatlan szomsz&eacute;ds&aacute;gi m&aacute;trix" width="500" height="121" /></p>\n<p><em>S&uacute;lyozott gr&aacute;f t&ouml;bbsz&ouml;r&ouml;s &eacute;leit &aacute;br&aacute;zolni azonban nem felt&eacute;tlen&uuml;l egy&eacute;rtelm&#369; k&eacute;t dimenzi&oacute;s t&ouml;mbben. Mivel a feladatunk a legr&ouml;videbb &uacute;t megkeres&eacute;se volt, ez&eacute;rt c&eacute;lszer a t&ouml;bbsz&ouml;r&ouml;s &eacute;lek eset&eacute;n a legkisebbet be&iacute;rni a t&ouml;mbbe, hiszen azt kell v&aacute;lasztanunk.</em></p>\n<p><img class="img-responsive" class="img-responsive" src="http:&#47;&#47;comsciblog.esy.es/img/site_adj_matrix_w02.png" alt="S&uacute;lyozott szomsz&eacute;ds&aacute;gi m&aacute;trix" width="600" height="145" /></p>\n<p>Az <a title="Illeszked&eacute;si m&aacute;trix - Wikip&eacute;dia" href="https:&#47;&#47;hu.wikipedia.org/wiki/Illeszked%C3%A9si_m%C3%A1trix" target="_blank">illeszked&eacute;si m&aacute;trix</a>&nbsp;szint&eacute;n egy t&aacute;bl&aacute;zatos megjelen&iacute;t&eacute;si forma, ami azonban <em>nem felt&eacute;tlen&uuml;l</em> eredm&eacute;nyez <em>n&eacute;gyzetes</em> m&aacute;trixot. A t&aacute;bl&aacute;zat sorai megfeleltethet&#337;k &nbsp;a gr&aacute;f cs&uacute;csainak, az oszlopai pedig az &eacute;leinek. Vagyis ez egy $n \\times m$-es m&aacute;trix, ahol $n$ a gr&aacute;f cs&uacute;csainak sz&aacute;ma, m pedig az &eacute;lek sz&aacute;ma. (De lehet ford&iacute;tva is, implement&aacute;ci&oacute; k&eacute;rd&eacute;se...). A t&aacute;bl&aacute;zat $i$-edik sor&aacute;ban l&eacute;v&#337; $j$-edik cella &eacute;rt&eacute;ke pedig akkor 1 (vagyis nem nulla, ha s&uacute;lyozott gr&aacute;fr&oacute;l besz&eacute;l&uuml;nk), ha az $i$-edik cs&uacute;cs&nbsp;illeszkedik a $j$-edik &eacute;lre, vagyis az $i$-edik cs&uacute;cs a $j$-edik &eacute;l valamelyik v&eacute;gpontja. Teh&aacute;t&nbsp;a t&aacute;bl&aacute;zat minden sor&aacute;ban<em> pontosan kett&#337; darab nem nulla</em>&nbsp; &eacute;rt&eacute;k van, hiszen egy &eacute;lnek k&eacute;t v&eacute;gpontja van.</p>\n<p><em><span style="text-decoration: underline;">P&eacute;lda:</span>&nbsp;A fenti feladat gr&aacute;fj&aacute;nak s&uacute;lyozott illeszked&eacute;si m&aacute;trixa. S&uacute;lyozatlan eset ugyanez, mind&ouml;ssze a nem nulla sz&aacute;mok&nbsp;helyett egyesek szerepelnek.</em></p>\n<p><em><img class="img-responsive" class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;" src="http:&#47;&#47;comsciblog.esy.es/img/site_inc_matrix.png" alt="S&uacute;lyozott illeszked&eacute;si m&aacute;trix" width="600" height="160" /></em></p>\n<p>Ez a t&aacute;rol&aacute;si forma &aacute;ltal&aacute;ban t&ouml;bb helyet ig&eacute;nyel, mint a szomsz&eacute;ds&aacute;gi m&aacute;trix, kiv&eacute;ve az olyan ritka eseteket, ha kevesebb &eacute;l van, mint cs&uacute;cs. Viszont <em>t&ouml;bbsz&ouml;r&ouml;s &eacute;lek eset&eacute;n az illeszked&eacute;si m&aacute;trix jobban haszn&aacute;lhat&oacute;</em>, mint a szomsz&eacute;ds&aacute;gi m&aacute;trix. Ezen k&iacute;v&uuml;l m&eacute;g akkor lehet&nbsp;el&#337;nye lehet az illeszked&eacute;si m&aacute;trixnak , amikor p&eacute;ld&aacute;ul egy adott &eacute;lre illeszked&#337; &eacute;lt szeretn&eacute;nk megkeresni (p&eacute;ld&aacute;ul a legnagyobb s&uacute;ly&uacute;t): ilyenkor elegend&#337; kiolvasnunk a megadott sorb&oacute;l azt a k&eacute;t nem nulla elemet, ami legfeljebb $n$ l&eacute;p&eacute;s alatt siker&uuml;l. Ezzel szemben a szomsz&eacute;ds&aacute;gi m&aacute;trix eset&eacute;ben (legrosszabb esetben) v&eacute;gig kell olvasnunk a teljes m&aacute;trixot, ami $n \\cdot n = n^2$ l&eacute;p&eacute;st ig&eacute;nyel.</p>\n<p>Az &eacute;llist&aacute;s megad&aacute;si m&oacute;d pedig az, amikor minden &eacute;lt felsorolunk: vagyis soronk&eacute;nt megadjuk az adott &eacute;lre illeszked&#337; k&eacute;t cs&uacute;cs sz&aacute;m&aacute;t, &eacute;s amennyiben s&uacute;lyozott a gr&aacute;f, m&eacute;g hozz&aacute;&iacute;rhatjuk az &eacute;l s&uacute;ly&aacute;t is. Minden ilyen sor egy &eacute;lt reprezent&aacute;l, teh&aacute;t pontosan annyi sorunk van, ah&aacute;ny &eacute;l van a gr&aacute;fban. Ilyen &eacute;llista form&aacute;tumot haszn&aacute;l p&eacute;ld&aacute;ul a<a title="DIMACS graph format" href="http:&#47;&#47;prolland.free.fr/works/research/dsat/dimacs.html" target="_blank"> DIMACS gr&aacute;f form&aacute;tuma</a> is.</p>\n<p>P&eacute;lda: Legyen az 1. cs&uacute;cs a Magrathea, a 2. Mordor, a 3. a Tatuin, a 4. pedig a Roxfort Boszork&aacute;ny- &eacute;s Var&aacute;zsl&oacute;k&eacute;pz&#337; Szakiskola. Ekkor a s&uacute;lyozott gr&aacute;fhoz tartoz&oacute; &eacute;llista:</p>\n<pre><code>1 2 15000\n1 3 12500\n1 4 2420\n2 3 9900\n2 3 6600\n3 4 10010\n3 4 42\n</code></pre>', '2016-10-12 08:12:37', '2016-10-17 09:49:50'),
(73, 'comsciblog', 'Brainfuck, avagy programok írása Turing gépre', 'hu', '<p style="text-align: justify;"><strong>A mai bejegyz&eacute;semben a Brianfuck programoz&aacute;si nyelvr&#337;l fogok r&ouml;vid ismertet&#337;t &iacute;rni. A nyelv mer&#337;ben elt&eacute;r a mostan&aacute;ban haszn&aacute;lt programoz&aacute;si nyelvekt&#337;l. Ez&eacute;rt is sorolj&aacute;k gyakran az ezoterikus programoz&aacute;si nyelvek k&ouml;z&eacute;, hasonl&oacute;an az &aacute;ltalam tavaly bemutatott ArnoldC-hez. &Aacute;m m&iacute;g az ArnoldC mind&ouml;ssze szintaktik&aacute;j&aacute;ban t&eacute;r el egy &aacute;tlagos imperat&iacute;v programoz&aacute;si nyelvt&#337;l, addig a Brainfuck egy teljesen m&aacute;s paradigm&aacute;ra &eacute;p&uuml;l, ami miatt kifejezetten izgalmas programoz&aacute;si nyelvnek tal&aacute;lom.</strong></p>\r\n<h3>Mi is az a Brainfuck programoz&aacute;si nyelv?</h3>\r\n<p style="text-align: justify;">A Brainfuck a neve alapj&aacute;n els&#337;re tal&aacute;n komolytalannak t&#369;nhet, viszont egy teljes &eacute;rt&eacute;k&#369; programnyelvnek tekinthet&#337;, m&eacute;g akkor is, ha alapjaiban t&eacute;r el a mai modern programoz&aacute;si nyelvekt&#337;l. Ugyanis mind&ouml;ssze 8 utas&iacute;t&aacute;st ("kulcssz&oacute;t") haszn&aacute;l, amelyek egy karakterb&#337;l &aacute;llnak, &eacute;s tetsz&#337;leges sorrendben haszn&aacute;lhat&oacute;k. Ugyanakkor BF seg&iacute;ts&eacute;g&eacute;vel elm&eacute;letileg minden olyan algoritmus le&iacute;rhat&oacute;, amely sz&aacute;m&iacute;t&oacute;g&eacute;ppel v&eacute;grehajthat&oacute;. A nyelv ugyanis nem m&aacute;s, mint egy Turing g&eacute;p szimul&aacute;tor utas&iacute;t&aacute;sk&eacute;szlete.</p>\r\n<p style="text-align: justify;">A Turing g&eacute;p egy olyan hardverk&eacute;nt k&eacute;pzelhet&#337; el, amely tartalmaz egy v&eacute;gtelen&iacute;tett szalagb&oacute;l&nbsp; &aacute;ll&oacute; mem&oacute;ri&aacute;t, ami cell&aacute;kra van osztva, &eacute;s minden cell&aacute;j&aacute;ban a g&eacute;p &aacute;ltal haszn&aacute;lt &aacute;b&eacute;c&eacute; egy-egy bet&#369;je van. A BF eset&eacute;ben egy cella egy byteot jel&ouml;l, az &aacute;b&eacute;c&eacute; pedig a 0-255 k&ouml;z&ouml;tti sz&aacute;mok. Tov&aacute;bb&aacute; tartalmaz egy &iacute;r&oacute;-olvas&oacute; fejet, ami mozoghat a cell&aacute;k k&ouml;z&ouml;tt jobbra, illetve balra. Ezt a BF &eacute;rtelmez&#337;k &aacute;ltal&aacute;ban egy mutat&oacute; n&ouml;vel&eacute;s&eacute;vel, illetve cs&ouml;kkent&eacute;s&eacute;vel oldj&aacute;k meg. A fej mozg&aacute;s&aacute;t a g&eacute;p vez&eacute;rl&#337;egys&eacute;ge szab&aacute;lyozza, ami jelen esetben a maga BF &eacute;rtelmez&#337;, mik&ouml;zben a BF forr&aacute;sk&oacute;dot olvassa.<br /><br />A BF nyelv utas&iacute;t&aacute;sai:</p>\r\n<ul>\r\n<li>&gt; A fej jobbra mozgat&aacute;sa, vagyis a mutat&oacute;&nbsp;n&ouml;vel&eacute;se eggyel</li>\r\n<li>&lt; A fej balra mozgat&aacute;sa, vagyis a mutat&oacute;&nbsp;cs&ouml;kkent&eacute;se eggyel</li>\r\n<li>+ A mutat&oacute;n&aacute;l&nbsp;lev&#337; byte n&ouml;vel&eacute;se eggyel</li>\r\n<li>- A mutat&oacute;n&aacute;l&nbsp;lev&#337; byte cs&ouml;kkent&eacute;se eggyel</li>\r\n<li>. A mutat&oacute;n&aacute;l&nbsp;lev&#337; cella tartalm&aacute;nak ki&iacute;r&aacute;sa</li>\r\n<li>, Egy karakter&nbsp;bek&eacute;r&eacute;se &eacute;s a mutat&oacute;n&aacute;l l&eacute;v&#337; cell&aacute;n&nbsp;t&aacute;rol&aacute;sa</li>\r\n<li>[ Ugr&aacute;s a k&ouml;vetkez&#337; ] jel ut&aacute;n, ha a mutat&oacute;&nbsp;alatti byte nulla.</li>\r\n<li>] Ugr&aacute;s az el&#337;z&#337; &nbsp;[ jelre</li>\r\n</ul>\r\n<p>Ezeken a karaktereken k&iacute;v&uuml;l minden egy&eacute;b karaktert figyelmen k&iacute;v&uuml;l hagy a BF interpreter, <br />teh&aacute;t tetsz&#337;legesen "kommentezhetj&uuml;k" a forr&aacute;sk&oacute;dunkat.<br /><br />Az al&aacute;bbiakban ismertetek p&aacute;r egyszer&#369;bb algoritmust Turing-g&eacute;pre, BF nyelven. Enn&eacute;l sokkal t&ouml;bb, komplexebb algoritmus tal&aacute;hat&oacute; p&eacute;ld&aacute;ul ezen az oldalon: http:&#47;&#47;esolangs.org/wiki/brainfuck_algorithms<br /><br /></p>\r\n<h3>Karakter beolvas&aacute;sa, majd ki&iacute;r&aacute;sa</h3>\r\n<p>Az egyik legegyszer&#369;bb feladat. Egy&aacute;ltal&aacute;n nincs sz&uuml;ks&eacute;g a mutat&oacute; mozgat&aacute;s&aacute;ra, illetve a mutat&oacute;n l&eacute;v&#337; &eacute;rt&eacute;k v&aacute;ltoztat&aacute;s&aacute;ra.</p>\r\n<pre><code>,.</code></pre>\r\n<h3>Hello World!</h3>\r\n<p>A BF-ben kiz&aacute;r&oacute;lag byteokon dolgozhatunk, &iacute;gy nem tudunk sz&ouml;vegkonstansot egy az egyben ki&iacute;rni a kimenetre. Ugyanakkor k&eacute;pesek vagyunk egy byteon l&eacute;v&#337; &eacute;rt&eacute;k karakteres ki&iacute;r&aacute;s&aacute;ra, n&ouml;vel&eacute;s&eacute;re, illetve cs&ouml;kkent&eacute;s&eacute;re. Ennyi &eacute;ppen elegend&#337; ahhoz, hogy nulla &eacute;rt&eacute;ket tartalmaz&oacute; cell&aacute;n &aacute;ll&oacute; mutat&oacute; eset&eacute;n tetsz&#337;leges sz&ouml;vegkonstanst ki&iacute;rjunk.</p>\r\n<p>Sz&uuml;ks&eacute;g&uuml;nk lehet egy ASCII-t&aacute;bl&aacute;zatra ahhoz, hogy melyik karakterhez milyen k&oacute;d tartozik, vagyis meddig kell n&ouml;veln&uuml;nk<br />a byteon l&eacute;v&#337; &eacute;rt&eacute;ket ahhoz, hogy a megfelel&#337; karaktert ki&iacute;rjuk.</p>\r\n<h4>P&eacute;lda: HELLO</h4>\r\n<p>A mutatott cella/byte &eacute;rt&eacute;ke nulla. (Ahhoz, hogy ezt biztos&iacute;tsuk, olvasd lejjebb)<br />&apos;H&apos; karakter ASCII-k&oacute;dja 72, vagyis hetvenk&eacute;t n&ouml;vel&eacute;s ut&aacute;n a byte &eacute;rt&eacute;ke 72 lesz, amit a kimenetre &iacute;rva &apos;H&apos; karaktert kapunk. Az &apos;E&apos; karakter k&oacute;dja 69, a cell&aacute;nk &eacute;rt&eacute;ke pedig 72,ez&eacute;rt 3 cs&ouml;kkent&eacute;s ut&aacute;n t&ouml;rt&eacute;n&#337; ki&iacute;rat&aacute;s eredm&eacute;nye egy d&iacute;szes &apos;E&apos; karakter. Az &apos;L&apos; &eacute;rt&eacute;ke 76, vagyis most 7 n&ouml;vel&eacute;sre van sz&uuml;ks&eacute;g, majd k&ouml;vetkezhet k&eacute;t ki&iacute;rat&aacute;s, amivel letudtuk a k&eacute;t &apos;L&apos; bet&#369;t.V&eacute;g&uuml;l 3 n&ouml;vel&eacute;s &eacute;s egy ki&iacute;r&aacute;s ut&aacute;n pont ker&uuml;l az i-re, illetve &apos;O&apos; a kimenetre.Vagyis a k&oacute;d (Az elej&eacute;n l&eacute;v&#337; karakter biztos&iacute;tja, hogy a byte &eacute;rt&eacute;ke nulla legyen. A magyar&aacute;zat lejjebb olvashat&oacute;)</p>\r\n<pre><code>[-]++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.---.+++++++..+++. \r\n</code></pre>\r\n<h3>Legegyszer&#369;bb ciklus</h3>\r\n<pre><code> [-]\r\n</code></pre>\r\n<p>Egy adott cell&aacute;t(vagy bytetot) kinull&aacute;z. Vagyis megvizsg&aacute;lja, hogy az adott cell&aacute;n l&eacute;v&#337; &eacute;rt&eacute;k nulla-e ([). Ha nem, cs&ouml;kkenti az &eacute;rt&eacute;ket (-), majd a vez&eacute;rl&eacute;s visszaugrik a ciklus elej&eacute;re, vagyis a [ jelhez, &eacute;s kezd&#337;dik el&ouml;lr&#337;l, am&iacute;g nem teljes&uuml;l a felt&eacute;tel, vagyis am&iacute;g a cella tartalma nem nulla.</p>\r\n<h3><strong>&Ouml;sszead&aacute;s</strong></h3>\r\n<p>egy cella &eacute;rt&eacute;k&eacute;nek hozz&aacute;ad&aacute;sa szomsz&eacute;dos cell&aacute;hoz:</p>\r\n<pre><code>[ &lt;+ &gt; -]\r\n</code></pre>\r\n<p>Tegy&uuml;k fel, hogy a mutat&oacute; a jobb oldali cell&aacute;n &aacute;ll, vagyis amit hozz&aacute; akarunk adni az el&#337;tte l&eacute;v&#337;h&ouml;z. (Ha nem ott, &aacute;ll&iacute;tsuk oda.)<br /> A fenti utas&iacute;t&aacute;ssorozat megvizsg&aacute;lja, hogy nulla-e. Ha nem nulla, eggyel cs&ouml;kkenti a mutat&oacute;t,<br />&eacute;s ahhoz a cell&aacute;hoz hozz&aacute;ad egyet (a n&ouml;velend&#337; "els&#337;") a cella &eacute;rt&eacute;k&eacute;hez. <br />Majd ism&eacute;t n&ouml;veli a mutat&oacute;t, &eacute;s majd eggyel cs&ouml;kkenti az ott tal&aacute;lhat&oacute; (hozz&aacute;adni k&iacute;v&aacute;nt "m&aacute;sodik") cella &eacute;rt&eacute;k&eacute;t.<br /><br />Hasonl&oacute;an m&#369;k&ouml;dhet a kivon&aacute;s is, csak ott mindk&eacute;t &eacute;rt&eacute;ket cs&ouml;kkenteni kell:</p>\r\n<p><br />[ &lt;- &gt; -]</p>\r\n<p>Az elv m&#369;k&ouml;dik nem szomsz&eacute;dos sz&aacute;mokra is. P&eacute;ld&aacute;ul k&eacute;t, egym&aacute;st&oacute;l 5 cell&aacute;nyira l&eacute;v&#337; &eacute;rt&eacute;k &ouml;sszead&aacute;sa:</p>\r\n<pre><code>[ &lt;&lt;&lt;&lt;&lt; + &gt;&gt;&gt;&gt;&gt; -]\r\n</code></pre>\r\n<h3><strong>(Egyjegy&#369;) Sz&aacute;mok beolvas&aacute;sa:</strong></h3>\r\n<p>Karakterek beolvas&aacute;sa egyszer&#369; dolog. Egyjegy&#369; sz&aacute;mok olvas&aacute;sa sem bonyolultabb, hiszen az is egyetlen karakter. Viszont egy sz&aacute;m &eacute;rt&eacute;ke &eacute;s egy sz&aacute;mkarakter ASCII k&oacute;dja nem ugyanaz, teh&aacute;t le kell kezeln&uuml;nk a k&uuml;l&ouml;nbs&eacute;get. &nbsp;A &apos;0&apos; ASCII k&oacute;dja 48, az &apos;1&apos;-&eacute; 49, ... a &apos;9&apos;-&eacute; 57. Vagyis ahhoz, hogy sz&aacute;molni tudjunk egy (egyjegy&#369;) sz&aacute;mmal, cs&ouml;kkenten&uuml;nk kell az beolvasott byteot 48-cal.<br /><br /><span style="text-decoration: underline;"><strong>P&eacute;lda:</strong></span> &nbsp;Beolvasott sz&aacute;mkarakter &aacute;talak&iacute;t&aacute;sa a sz&aacute;m val&oacute;di &eacute;rt&eacute;k&eacute;v&eacute;, vagyis -48.<br /><br /> <strong>1. m&oacute;dszer</strong><br /> ,.------------------------------------------------ <br /><br /></p>\r\n<p>Egyszer&#369;, k&ouml;nnyen olvashat&oacute;. Pontosan 48 m&#369;veletet ig&eacute;nyel (viszont ugyanannyi karakter hossz&uacute; a k&oacute;dja is).<br /><br /> <strong>2. m&oacute;dszer:&nbsp;</strong>Meghat&aacute;rozzuk a 48 konstanst egy &uacute;j byteon/cell&aacute;ban, majd kivonjuk a beolvasott karakterb&#337;l.</p>\r\n<pre><code>,. [-]&gt;[-]&gt;<br />++++++[&lt;++++++++&gt;-] 48 konstans = hatszor nyolc<br />&lt;[ -&lt; -&gt; ] Kivon&aacute;s<br /><strong><br /></strong></code></pre>\r\n<p>A konstanst meghat&aacute;rozhatjuk az el&#337;z&#337; m&oacute;dszerrel, vagyis kinull&aacute;zunk egy cell&aacute;t, &nbsp; &eacute;s null&aacute;t n&ouml;velj&uuml;k 48-szor, vagy kisz&aacute;molhatjuk szorzatk&eacute;nt is. A fenti k&oacute;dr&eacute;szlet ez ut&oacute;bbit mutatja. a 48-at $6 \\cdot 8$-k&eacute;nt sz&aacute;molja ki. Ha a konstans meghat&aacute;roz&aacute;s&aacute;hoz haszn&aacute;lt k&eacute;t cella &eacute;rt&eacute;ke eleve nulla, akkor az els&#337; f&aacute;zisban hatszor n&ouml;velj&uuml;k &nbsp;a sz&aacute;mol&aacute;shoz haszn&aacute;lt els&#337; cell&aacute;t (6 m&#369;velet), majd a ciklusban l&aacute;that&oacute; 11 m&#369;velet (k&eacute;t fejmozgat&aacute;s, 8 n&ouml;vel&eacute;s,illetve egy cs&ouml;kkent&eacute;s), ami pontosan hatszor fut le. Teh&aacute;t csak a 48 kisz&aacute;mol&aacute;s&aacute;hoz felhaszn&aacute;lunk legal&aacute;bb $6+6 \\cdot 11 = 72$ m&#369;velet kell (ha mindk&eacute;t cella &eacute;rt&eacute;ke eleve 0, egy&eacute;bk&eacute;nt m&eacute;g hozz&aacute;j&ouml;n a kinull&aacute;z&aacute;s k&ouml;lts&eacute;ge). Majd ezt a sz&aacute;mot (48) kivonjuk a beolvasott &eacute;rt&eacute;kb&#337;l: vagyis <em>addig cs&ouml;kkentj&uuml;k mindk&eacute;t &eacute;rt&eacute;ket, am&iacute;g az kivonand&oacute; (48) nem lesz nulla</em>. Vagyis a <strong>[ -&lt; -&gt; ]</strong> ciklus <em>ekkor 48-szor fut le,</em> &eacute;s 4 m&#369;veletet tartalmaz 2 fejmozgat&aacute;st &eacute;s 2 cs&ouml;kkent&eacute;st, teh&aacute;t $48 \\cdot 4 = 192 $m&#369;veletet. &Ouml;sszesen teh&aacute;t legal&aacute;bb $192+72 = 264 $m&#369;veletet haszn&aacute;lunk, de legal&aacute;bb valamivel r&ouml;videbb &nbsp;(&eacute;s olvashatatlanabb :) a k&oacute;d.</p>\r\n<p><br /><strong>Sz&aacute;mok &ouml;sszead&aacute;sa</strong><br /><br />A fent le&iacute;rtak alapj&aacute;n elk&eacute;sz&iacute;thet&uuml;nk egy olyan komplex alkalmaz&aacute;st, amely k&eacute;t egyjegy&#369; sz&aacute;mot bek&eacute;r,<br />&eacute;s &ouml;sszeadja &#337;ket! L&aacute;ssuk, mire van sz&uuml;ks&eacute;g&uuml;nk: Beolvasunk egy karaktert, &eacute;s sz&aacute;mm&aacute; alak&iacute;tjuk (persze, hogy a lassabb, &eacute;s bonyolultabb m&oacute;dszerrel :)</p>\r\n<pre><code>,. Beolvas&aacute;s &gt;&gt;&nbsp; Pointer l&eacute;ptet&eacute;se a 48 konstans kisz&aacute;mol&aacute;s&aacute;hoz\r\n++++++[&lt;++++++++&gt;-] 48 konstans = hatszor nyolc\r\n&lt;\r\n[ -&lt; -&gt; ] kivon&aacute;s = #1 &eacute;s #2 cs&ouml;kkent&eacute;se am&iacute;g #2 el nem fogy\r\n</code></pre>\r\n<p><br />Majd a mutat&oacute; jobbra l&eacute;ptet&eacute;se ut&aacute;n (&gt;) ugyan&iacute;gy beolvassuk a m&aacute;sodik sz&aacute;mot is.<br />Esetleg k&ouml;zben ki&iacute;rhatunk a konzolra k&uuml;l&ouml;nb&ouml;z&#337; karaktereket, p&eacute;ld&aacute;ul +-jelet (ASCII k&oacute;d: 43), <br />vagy = jelet (ASCII k&oacute;d: 61). A v&eacute;g&eacute;n pedig nincs m&aacute;s dolgunk, mit &ouml;sszeadni k&eacute;t szomsz&eacute;dos cella tartalm&aacute;t, &eacute;s ki&iacute;rni az eredm&eacute;nyt.</p>\r\n<p>Ki&iacute;r&aacute;sn&aacute;l azonban figyelni kell arra, hogy az eredm&eacute;nyt ism&eacute;t sz&aacute;mkarakterr&eacute; kell alak&iacute;tani.<br />R&aacute;ad&aacute;sul arra is figyelni kell, hogy <em>k&eacute;t egyjegy&#369; sz&aacute;m &ouml;sszege lehet k&eacute;tjegy&#369; is</em>, amit el&eacute;g sok bonyodalomhoz vezet, ami n&eacute;mi Google &eacute;s Stackoverflow haszn&aacute;lat seg&iacute;ts&eacute;g&eacute;vel k&ouml;nnyen &aacute;thidalhat&oacute;:<br /><br /></p>\r\n<p><strong>Eredm&eacute;ny ki&iacute;rat&aacute;sa</strong> (<em>I have no idea what I am doing</em>):</p>\r\n<pre><code>&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-<br />&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[&gt;++++++[-&lt;++++++++&gt;]&lt;.&lt;&lt;+&gt;+&gt;[-]]&lt;[&lt;[-&gt;-&lt;]++++++[-&gt;++++++++<br />&lt;]&gt;.[-]]&lt;&lt;++++++[-&lt;++++++++&gt;]&lt;.[-]&lt;&lt;[-&lt;+&gt;]\r\n</code></pre>\r\n<p>A m&oacute;dszer el&#337;nye, hogy m&#369;k&ouml;dik, a h&aacute;tr&aacute;nya pedig, hogy fogalmam sincs, hogyan :)<br />Aki esetleg &eacute;rti, nyugodtan elmagyar&aacute;zhatja. Valamif&eacute;le 10-zel val&oacute; oszt&aacute;s(okat) &eacute;s marad&eacute;kk&eacute;pz&eacute;s(eke)t <br />sejtek a h&aacute;tt&eacute;rben... A teljes k&oacute;d megtal&aacute;lhat&oacute; GitHubon.</p>\r\n<h3>n (egyjegy&#369;) sz&aacute;m &ouml;sszead&aacute;sa</h3>\r\n<p>Miut&aacute;n ilyen "professzion&aacute;lisan" &ouml;sszeadtam k&eacute;t sz&aacute;mot, ideje az &aacute;ltal&aacute;nos&iacute;t&aacute;shoz. <br />Olvassunk be egy $n$ &eacute;rt&eacute;ket, majd $n$ beolvasott sz&aacute;mot adjunk &ouml;ssze! <br />A beolvasand&oacute; sz&aacute;mok tov&aacute;bbra is egyjegy&#369;ek, de term&eacute;szetesen l&eacute;tezik algoritmus<br />t&ouml;bbjegy&#369; sz&aacute;mok haszn&aacute;lat&aacute;ra is. A Google itt is seg&iacute;thet(ne), de azt most nem csin&aacute;ltam meg.<br /><br />1. Kezdetben beolvasom $n$ &eacute;rt&eacute;k&eacute;t az els&#337; cell&aacute;ba. Ez a cella t&aacute;rolja, hogy m&eacute;g h&aacute;nyszor kell lefutnia az &ouml;sszead&oacute; ciklusnak. A v&eacute;g&eacute;n pedig jobbra l&eacute;ptetem a mutat&oacute;t.</p>\r\n<pre><code>,.------------------------------------------------ &gt;\r\n</code></pre>\r\n<p>2. Beolvasom az els&#337; &eacute;rt&eacute;ket a m&aacute;sodik cell&aacute;ba. Ebben a cell&aacute;ban fogom t&aacute;rolni a jelenlegi &ouml;sszeget. &nbsp;<br />A beolvas&aacute;s ut&aacute;n eggyel cs&ouml;kkenthet&#337; az els&#337; cella, vagyis a ciklus sz&aacute;ml&aacute;l&oacute;ja.<br /><br />Els&#337; sz&aacute;m bek&eacute;r&eacute;se (#2 cella: akkumul&aacute;tor cella)</p>\r\n<pre><code>,.------------------------------------------------\r\n&lt;- Sz&aacute;ml&aacute;l&oacute; (#1) cs&ouml;kkent&eacute;se\r\n</code></pre>\r\n<p>Majd egy ciklusban olvasunk a 3. cell&aacute;ba sz&aacute;mokat, amiket rendre hozz&aacute;adunk az &ouml;sszeget tartalmaz&oacute;, 2. cell&aacute;hoz, &eacute;s cs&ouml;kkentj&uuml;k az 1. cell&aacute;ban l&eacute;v&#337; sz&aacute;ml&aacute;l&oacute;t, am&iacute;g az el nem fogy:</p>\r\n<pre><code>[ &gt;&gt; [-]<br /><br />&nbsp;&nbsp; &nbsp;Tov&aacute;bbi sz&aacute;mok beolvas&aacute;sa (#3 cell&aacute;ba)<br />&nbsp;&nbsp; &nbsp;,.------------------------------------------------<br />&nbsp;&nbsp; &nbsp; <br />&nbsp;&nbsp; &nbsp;&Ouml;sszead&aacute;s [ -&lt; +&gt; ]&nbsp;&nbsp; #2 akkumul&aacute;tor n&ouml;vel&eacute;se &eacute;s #3 cs&ouml;kkent&eacute;se am&iacute;g el nem fogy<br /><br />&lt;&lt;-&nbsp;&nbsp;&nbsp; #1 Ciklus sz&aacute;ml&aacute;l&oacute; cs&ouml;kkent&eacute;se<br />]<br />\r\n</code></pre>\r\n<p>A teljes k&oacute;d megtal&aacute;lhat&oacute; a GitHubon. Szerintem kifejezetten &eacute;rdekes nyelv, &eacute;rdemes kipr&oacute;b&aacute;lni!</p>', '2017-01-08 10:38:13', '2017-01-09 09:07:45');

-- --------------------------------------------------------

--
-- Tábla szerkezet: `post_category`
--

CREATE TABLE IF NOT EXISTS `post_category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `post_id` int(11) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=25 ;

--
-- A tábla adatainak kiíratása `post_category`
--

INSERT INTO `post_category` (`id`, `post_id`, `category_id`) VALUES
(1, 26, 1),
(2, 34, 1),
(3, 35, 1),
(4, 36, 1),
(5, 37, 1),
(6, 39, 1),
(7, 41, 1),
(8, 42, 1),
(9, 46, 1),
(10, 49, 1),
(12, 56, 2),
(13, 55, 2),
(14, 54, 2),
(15, 58, 2),
(16, 57, 2),
(17, 60, 2),
(18, 61, 2),
(19, 63, 3),
(20, 64, 3),
(21, 65, 3),
(22, 66, 1),
(23, 67, 3),
(24, 69, 3);

-- --------------------------------------------------------

--
-- Tábla szerkezet: `user`
--

CREATE TABLE IF NOT EXISTS `user` (
  `user_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `password` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_username_unique` (`username`),
  UNIQUE KEY `user_email_unique` (`email`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=3 ;

--
-- A tábla adatainak kiíratása `user`
--

INSERT INTO `user` (`user_id`, `username`, `password`, `email`, `created_at`, `updated_at`) VALUES
(2, 'comsciblog', '$2y$10$CIE.lOifg165LeazYdHol.6Fqt7ip5j37B0iuauSX5DfWxz72lNBC', 'strahlistvan0@gmail.com', '2015-07-30 11:57:54', '2015-07-30 11:57:54');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
